/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/auth": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Authenticate
         * @description **Access policy**: public
         *     Use this environment(endpoint) to authenticate against Portainer using a username and password.
         */
        post: operations["AuthenticateUser"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/logout": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Logout
         * @description **Access policy**: public
         */
        post: operations["Logout"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/oauth/validate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Authenticate with OAuth
         * @description **Access policy**: public
         */
        post: operations["ValidateOAuth"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/backup": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Creates an archive with a system data snapshot that could be used to restore the system.
         * @description Creates an archive with a system data snapshot that could be used to restore the system.
         *     **Access policy**: admin
         */
        post: operations["Backup"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/custom_templates": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List available custom templates
         * @description List available custom templates.
         *     **Access policy**: authenticated
         */
        get: operations["CustomTemplateList"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/custom_templates/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Inspect a custom template
         * @description Retrieve details about a template.
         *     **Access policy**: authenticated
         */
        get: operations["CustomTemplateInspect"];
        /**
         * Update a template
         * @description Update a template.
         *     **Access policy**: authenticated
         */
        put: operations["CustomTemplateUpdate"];
        post?: never;
        /**
         * Remove a template
         * @description Remove a template.
         *     **Access policy**: authenticated
         */
        delete: operations["CustomTemplateDelete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/custom_templates/{id}/file": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Template stack file content.
         * @description Retrieve the content of the Stack file for the specified custom template
         *     **Access policy**: authenticated
         */
        get: operations["CustomTemplateFile"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/custom_templates/{id}/git_fetch": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * Fetch the latest config file content based on custom template's git repository configuration
         * @description Retrieve details about a template created from git repository method.
         *     **Access policy**: authenticated
         */
        put: operations["CustomTemplateGitFetch"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/custom_templates/create/file": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create a custom template
         * @description Create a custom template.
         *     **Access policy**: authenticated
         */
        post: operations["CustomTemplateCreateFile"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/custom_templates/create/repository": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create a custom template
         * @description Create a custom template.
         *     **Access policy**: authenticated
         */
        post: operations["CustomTemplateCreateRepository"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/custom_templates/create/string": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create a custom template
         * @description Create a custom template.
         *     **Access policy**: authenticated
         */
        post: operations["CustomTemplateCreateString"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/docker/{environmentId}/containers/{containerId}/gpus": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Fetch container gpus data
         * @description **Access policy**:
         */
        get: operations["dockerContainerGpusInspect"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/docker/{environmentId}/dashboard": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Get counters for the dashboard
         * @description **Access policy**: restricted
         */
        post: operations["dockerDashboard"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/docker/{environmentId}/images": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Fetch images
         * @description **Access policy**:
         */
        get: operations["dockerImagesList"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/edge_groups": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * list EdgeGroups
         * @description **Access policy**: administrator
         */
        get: operations["EdgeGroupList"];
        put?: never;
        /**
         * Create an EdgeGroup
         * @description **Access policy**: administrator
         */
        post: operations["EdgeGroupCreate"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/edge_groups/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Inspects an EdgeGroup
         * @description **Access policy**: administrator
         */
        get: operations["EdgeGroupInspect"];
        /**
         * Updates an EdgeGroup
         * @description **Access policy**: administrator
         */
        put: operations["EgeGroupUpdate"];
        post?: never;
        /**
         * Deletes an EdgeGroup
         * @description **Access policy**: administrator
         */
        delete: operations["EdgeGroupDelete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/edge_jobs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Fetch EdgeJobs list
         * @description **Access policy**: administrator
         */
        get: operations["EdgeJobList"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/edge_jobs/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Inspect an EdgeJob
         * @description **Access policy**: administrator
         */
        get: operations["EdgeJobInspect"];
        /**
         * Update an EdgeJob
         * @description **Access policy**: administrator
         */
        put: operations["EdgeJobUpdate"];
        post?: never;
        /**
         * Delete an EdgeJob
         * @description **Access policy**: administrator
         */
        delete: operations["EdgeJobDelete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/edge_jobs/{id}/file": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Fetch a file of an EdgeJob
         * @description **Access policy**: administrator
         */
        get: operations["EdgeJobFile"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/edge_jobs/{id}/tasks": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Fetch the list of tasks on an EdgeJob
         * @description **Access policy**: administrator
         */
        get: operations["EdgeJobTasksList"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/edge_jobs/{id}/tasks/{taskID}/logs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Fetch the log for a specifc task on an EdgeJob
         * @description **Access policy**: administrator
         */
        get: operations["EdgeJobTaskLogsInspect"];
        put?: never;
        /**
         * Collect the log for a specifc task on an EdgeJob
         * @description **Access policy**: administrator
         */
        post: operations["EdgeJobTasksCollect"];
        /**
         * Clear the log for a specifc task on an EdgeJob
         * @description **Access policy**: administrator
         */
        delete: operations["EdgeJobTasksClear"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/edge_jobs/create/file": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create an EdgeJob from a file
         * @description **Access policy**: administrator
         */
        post: operations["EdgeJobCreateFile"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/edge_jobs/create/string": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create an EdgeJob from a text
         * @description **Access policy**: administrator
         */
        post: operations["EdgeJobCreateString"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/edge_stacks": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Fetches the list of EdgeStacks
         * @description **Access policy**: administrator
         */
        get: operations["EdgeStackList"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/edge_stacks/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Inspect an EdgeStack
         * @description **Access policy**: administrator
         */
        get: operations["EdgeStackInspect"];
        /**
         * Update an EdgeStack
         * @description **Access policy**: administrator
         */
        put: operations["EdgeStackUpdate"];
        post?: never;
        /**
         * Delete an EdgeStack
         * @description **Access policy**: administrator
         */
        delete: operations["EdgeStackDelete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/edge_stacks/{id}/file": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Fetches the stack file for an EdgeStack
         * @description **Access policy**: administrator
         */
        get: operations["EdgeStackFile"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/edge_stacks/{id}/status": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * Update an EdgeStack status
         * @description Authorized only if the request is done by an Edge Environment(Endpoint)
         */
        put: operations["EdgeStackStatusUpdate"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/edge_stacks/create/file": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create an EdgeStack from file
         * @description **Access policy**: administrator
         */
        post: operations["EdgeStackCreateFile"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/edge_stacks/create/repository": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create an EdgeStack from a git repository
         * @description **Access policy**: administrator
         */
        post: operations["EdgeStackCreateRepository"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/edge_stacks/create/string": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create an EdgeStack from a text
         * @description **Access policy**: administrator
         */
        post: operations["EdgeStackCreateString"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/endpoint_groups": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Environment(Endpoint) groups
         * @description List all environment(endpoint) groups based on the current user authorizations. Will
         *     return all environment(endpoint) groups if using an administrator account otherwise it will
         *     only return authorized environment(endpoint) groups.
         *     **Access policy**: restricted
         */
        get: operations["EndpointGroupList"];
        put?: never;
        /**
         * Create an Environment(Endpoint) Group
         * @description Create a new environment(endpoint) group.
         *     **Access policy**: administrator
         */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            /** @description Environment(Endpoint) Group details */
            requestBody: {
                content: {
                    "application/json": components["schemas"]["endpointgroups.endpointGroupCreatePayload"];
                };
            };
            responses: {
                /** @description Success */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["portainer.EndpointGroup"];
                    };
                };
                /** @description Invalid request */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description Server error */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/endpoint_groups/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Inspect an Environment(Endpoint) group
         * @description Retrieve details abont an environment(endpoint) group.
         *     **Access policy**: administrator
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description Environment(Endpoint) group identifier */
                    id: number;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Success */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["portainer.EndpointGroup"];
                    };
                };
                /** @description Invalid request */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description EndpointGroup not found */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description Server error */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        /**
         * Update an environment(endpoint) group
         * @description Update an environment(endpoint) group.
         *     **Access policy**: administrator
         */
        put: operations["EndpointGroupUpdate"];
        post?: never;
        /**
         * Remove an environment(endpoint) group
         * @description Remove an environment(endpoint) group.
         *     **Access policy**: administrator
         */
        delete: operations["EndpointGroupDelete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/endpoint_groups/{id}/endpoints/{endpointId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * Add an environment(endpoint) to an environment(endpoint) group
         * @description Add an environment(endpoint) to an environment(endpoint) group
         *     **Access policy**: administrator
         */
        put: operations["EndpointGroupAddEndpoint"];
        post?: never;
        /**
         * Removes environment(endpoint) from an environment(endpoint) group
         * @description **Access policy**: administrator
         */
        delete: operations["EndpointGroupDeleteEndpoint"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/endpoints": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List environments(endpoints)
         * @description List all environments(endpoints) based on the current user authorizations. Will
         *     return all environments(endpoints) if using an administrator or team leader account otherwise it will
         *     only return authorized environments(endpoints).
         *     **Access policy**: restricted
         */
        get: operations["EndpointList"];
        put?: never;
        /**
         * Create a new environment(endpoint)
         * @description Create a new environment(endpoint) that will be used to manage an environment(endpoint).
         *     **Access policy**: administrator
         */
        post: operations["EndpointCreate"];
        /**
         * Remove multiple environments
         * @deprecated
         * @description Deprecated: use the `POST` endpoint instead.
         *     Remove multiple environments and optionally clean-up associated resources.
         *     **Access policy**: Administrator only.
         */
        delete: operations["EndpointDeleteBatchDeprecated"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/endpoints/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Inspect an environment(endpoint)
         * @description Retrieve details about an environment(endpoint).
         *     **Access policy**: restricted
         */
        get: operations["EndpointInspect"];
        /**
         * Update an environment(endpoint)
         * @description Update an environment(endpoint).
         *     **Access policy**: authenticated
         */
        put: operations["EndpointUpdate"];
        post?: never;
        /**
         * Remove an environment
         * @description Remove the environment associated to the specified identifier and optionally clean-up associated resources.
         *     **Access policy**: Administrator only.
         */
        delete: operations["EndpointDelete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/endpoints/{id}/association": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * De-association an edge environment(endpoint)
         * @description De-association an edge environment(endpoint).
         *     **Access policy**: administrator
         */
        put: operations["EndpointAssociationDelete"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/endpoints/{id}/docker/v2/browse/put": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Upload a file under a specific path on the file system of an environment (endpoint)
         * @description Use this environment(endpoint) to upload TLS files.
         *     **Access policy**: administrator
         */
        post: {
            parameters: {
                query?: {
                    /** @description Optional volume identifier to upload the file */
                    volumeID?: string;
                };
                header?: never;
                path: {
                    /** @description Environment(Endpoint) identifier */
                    id: number;
                };
                cookie?: never;
            };
            requestBody: {
                content: {
                    "multipart/form-data": {
                        /** @description The destination path to upload the file to */
                        Path: string;
                        /**
                         * Format: binary
                         * @description The file to upload
                         */
                        file: string;
                    };
                };
            };
            responses: {
                /** @description Success */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description Invalid request */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description Server error */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/endpoints/{id}/dockerhub/{registryId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * fetch docker pull limits
         * @description get docker pull limits for a docker hub registry in the environment
         *     **Access policy**:
         */
        get: operations["endpointDockerhubStatus"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/endpoints/{id}/edge/jobs/{jobID}/logs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Inspect an EdgeJob Log
         * @description **Access policy**: public
         */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description environment(endpoint) Id */
                    id: number;
                    /** @description Job Id */
                    jobID: number;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description Bad Request */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description Internal Server Error */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/endpoints/{id}/edge/stacks/{stackId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Inspect an Edge Stack for an Environment(Endpoint)
         * @description **Access policy**: public
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description environment(endpoint) Id */
                    id: number;
                    /** @description EdgeStack Id */
                    stackId: number;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["edge.StackPayload"];
                    };
                };
                /** @description Bad Request */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description Not Found */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description Internal Server Error */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/endpoints/{id}/edge/status": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get environment(endpoint) status
         * @description environment(endpoint) for edge agent to check status of environment(endpoint)
         *     **Access policy**: restricted only to Edge environments(endpoints)
         */
        get: operations["EndpointEdgeStatusInspect"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/endpoints/{id}/forceupdateservice": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * force update a docker service
         * @description force update a docker service
         *     **Access policy**: authenticated
         */
        put: operations["endpointForceUpdateService"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/endpoints/{id}/kubernetes/helm": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Helm Releases
         * @description **Access policy**: authenticated
         */
        get: operations["HelmList"];
        put?: never;
        /**
         * Install Helm Chart
         * @description **Access policy**: authenticated
         */
        post: operations["HelmInstall"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/endpoints/{id}/kubernetes/helm/{release}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Delete Helm Release
         * @description **Access policy**: authenticated
         */
        delete: operations["HelmDelete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/endpoints/{id}/registries": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Registries on environment
         * @description List all registries based on the current user authorizations in current environment.
         *     **Access policy**: authenticated
         */
        get: operations["endpointRegistriesList"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/endpoints/{id}/registries/{registryId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * update registry access for environment
         * @description **Access policy**: authenticated
         */
        put: operations["endpointRegistryAccess"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/endpoints/{id}/settings": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * Update settings for an environment(endpoint)
         * @description Update settings for an environment(endpoint).
         *     **Access policy**: authenticated
         */
        put: operations["EndpointSettingsUpdate"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/endpoints/{id}/snapshot": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Snapshots an environment(endpoint)
         * @description Snapshots an environment(endpoint)
         *     **Access policy**: administrator
         */
        post: operations["EndpointSnapshot"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/endpoints/delete": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Remove multiple environments
         * @description Remove multiple environments and optionally clean-up associated resources.
         *     **Access policy**: Administrator only.
         */
        post: operations["EndpointDeleteBatch"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/endpoints/global-key": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Create or retrieve the endpoint for an EdgeID */
        post: operations["EndpointCreateGlobalKey"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/endpoints/relations": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * Update relations for a list of environments
         * @description Update relations for a list of environments
         *     Edge groups, tags and environment group can be updated.
         *
         *     **Access policy**: administrator
         */
        put: operations["EndpointUpdateRelations"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/endpoints/snapshot": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Snapshot all environments(endpoints)
         * @description Snapshot all environments(endpoints)
         *     **Access policy**: administrator
         */
        post: operations["EndpointSnapshots"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/gitops/repo/file/preview": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * preview the content of target file in the git repository
         * @description Retrieve the compose file content based on git repository configuration
         *     **Access policy**: authenticated
         */
        post: operations["GitOperationRepoFilePreview"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/kubernetes/{id}/applications": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a list of applications across all namespaces in the cluster. If the nodeName is provided, it will return the applications running on that node.
         * @description Get a list of applications across all namespaces in the cluster. If the nodeName is provided, it will return the applications running on that node.
         *     **Access policy**: authenticated
         */
        get: operations["GetAllKubernetesApplications"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/kubernetes/{id}/applications/count": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Applications count
         * @description Get the count of Applications across all namespaces in the cluster. If the nodeName is provided, it will return the count of applications running on that node.
         *     **Access policy**: Authenticated user.
         */
        get: operations["GetAllKubernetesApplicationsCount"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/kubernetes/{id}/cluster_role_bindings/delete": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Delete cluster role bindings
         * @description Delete the provided list of cluster role bindings.
         *     **Access policy**: Authenticated user.
         */
        post: operations["DeleteClusterRoleBindings"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/kubernetes/{id}/cluster_roles/delete": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Delete cluster roles
         * @description Delete the provided list of cluster roles.
         *     **Access policy**: Authenticated user.
         */
        post: operations["DeleteClusterRoles"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/kubernetes/{id}/clusterrolebindings": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a list of kubernetes cluster role bindings
         * @description Get a list of kubernetes cluster role bindings within the given environment at the cluster level.
         *     **Access policy**: Authenticated user.
         */
        get: operations["GetAllKubernetesClusterRoleBindings"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/kubernetes/{id}/clusterroles": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a list of kubernetes cluster roles
         * @description Get a list of kubernetes cluster roles within the given environment at the cluster level.
         *     **Access policy**: Authenticated user.
         */
        get: operations["GetAllKubernetesClusterRoles"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/kubernetes/{id}/configmaps": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a list of ConfigMaps
         * @description Get a list of ConfigMaps across all namespaces in the cluster. For non-admin users, it will only return ConfigMaps based on the namespaces that they have access to.
         *     **Access policy**: Authenticated user.
         */
        get: operations["GetAllKubernetesConfigMaps"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/kubernetes/{id}/configmaps/count": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get ConfigMaps count
         * @description Get the count of ConfigMaps across all namespaces in the cluster. For non-admin users, it will only return the count of ConfigMaps based on the namespaces that they have access to.
         *     **Access policy**: Authenticated user.
         */
        get: operations["GetAllKubernetesConfigMapsCount"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/kubernetes/{id}/cron_jobs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a list of kubernetes Cron Jobs
         * @description Get a list of kubernetes Cron Jobs that the user has access to.
         *     **Access policy**: Authenticated user.
         */
        get: operations["GetKubernetesCronJobs"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/kubernetes/{id}/cron_jobs/delete": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Delete Cron Jobs
         * @description Delete the provided list of Cron Jobs.
         *     **Access policy**: Authenticated user.
         */
        post: operations["DeleteCronJobs"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/kubernetes/{id}/dashboard": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get the dashboard summary data
         * @description Get the dashboard summary data which is simply a count of a range of different commonly used kubernetes resources.
         *     **Access policy**: Authenticated user.
         */
        get: operations["GetKubernetesDashboard"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/kubernetes/{id}/ingresscontrollers": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a list of ingress controllers
         * @description Get a list of ingress controllers for the given environment. If the allowedOnly query parameter is set, only ingress controllers that are allowed by the environment's ingress configuration will be returned.
         *     **Access policy**: Authenticated user.
         */
        get: operations["GetAllKubernetesIngressControllers"];
        /**
         * Update (block/unblock) ingress controllers
         * @description Update (block/unblock) ingress controllers for the provided environment.
         *     **Access policy**: Authenticated user.
         */
        put: operations["UpdateKubernetesIngressControllers"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/kubernetes/{id}/ingresses": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get kubernetes ingresses at the cluster level
         * @description Get kubernetes ingresses at the cluster level for the provided environment.
         *     **Access policy**: Authenticated user.
         */
        get: operations["GetAllKubernetesClusterIngresses"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/kubernetes/{id}/ingresses/count": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Ingresses count
         * @description Get the number of kubernetes ingresses within the given environment.
         *     **Access policy**: Authenticated user.
         */
        get: operations["GetAllKubernetesClusterIngressesCount"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/kubernetes/{id}/ingresses/delete": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Delete one or more Ingresses
         * @description Delete one or more Ingresses in the provided environment.
         *     **Access policy**: Authenticated user.
         */
        post: operations["DeleteKubernetesIngresses"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/kubernetes/{id}/jobs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a list of kubernetes Jobs
         * @description Get a list of kubernetes Jobs that the user has access to.
         *     **Access policy**: Authenticated user.
         */
        get: operations["GetKubernetesJobs"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/kubernetes/{id}/jobs/delete": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Delete Jobs
         * @description Delete the provided list of Jobs.
         *     **Access policy**: Authenticated user.
         */
        post: operations["DeleteJobs"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/kubernetes/{id}/max_resource_limits": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get max CPU and memory limits of all nodes within k8s cluster
         * @description Get max CPU and memory limits (unused resources) of all nodes within k8s cluster.
         *     **Access policy**: Authenticated user.
         */
        get: operations["GetKubernetesMaxResourceLimits"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/kubernetes/{id}/metrics/applications_resources": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get the total resource requests and limits of all applications
         * @description Get the total CPU (cores) and memory (bytes) requests and limits of all applications across all namespaces.
         *     **Access policy**: Authenticated user.
         */
        get: operations["GetApplicationsResources"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/kubernetes/{id}/metrics/nodes": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a list of nodes with their live metrics
         * @description Get a list of metrics associated with all nodes of a cluster.
         *     **Access policy**: Authenticated user.
         */
        get: operations["GetKubernetesMetricsForAllNodes"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/kubernetes/{id}/metrics/nodes/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get live metrics for a node
         * @description Get live metrics for the specified node.
         *     **Access policy**: Authenticated user.
         */
        get: operations["GetKubernetesMetricsForNode"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/kubernetes/{id}/metrics/pods/{namespace}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a list of pods with their live metrics
         * @description Get a list of pods with their live metrics for the specified namespace.
         *     **Access policy**: Authenticated user.
         */
        get: operations["GetKubernetesMetricsForAllPods"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/kubernetes/{id}/metrics/pods/{namespace}/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get live metrics for a pod
         * @description Get live metrics for the specified pod.
         *     **Access policy**: Authenticated user.
         */
        get: operations["GetKubernetesMetricsForPod"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/kubernetes/{id}/namespaces": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a list of namespaces
         * @description Get a list of all namespaces within the given environment based on the user role and permissions. If the user is an admin, they can access all namespaces. If the user is not an admin, they can only access namespaces that they have access to.
         *     **Access policy**: Authenticated user.
         */
        get: operations["GetKubernetesNamespaces"];
        /**
         * Update a namespace
         * @description Update a namespace within the given environment.
         *     **Access policy**: Authenticated user.
         */
        put: operations["UpdateKubernetesNamespaceDeprecated"];
        /**
         * Create a namespace
         * @description Create a namespace within the given environment.
         *     **Access policy**: Authenticated user.
         */
        post: operations["CreateKubernetesNamespace"];
        /**
         * Delete a kubernetes namespace
         * @description Delete a kubernetes namespace within the given environment.
         *     **Access policy**: Authenticated user.
         */
        delete: operations["DeleteKubernetesNamespace"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/kubernetes/{id}/namespaces/{namespace}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get namespace details
         * @description Get namespace details for the provided namespace within the given environment.
         *     **Access policy**: Authenticated user.
         */
        get: operations["GetKubernetesNamespace"];
        /**
         * Update a namespace
         * @description Update a namespace within the given environment.
         *     **Access policy**: Authenticated user.
         */
        put: operations["UpdateKubernetesNamespace"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/kubernetes/{id}/namespaces/{namespace}/configmaps/{configmap}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a ConfigMap
         * @description Get a ConfigMap by name for a given namespace.
         *     **Access policy**: Authenticated user.
         */
        get: operations["GetKubernetesConfigMap"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/kubernetes/{id}/namespaces/{namespace}/ingresscontrollers": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a list ingress controllers by namespace
         * @description Get a list of ingress controllers for the given environment in the provided namespace.
         *     **Access policy**: Authenticated user.
         */
        get: operations["GetKubernetesIngressControllersByNamespace"];
        /**
         * Update (block/unblock) ingress controllers by namespace
         * @description Update (block/unblock) ingress controllers by namespace for the provided environment.
         *     **Access policy**: Authenticated user.
         */
        put: operations["UpdateKubernetesIngressControllersByNamespace"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/kubernetes/{id}/namespaces/{namespace}/ingresses": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a list of Ingresses
         * @description Get a list of Ingresses. If namespace is provided, it will return the list of Ingresses in that namespace.
         *     **Access policy**: Authenticated user.
         */
        get: operations["GetAllKubernetesIngresses"];
        /**
         * Update an Ingress
         * @description Update an Ingress for the provided environment.
         *     **Access policy**: Authenticated user.
         */
        put: operations["UpdateKubernetesIngress"];
        /**
         * Create an Ingress
         * @description Create an Ingress for the provided environment.
         *     **Access policy**: Authenticated user.
         */
        post: operations["CreateKubernetesIngress"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/kubernetes/{id}/namespaces/{namespace}/ingresses/{ingress}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get an Ingress by name
         * @description Get an Ingress by name for the provided environment.
         *     **Access policy**: Authenticated user.
         */
        get: operations["GetKubernetesIngress"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/kubernetes/{id}/namespaces/{namespace}/secrets/{secret}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a Secret
         * @description Get a Secret by name for a given namespace.
         *     **Access policy**: Authenticated user.
         */
        get: operations["GetKubernetesSecret"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/kubernetes/{id}/namespaces/{namespace}/services": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a list of services for a given namespace
         * @description Get a list of services for a given namespace.
         *     **Access policy**: Authenticated user.
         */
        get: operations["GetKubernetesServicesByNamespace"];
        /**
         * Update a service
         * @description Update a service within a given namespace.
         *     **Access policy**: Authenticated user.
         */
        put: operations["UpdateKubernetesService"];
        /**
         * Create a service
         * @description Create a service within a given namespace
         *     **Access policy**: Authenticated user.
         */
        post: operations["CreateKubernetesService"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/kubernetes/{id}/namespaces/{namespace}/system": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * Toggle the system state for a namespace
         * @description Toggle the system state for a namespace
         *     **Access policy**: Administrator or environment administrator.
         */
        put: operations["KubernetesNamespacesToggleSystem"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/kubernetes/{id}/namespaces/{namespace}/volumes": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Kubernetes volumes within a namespace in the given Portainer environment
         * @description Get a list of kubernetes volumes within the specified namespace in the given environment (Endpoint). The Endpoint ID must be a valid Portainer environment identifier.
         *     **Access policy**: Authenticated user.
         */
        get: operations["GetKubernetesVolumesInNamespace"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/kubernetes/{id}/namespaces/count": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get the total number of kubernetes namespaces within the given Portainer environment.
         * @description Get the total number of kubernetes namespaces within the given environment, including the system namespaces. The total count depends on the user's role and permissions.
         *     **Access policy**: Authenticated user.
         */
        get: operations["GetKubernetesNamespacesCount"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/kubernetes/{id}/nodes_limits": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get CPU and memory limits of all nodes within k8s cluster
         * @description Get CPU and memory limits of all nodes within k8s cluster.
         *     **Access policy**: Authenticated user.
         */
        get: operations["GetKubernetesNodesLimits"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/kubernetes/{id}/rbac_enabled": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Check if RBAC is enabled
         * @description Check if RBAC is enabled in the specified Kubernetes cluster.
         *     **Access policy**: Authenticated user.
         */
        get: operations["GetKubernetesRBACStatus"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/kubernetes/{id}/role_bindings/delete": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Delete role bindings
         * @description Delete the provided list of role bindings.
         *     **Access policy**: Authenticated user.
         */
        post: operations["DeleteRoleBindings"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/kubernetes/{id}/rolebindings": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a list of kubernetes role bindings
         * @description Get a list of kubernetes role bindings that the user has access to.
         *     **Access policy**: Authenticated user.
         */
        get: operations["GetKubernetesRoleBindings"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/kubernetes/{id}/roles": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a list of kubernetes roles
         * @description Get a list of kubernetes roles that the user has access to.
         *     **Access policy**: Authenticated user.
         */
        get: operations["GetKubernetesRoles"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/kubernetes/{id}/roles/delete": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Delete roles
         * @description Delete the provided list of roles.
         *     **Access policy**: Authenticated user.
         */
        post: operations["DeleteRoles"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/kubernetes/{id}/secrets": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a list of Secrets
         * @description Get a list of Secrets for a given namespace. If isUsed is set to true, information about the applications that use the secrets is also returned.
         *     **Access policy**: Authenticated user.
         */
        get: operations["GetKubernetesSecrets"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/kubernetes/{id}/secrets/count": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Secrets count
         * @description Get the count of Secrets across all namespaces that the user has access to.
         *     **Access policy**: Authenticated user.
         */
        get: operations["GetKubernetesSecretsCount"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/kubernetes/{id}/service_accounts/delete": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Delete service accounts
         * @description Delete the provided list of service accounts.
         *     **Access policy**: Authenticated user.
         */
        post: operations["DeleteServiceAccounts"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/kubernetes/{id}/serviceaccounts": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a list of kubernetes service accounts
         * @description Get a list of kubernetes service accounts that the user has access to.
         *     **Access policy**: Authenticated user.
         */
        get: operations["GetKubernetesServiceAccounts"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/kubernetes/{id}/services": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a list of services
         * @description Get a list of services that the user has access to.
         *     **Access policy**: Authenticated user.
         */
        get: operations["GetKubernetesServices"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/kubernetes/{id}/services/count": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get services count
         * @description Get the count of services that the user has access to.
         *     **Access policy**: Authenticated user.
         */
        get: operations["GetAllKubernetesServicesCount"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/kubernetes/{id}/services/delete": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Delete services
         * @description Delete the provided list of services.
         *     **Access policy**: Authenticated user.
         */
        post: operations["DeleteKubernetesServices"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/kubernetes/{id}/volumes": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Kubernetes volumes within the given Portainer environment
         * @description Get a list of all kubernetes volumes within the given environment (Endpoint). The Endpoint ID must be a valid Portainer environment identifier.
         *     **Access policy**: Authenticated user.
         */
        get: operations["GetAllKubernetesVolumes"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/kubernetes/{id}/volumes/{namespace}/{volume}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a Kubernetes volume within the given Portainer environment
         * @description Get a Kubernetes volume within the given environment (Endpoint). The Endpoint ID must be a valid Portainer environment identifier.
         *     **Access policy**: Authenticated user.
         */
        get: operations["GetKubernetesVolume"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/kubernetes/{id}/volumes/count": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get the total number of kubernetes volumes within the given Portainer environment.
         * @description Get the total number of kubernetes volumes within the given environment (Endpoint). The total count depends on the user's role and permissions. The Endpoint ID must be a valid Portainer environment identifier.
         *     **Access policy**: Authenticated user.
         */
        get: operations["getAllKubernetesVolumesCount"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/kubernetes/config": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Generate a kubeconfig file
         * @description Generate a kubeconfig file that allows a client to communicate with the Kubernetes API server
         *     **Access policy**: Authenticated user.
         */
        get: operations["GetKubernetesConfig"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/ldap/check": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Test LDAP connectivity
         * @description Test LDAP connectivity using LDAP details
         *     **Access policy**: administrator
         */
        post: operations["LDAPCheck"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/motd": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * fetches the message of the day
         * @description **Access policy**: restricted
         */
        get: operations["MOTD"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/open_amt": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Enable Portainer's OpenAMT capabilities
         * @description Enable Portainer's OpenAMT capabilities
         *     **Access policy**: administrator
         */
        post: operations["OpenAMTConfigure"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/open_amt/{id}/activate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Activate OpenAMT device and associate to agent endpoint
         * @description Activate OpenAMT device and associate to agent endpoint
         *     **Access policy**: administrator
         */
        post: operations["openAMTActivate"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/open_amt/{id}/devices": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Fetch OpenAMT managed devices information for endpoint
         * @description Fetch OpenAMT managed devices information for endpoint
         *     **Access policy**: administrator
         */
        get: operations["OpenAMTDevices"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/open_amt/{id}/devices/{deviceId}/action": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Execute out of band action on an AMT managed device
         * @description Execute out of band action on an AMT managed device
         *     **Access policy**: administrator
         */
        post: operations["DeviceAction"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/open_amt/{id}/devices_features/{deviceId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Enable features on an AMT managed device
         * @description Enable features on an AMT managed device
         *     **Access policy**: administrator
         */
        post: operations["DeviceFeatures"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/open_amt/{id}/info": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Request OpenAMT info from a node
         * @description Request OpenAMT info from a node
         *     **Access policy**: administrator
         */
        get: operations["OpenAMTHostInfo"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/registries": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Registries
         * @description List all registries based on the current user authorizations.
         *     Will return all registries if using an administrator account otherwise it
         *     will only return authorized registries.
         *     **Access policy**: restricted
         */
        get: operations["RegistryList"];
        put?: never;
        /**
         * Create a new registry
         * @description Create a new registry.
         *     **Access policy**: restricted
         */
        post: operations["RegistryCreate"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/registries/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Inspect a registry
         * @description Retrieve details about a registry.
         *     **Access policy**: restricted
         */
        get: operations["RegistryInspect"];
        /**
         * Update a registry
         * @description Update a registry
         *     **Access policy**: restricted
         */
        put: operations["RegistryUpdate"];
        post?: never;
        /**
         * Remove a registry
         * @description Remove a registry
         *     **Access policy**: restricted
         */
        delete: operations["RegistryDelete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/registries/{id}/configure": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Configures a registry
         * @description Configures a registry.
         *     **Access policy**: restricted
         */
        post: operations["RegistryConfigure"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/resource_controls": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create a new resource control
         * @description Create a new resource control to restrict access to a Docker resource.
         *     **Access policy**: administrator
         */
        post: operations["ResourceControlCreate"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/resource_controls/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * Update a resource control
         * @description Update a resource control
         *     **Access policy**: authenticated
         */
        put: operations["ResourceControlUpdate"];
        post?: never;
        /**
         * Remove a resource control
         * @description Remove a resource control.
         *     **Access policy**: administrator
         */
        delete: operations["ResourceControlDelete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/restore": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Triggers a system restore using provided backup file
         * @description Triggers a system restore using provided backup file
         *     **Access policy**: public
         */
        post: operations["Restore"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/roles": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List roles
         * @description List all roles available for use
         *     **Access policy**: administrator
         */
        get: operations["RoleList"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/settings": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve Portainer settings
         * @description Retrieve Portainer settings.
         *     **Access policy**: administrator
         */
        get: operations["SettingsInspect"];
        /**
         * Update Portainer settings
         * @description Update Portainer settings.
         *     **Access policy**: administrator
         */
        put: operations["SettingsUpdate"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/settings/public": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve Portainer public settings
         * @description Retrieve public settings. Returns a small set of settings that are not reserved to administrators only.
         *     **Access policy**: public
         */
        get: operations["SettingsPublic"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/ssl": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Inspect the ssl settings
         * @description Retrieve the ssl settings.
         *     **Access policy**: administrator
         */
        get: operations["SSLInspect"];
        /**
         * Update the ssl settings
         * @description Update the ssl settings.
         *     **Access policy**: administrator
         */
        put: operations["SSLUpdate"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/stacks": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List stacks
         * @description List all stacks based on the current user authorizations.
         *     Will return all stacks if using an administrator account otherwise it
         *     will only return the list of stacks the user have access to.
         *     Limited stacks will not be returned by this endpoint.
         *     **Access policy**: authenticated
         */
        get: operations["StackList"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/stacks/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Inspect a stack
         * @description Retrieve details about a stack.
         *     **Access policy**: restricted
         */
        get: operations["StackInspect"];
        /**
         * Update a stack
         * @description Update a stack, only for file based stacks.
         *     **Access policy**: authenticated
         */
        put: operations["StackUpdate"];
        post?: never;
        /**
         * Remove a stack
         * @description Remove a stack.
         *     **Access policy**: restricted
         */
        delete: operations["StackDelete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/stacks/{id}/associate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * Associate an orphaned stack to a new environment(endpoint)
         * @description **Access policy**: administrator
         */
        put: operations["StackAssociate"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/stacks/{id}/file": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve the content of the Stack file for the specified stack
         * @description Get Stack file content.
         *     **Access policy**: restricted
         */
        get: operations["StackFileInspect"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/stacks/{id}/git": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Update a stack's Git configs
         * @description Update the Git settings in a stack, e.g., RepositoryReferenceName and AutoUpdate
         *     **Access policy**: authenticated
         */
        post: operations["StackUpdateGit"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/stacks/{id}/git/redeploy": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * Redeploy a stack
         * @description Pull and redeploy a stack via Git
         *     **Access policy**: authenticated
         */
        put: operations["StackGitRedeploy"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/stacks/{id}/migrate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Migrate a stack to another environment(endpoint)
         * @description Migrate a stack from an environment(endpoint) to another environment(endpoint). It will re-create the stack inside the target environment(endpoint) before removing the original stack.
         *     **Access policy**: authenticated
         */
        post: operations["StackMigrate"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/stacks/{id}/start": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Starts a stopped Stack
         * @description Starts a stopped Stack.
         *     **Access policy**: authenticated
         */
        post: operations["StackStart"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/stacks/{id}/stop": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Stops a stopped Stack
         * @description Stops a stopped Stack.
         *     **Access policy**: authenticated
         */
        post: operations["StackStop"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/stacks/create/kubernetes/repository": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Deploy a new kubernetes stack from a git repository
         * @description Deploy a new stack into a Docker environment specified via the environment identifier.
         *     **Access policy**: authenticated
         */
        post: operations["StackCreateKubernetesGit"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/stacks/create/kubernetes/string": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Deploy a new kubernetes stack from a file
         * @description Deploy a new stack into a Docker environment specified via the environment identifier.
         *     **Access policy**: authenticated
         */
        post: operations["StackCreateKubernetesFile"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/stacks/create/kubernetes/url": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Deploy a new kubernetes stack from a url
         * @description Deploy a new stack into a Docker environment specified via the environment identifier.
         *     **Access policy**: authenticated
         */
        post: operations["StackCreateKubernetesUrl"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/stacks/create/standalone/file": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Deploy a new compose stack from a file
         * @description Deploy a new stack into a Docker environment specified via the environment identifier.
         *     **Access policy**: authenticated
         */
        post: operations["StackCreateDockerStandaloneFile"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/stacks/create/standalone/repository": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Deploy a new compose stack from repository
         * @description Deploy a new stack into a Docker environment specified via the environment identifier.
         *     **Access policy**: authenticated
         */
        post: operations["StackCreateDockerStandaloneRepository"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/stacks/create/standalone/string": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Deploy a new compose stack from a text
         * @description Deploy a new stack into a Docker environment specified via the environment identifier.
         *     **Access policy**: authenticated
         */
        post: operations["StackCreateDockerStandaloneString"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/stacks/create/swarm/file": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Deploy a new swarm stack from a file
         * @description Deploy a new stack into a Docker environment specified via the environment identifier.
         *     **Access policy**: authenticated
         */
        post: operations["StackCreateDockerSwarmFile"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/stacks/create/swarm/repository": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Deploy a new swarm stack from a git repository
         * @description Deploy a new stack into a Docker environment specified via the environment identifier.
         *     **Access policy**: authenticated
         */
        post: operations["StackCreateDockerSwarmRepository"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/stacks/create/swarm/string": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Deploy a new swarm stack from a text
         * @description Deploy a new stack into a Docker environment specified via the environment identifier.
         *     **Access policy**: authenticated
         */
        post: operations["StackCreateDockerSwarmString"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/stacks/name/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Remove Kubernetes stacks by name
         * @description Remove a stack.
         *     **Access policy**: restricted
         */
        delete: operations["StackDeleteKubernetesByName"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/stacks/webhooks/{webhookID}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Webhook for triggering stack updates from git
         * @description **Access policy**: public
         */
        post: operations["WebhookInvoke"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/status": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Check Portainer status
         * @deprecated
         * @description Deprecated: use the `/system/status` endpoint instead.
         *     Retrieve Portainer status
         *     **Access policy**: public
         */
        get: operations["StatusInspect"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/system/info": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve system info
         * @description **Access policy**: authenticated
         */
        get: operations["systemInfo"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/system/nodes": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve the count of nodes
         * @description **Access policy**: authenticated
         */
        get: operations["systemNodesCount"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/system/status": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Check Portainer status
         * @description Retrieve Portainer status
         *     **Access policy**: public
         */
        get: operations["systemStatus"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/system/upgrade": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Upgrade Portainer to BE
         * @description Upgrade Portainer to BE
         *     **Access policy**: administrator
         */
        post: operations["systemUpgrade"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/system/version": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Check for portainer updates
         * @description Check if portainer has an update available
         *     **Access policy**: authenticated
         */
        get: operations["systemVersion"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/tags": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List tags
         * @description List tags.
         *     **Access policy**: authenticated
         */
        get: operations["TagList"];
        put?: never;
        /**
         * Create a new tag
         * @description Create a new tag.
         *     **Access policy**: administrator
         */
        post: operations["TagCreate"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/tags/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Remove a tag
         * @description Remove a tag.
         *     **Access policy**: administrator
         */
        delete: operations["TagDelete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/team_memberships": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List team memberships
         * @description List team memberships. Access is only available to administrators and team leaders.
         *     **Access policy**: administrator
         */
        get: operations["TeamMembershipList"];
        put?: never;
        /**
         * Create a new team membership
         * @description Create a new team memberships. Access is only available to administrators leaders of the associated team.
         *     **Access policy**: administrator
         */
        post: operations["TeamMembershipCreate"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/team_memberships/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * Update a team membership
         * @description Update a team membership. Access is only available to administrators or leaders of the associated team.
         *     **Access policy**: administrator or leaders of the associated team
         */
        put: operations["TeamMembershipUpdate"];
        post?: never;
        /**
         * Remove a team membership
         * @description Remove a team membership. Access is only available to administrators leaders of the associated team.
         *     **Access policy**: administrator
         */
        delete: operations["TeamMembershipDelete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/teams": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List teams
         * @description List teams. For non-administrator users, will only list the teams they are member of.
         *     **Access policy**: restricted
         */
        get: operations["TeamList"];
        put?: never;
        /**
         * Create a new team
         * @description Create a new team.
         *     **Access policy**: administrator
         */
        post: operations["TeamCreate"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/teams/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Inspect a team
         * @description Retrieve details about a team. Access is only available for administrator and leaders of that team.
         *     **Access policy**: administrator
         */
        get: operations["TeamInspect"];
        /**
         * Update a team
         * @description Update a team.
         *     **Access policy**: administrator
         */
        put: operations["TeamUpdate"];
        post?: never;
        /**
         * Remove a team
         * @description Remove a team.
         *     **Access policy**: administrator
         */
        delete: operations["TeamDelete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/teams/{id}/memberships": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List team memberships
         * @description List team memberships. Access is only available to administrators and team leaders.
         *     **Access policy**: restricted
         */
        get: operations["TeamMemberships"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/templates": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List available templates
         * @description List available templates.
         *     **Access policy**: authenticated
         */
        get: operations["TemplateList"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/templates/{id}/file": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Get a template's file
         * @description Get a template's file
         *     **Access policy**: authenticated
         */
        post: operations["TemplateFile"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/templates/helm": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Search Helm Charts
         * @description **Access policy**: authenticated
         */
        get: operations["HelmRepoSearch"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/templates/helm/{command}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Show Helm Chart Information
         * @description **Access policy**: authenticated
         */
        get: operations["HelmShow"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/upload/tls/{certificate}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Upload TLS files
         * @description Use this environment(endpoint) to upload TLS files.
         *     **Access policy**: administrator
         */
        post: operations["UploadTLS"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List users
         * @description List Portainer users.
         *     Non-administrator users will only be able to list other non-administrator user accounts.
         *     User passwords are filtered out, and should never be accessible.
         *     **Access policy**: restricted
         */
        get: operations["UserList"];
        put?: never;
        /**
         * Create a new user
         * @description Create a new Portainer user.
         *     Only administrators can create users.
         *     **Access policy**: restricted
         */
        post: operations["UserCreate"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Inspect a user
         * @description Retrieve details about a user.
         *     User passwords are filtered out, and should never be accessible.
         *     **Access policy**: authenticated
         */
        get: operations["UserInspect"];
        /**
         * Update a user
         * @description Update user details. A regular user account can only update his details.
         *     A regular user account cannot change their username or role.
         *     **Access policy**: authenticated
         */
        put: operations["UserUpdate"];
        post?: never;
        /**
         * Remove a user
         * @description Remove a user.
         *     **Access policy**: administrator
         */
        delete: operations["UserDelete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/{id}/helm/repositories": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List a users helm repositories
         * @description Inspect a user helm repositories.
         *     **Access policy**: authenticated
         */
        get: operations["HelmUserRepositoriesList"];
        put?: never;
        /**
         * Create a user helm repository
         * @description Create a user helm repository.
         *     **Access policy**: authenticated
         */
        post: operations["HelmUserRepositoryCreate"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/{id}/helm/repositories/{repositoryID}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Delete a users helm repositoryies
         * @description **Access policy**: authenticated
         */
        delete: operations["HelmUserRepositoryDelete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/{id}/memberships": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Inspect a user memberships
         * @description Inspect a user memberships.
         *     **Access policy**: restricted
         */
        get: operations["UserMembershipsInspect"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/{id}/passwd": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * Update password for a user
         * @description Update password for the specified user.
         *     **Access policy**: authenticated
         */
        put: operations["UserUpdatePassword"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/{id}/tokens": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get all API keys for a user
         * @description Gets all API keys for a user.
         *     Only the calling user or admin can retrieve api-keys.
         *     **Access policy**: authenticated
         */
        get: operations["UserGetAPIKeys"];
        put?: never;
        /**
         * Generate an API key for a user
         * @description Generates an API key for a user.
         *     Only the calling user can generate a token for themselves.
         *     Password is required only for internal authentication.
         *     **Access policy**: restricted
         */
        post: operations["UserGenerateAPIKey"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/{id}/tokens/{keyID}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Remove an api-key associated to a user
         * @description Remove an api-key associated to a user..
         *     Only the calling user or admin can remove api-key.
         *     **Access policy**: authenticated
         */
        delete: operations["UserRemoveAPIKey"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/admin/check": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Check administrator account existence
         * @description Check if an administrator account exists in the database.
         *     **Access policy**: public
         */
        get: operations["UserAdminCheck"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/admin/init": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Initialize administrator account
         * @description Initialize the 'admin' user account.
         *     **Access policy**: public
         */
        post: operations["UserAdminInit"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/me": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Inspect the current user user
         * @description Retrieve details about the current  user.
         *     User passwords are filtered out, and should never be accessible.
         *     **Access policy**: authenticated
         */
        get: operations["CurrentUserInspect"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/webhooks": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List webhooks
         * @description **Access policy**: authenticated
         */
        get: {
            parameters: {
                query?: {
                    /**
                     * @description Filters (json-string)
                     * @example {"EndpointID":1,"ResourceID":"abc12345-abcd-2345-ab12-58005b4a0260"}
                     */
                    filters?: string;
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["portainer.Webhook"][];
                    };
                };
                /** @description Bad Request */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description Internal Server Error */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        put?: never;
        /**
         * Create a webhook
         * @description **Access policy**: authenticated
         */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            /** @description Webhook data */
            requestBody: {
                content: {
                    "application/json": components["schemas"]["webhooks.webhookCreatePayload"];
                };
            };
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["portainer.Webhook"];
                    };
                };
                /** @description Invalid request */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description A webhook for this resource already exists */
                409: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description Server error */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/webhooks/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * Update a webhook
         * @description **Access policy**: authenticated
         */
        put: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description Webhook id */
                    id: number;
                };
                cookie?: never;
            };
            /** @description Webhook data */
            requestBody: {
                content: {
                    "application/json": components["schemas"]["webhooks.webhookUpdatePayload"];
                };
            };
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["portainer.Webhook"];
                    };
                };
                /** @description Bad Request */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description Conflict */
                409: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description Internal Server Error */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        /**
         * Execute a webhook
         * @description Acts on a passed in token UUID to restart the docker service
         *     **Access policy**: public
         */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description Webhook token */
                    id: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Webhook executed */
                202: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description Bad Request */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description Internal Server Error */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        /**
         * Delete a webhook
         * @description **Access policy**: authenticated
         */
        delete: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description Webhook id */
                    id: number;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Webhook deleted */
                202: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description Bad Request */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description Internal Server Error */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/websocket/attach": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Attach a websocket
         * @description If the nodeName query parameter is present, the request will be proxied to the underlying agent environment(endpoint).
         *     If the nodeName query parameter is not specified, the request will be upgraded to the websocket protocol and
         *     an AttachStart operation HTTP request will be created and hijacked.
         *     **Access policy**: authenticated
         */
        get: {
            parameters: {
                query: {
                    /** @description environment(endpoint) ID of the environment(endpoint) where the resource is located */
                    endpointId: number;
                    /** @description node name */
                    nodeName?: string;
                    /** @description JWT token used for authentication against this environment(endpoint) */
                    token: string;
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description Bad Request */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description Forbidden */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description Not Found */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description Internal Server Error */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/websocket/exec": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Execute a websocket
         * @description If the nodeName query parameter is present, the request will be proxied to the underlying agent environment(endpoint).
         *     If the nodeName query parameter is not specified, the request will be upgraded to the websocket protocol and
         *     an ExecStart operation HTTP request will be created and hijacked.
         */
        get: {
            parameters: {
                query: {
                    /** @description environment(endpoint) ID of the environment(endpoint) where the resource is located */
                    endpointId: number;
                    /** @description node name */
                    nodeName?: string;
                    /** @description JWT token used for authentication against this environment(endpoint) */
                    token: string;
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description Bad Request */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description Conflict */
                409: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description Internal Server Error */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/websocket/kubernetes-shell": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Execute a websocket on kubectl shell pod
         * @description The request will be upgraded to the websocket protocol. The request will proxy input from the client to the pod via long-lived websocket connection.
         *     **Access policy**: authenticated
         */
        get: {
            parameters: {
                query: {
                    /** @description environment(endpoint) ID of the environment(endpoint) where the resource is located */
                    endpointId: number;
                    /** @description JWT token used for authentication against this environment(endpoint) */
                    token: string;
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Success */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description Invalid request */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description Permission denied */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description Server error */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/websocket/pod": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Execute a websocket on pod
         * @description The request will be upgraded to the websocket protocol.
         *     **Access policy**: authenticated
         */
        get: {
            parameters: {
                query: {
                    /** @description environment(endpoint) ID of the environment(endpoint) where the resource is located */
                    endpointId: number;
                    /** @description namespace where the container is located */
                    namespace: string;
                    /** @description name of the pod containing the container */
                    podName: string;
                    /** @description name of the container */
                    containerName: string;
                    /** @description command to execute in the container */
                    command: string;
                    /** @description JWT token used for authentication against this environment(endpoint) */
                    token: string;
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description Bad Request */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description Forbidden */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description Not Found */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description Internal Server Error */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        "auth.authenticatePayload": {
            /**
             * @description Password
             * @example mypassword
             */
            password: string;
            /**
             * @description Username
             * @example admin
             */
            username: string;
        };
        "auth.authenticateResponse": {
            /**
             * @description JWT token used to authenticate against the API
             * @example abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyzAB
             */
            jwt?: string;
        };
        "auth.oauthPayload": {
            /** @description OAuth code returned from OAuth Provided */
            code?: string;
        };
        "backup.backupPayload": {
            password?: string;
        };
        "backup.restorePayload": {
            fileContent?: number[];
            fileName?: string;
            password?: string;
        };
        "build.BuildInfo": {
            buildNumber?: string;
            gitCommit?: string;
            goVersion?: string;
            imageTag?: string;
            nodejsVersion?: string;
            webpackVersion?: string;
            yarnVersion?: string;
        };
        "build.DependenciesInfo": {
            composeVersion?: string;
            dockerVersion?: string;
            helmVersion?: string;
            kubectlVersion?: string;
        };
        "build.RuntimeInfo": {
            env?: string[];
        };
        "containers.containerGpusResponse": {
            gpus?: string;
        };
        "customtemplates.customTemplateFromFileContentPayload": {
            /**
             * @description Description of the template
             * @example High performance web server
             */
            description: string;
            /**
             * @description EdgeTemplate indicates if this template purpose for Edge Stack
             * @example false
             */
            edgeTemplate?: boolean;
            /** @description Content of stack file */
            fileContent: string;
            /**
             * @description URL of the template's logo
             * @example https://portainer.io/img/logo.svg
             */
            logo?: string;
            /**
             * @description A note that will be displayed in the UI. Supports HTML content
             * @example This is my <b>custom</b> template
             */
            note?: string;
            /**
             * @description Platform associated to the template.
             *     Valid values are: 1 - 'linux', 2 - 'windows'
             *     Required for Docker stacks
             * @example 1
             * @enum {integer}
             */
            platform?: 1 | 2;
            /**
             * @description Title of the template
             * @example Nginx
             */
            title: string;
            /**
             * @description Type of created stack:
             *     * 1 - swarm
             *     * 2 - compose
             *     * 3 - kubernetes
             * @example 1
             * @enum {integer}
             */
            type: 1 | 2 | 3;
            /** @description Definitions of variables in the stack file */
            variables?: components["schemas"]["portainer.CustomTemplateVariableDefinition"][];
        };
        "customtemplates.customTemplateFromGitRepositoryPayload": {
            /**
             * @description Path to the Stack file inside the Git repository
             * @default docker-compose.yml
             * @example docker-compose.yml
             */
            composeFilePathInRepository: string;
            /**
             * @description Description of the template
             * @example High performance web server
             */
            description: string;
            /**
             * @description EdgeTemplate indicates if this template purpose for Edge Stack
             * @example false
             */
            edgeTemplate?: boolean;
            /**
             * @description IsComposeFormat indicates if the Kubernetes template is created from a Docker Compose file
             * @example false
             */
            isComposeFormat?: boolean;
            /**
             * @description URL of the template's logo
             * @example https://portainer.io/img/logo.svg
             */
            logo?: string;
            /**
             * @description A note that will be displayed in the UI. Supports HTML content
             * @example This is my <b>custom</b> template
             */
            note?: string;
            /**
             * @description Platform associated to the template.
             *     Valid values are: 1 - 'linux', 2 - 'windows'
             *     Required for Docker stacks
             * @example 1
             * @enum {integer}
             */
            platform?: 1 | 2;
            /**
             * @description Use basic authentication to clone the Git repository
             * @example true
             */
            repositoryAuthentication?: boolean;
            /**
             * @description Password used in basic authentication. Required when RepositoryAuthentication is true.
             * @example myGitPassword
             */
            repositoryPassword?: string;
            /**
             * @description Reference name of a Git repository hosting the Stack file
             * @example refs/heads/master
             */
            repositoryReferenceName?: string;
            /**
             * @description URL of a Git repository hosting the Stack file
             * @example https://github.com/openfaas/faas
             */
            repositoryURL: string;
            /**
             * @description Username used in basic authentication. Required when RepositoryAuthentication is true.
             * @example myGitUsername
             */
            repositoryUsername?: string;
            /**
             * @description Title of the template
             * @example Nginx
             */
            title: string;
            /**
             * @description TLSSkipVerify skips SSL verification when cloning the Git repository
             * @example false
             */
            tlsskipVerify?: boolean;
            /**
             * @description Type of created stack:
             *     * 1 - swarm
             *     * 2 - compose
             *     * 3 - kubernetes
             * @example 1
             * @enum {integer}
             */
            type: 1 | 2;
            /** @description Definitions of variables in the stack file */
            variables?: components["schemas"]["portainer.CustomTemplateVariableDefinition"][];
        };
        "customtemplates.customTemplateUpdatePayload": {
            /**
             * @description Path to the Stack file inside the Git repository
             * @default docker-compose.yml
             * @example docker-compose.yml
             */
            composeFilePathInRepository: string;
            /**
             * @description Description of the template
             * @example High performance web server
             */
            description: string;
            /**
             * @description EdgeTemplate indicates if this template purpose for Edge Stack
             * @example false
             */
            edgeTemplate?: boolean;
            /** @description Content of stack file */
            fileContent: string;
            /**
             * @description IsComposeFormat indicates if the Kubernetes template is created from a Docker Compose file
             * @example false
             */
            isComposeFormat?: boolean;
            /**
             * @description URL of the template's logo
             * @example https://portainer.io/img/logo.svg
             */
            logo?: string;
            /**
             * @description A note that will be displayed in the UI. Supports HTML content
             * @example This is my <b>custom</b> template
             */
            note?: string;
            /**
             * @description Platform associated to the template.
             *     Valid values are: 1 - 'linux', 2 - 'windows'
             *     Required for Docker stacks
             * @example 1
             * @enum {integer}
             */
            platform?: 1 | 2;
            /**
             * @description Use basic authentication to clone the Git repository
             * @example true
             */
            repositoryAuthentication?: boolean;
            /**
             * @description GitCredentialID used to identify the bound git credential. Required when RepositoryAuthentication
             *     is true and RepositoryUsername/RepositoryPassword are not provided
             * @example 0
             */
            repositoryGitCredentialID?: number;
            /**
             * @description Password used in basic authentication. Required when RepositoryAuthentication is true
             *     and RepositoryGitCredentialID is 0
             * @example myGitPassword
             */
            repositoryPassword?: string;
            /**
             * @description Reference name of a Git repository hosting the Stack file
             * @example refs/heads/master
             */
            repositoryReferenceName?: string;
            /**
             * @description URL of a Git repository hosting the Stack file
             * @example https://github.com/openfaas/faas
             */
            repositoryURL: string;
            /**
             * @description Username used in basic authentication. Required when RepositoryAuthentication is true
             *     and RepositoryGitCredentialID is 0
             * @example myGitUsername
             */
            repositoryUsername?: string;
            /**
             * @description Title of the template
             * @example Nginx
             */
            title: string;
            /**
             * @description TLSSkipVerify skips SSL verification when cloning the Git repository
             * @example false
             */
            tlsskipVerify?: boolean;
            /**
             * @description Type of created stack (1 - swarm, 2 - compose, 3 - kubernetes)
             * @example 1
             * @enum {integer}
             */
            type: 1 | 2 | 3;
            /** @description Definitions of variables in the stack file */
            variables?: components["schemas"]["portainer.CustomTemplateVariableDefinition"][];
        };
        "customtemplates.fileResponse": {
            fileContent?: string;
        };
        "docker.ContainerStats": {
            healthy?: number;
            running?: number;
            stopped?: number;
            total?: number;
            unhealthy?: number;
        };
        "docker.dashboardResponse": {
            containers?: components["schemas"]["docker.ContainerStats"];
            images?: components["schemas"]["docker.imagesCounters"];
            networks?: number;
            services?: number;
            stacks?: number;
            volumes?: number;
        };
        "docker.imagesCounters": {
            size?: number;
            total?: number;
        };
        "edge.DeployerOptionsPayload": {
            /** @description Prune is a flag indicating if the agent must prune the containers or not when creating/updating an edge stack
             *     This flag drives `docker compose up --remove-orphans` and `docker stack up --prune` options
             *     Used only for EE */
            prune?: boolean;
            /** @description RemoveVolumes is a flag indicating if the agent must remove the named volumes declared
             *     in the compose file and anonymouse volumes attached to containers
             *     This flag drives `docker compose down --volumes` option
             *     Used only for EE */
            removeVolumes?: boolean;
        };
        "edge.RegistryCredentials": {
            secret?: string;
            serverURL?: string;
            username?: string;
        };
        "edge.StackPayload": {
            deployerOptionsPayload?: components["schemas"]["edge.DeployerOptionsPayload"];
            /** @description Content of stack folder */
            dirEntries?: components["schemas"]["filesystem.DirEntry"][];
            /** @description EdgeUpdateID is the ID of the edge update related to this stack.
             *     Used only for EE */
            edgeUpdateID?: number;
            /** @description Name of the stack entry file */
            entryFileName?: string;
            /** @description Used only for EE
             *     EnvVars is a list of environment variables to inject into the stack */
            envVars?: components["schemas"]["portainer.Pair"][];
            /** @description Mount point for relative path */
            filesystemPath?: string;
            /** @description ID of the stack */
            id?: number;
            /** @description Name of the stack */
            name?: string;
            /** @description Namespace to use for kubernetes stack. Keep empty to use the manifest namespace. */
            namespace?: string;
            /** @description PrePullImage is a flag indicating if the agent must pull the image before deploying the stack.
             *     Used only for EE */
            prePullImage?: boolean;
            /** @description RePullImage is a flag indicating if the agent must pull the image if it is already present on the node.
             *     Used only for EE */
            rePullImage?: boolean;
            /** @description Used only for EE async edge agent
             *     ReadyRePullImage is a flag to indicate whether the auto update is trigger to re-pull image */
            readyRePullImage?: boolean;
            /** @description RegistryCredentials holds the credentials for a Docker registry.
             *     Used only for EE */
            registryCredentials?: components["schemas"]["edge.RegistryCredentials"][];
            /** @description RetryDeploy is a flag indicating if the agent must retry to deploy the stack if it fails.
             *     Used only for EE */
            retryDeploy?: boolean;
            /** @description RetryPeriod specifies the duration, in seconds, for which the agent should continue attempting to deploy the stack after a failure
             *     Used only for EE */
            retryPeriod?: number;
            /** @description RollbackTo specifies the stack file version to rollback to (only support to rollback to the last version currently) */
            rollbackTo?: number;
            /** @description Content of the stack file (for compatibility to agent version less than 2.19.0) */
            stackFileContent?: string;
            /** @description Is relative path supported */
            supportRelativePath?: boolean;
            /** @description Version of the stack file */
            version?: number;
        };
        "edgegroups.decoratedEdgeGroup": {
            Dynamic?: boolean;
            Endpoints?: number[];
            HasEdgeJob?: boolean;
            HasEdgeStack?: boolean;
            /**
             * @description EdgeGroup Identifier
             * @example 1
             */
            Id?: number;
            Name?: string;
            PartialMatch?: boolean;
            TagIds?: number[];
            TrustedEndpoints?: number[];
            endpointTypes?: number[];
        };
        "edgegroups.edgeGroupCreatePayload": {
            dynamic?: boolean;
            endpoints?: number[];
            name?: string;
            partialMatch?: boolean;
            tagIDs?: number[];
        };
        "edgegroups.edgeGroupUpdatePayload": {
            dynamic?: boolean;
            endpoints?: number[];
            name?: string;
            partialMatch?: boolean;
            tagIDs?: number[];
        };
        "edgejobs.edgeJobCreateFromFileContentPayload": {
            cronExpression?: string;
            edgeGroups?: number[];
            endpoints?: number[];
            fileContent?: string;
            name?: string;
            recurring?: boolean;
        };
        "edgejobs.edgeJobFileResponse": {
            FileContent?: string;
        };
        "edgejobs.edgeJobUpdatePayload": {
            cronExpression?: string;
            edgeGroups?: number[];
            endpoints?: number[];
            fileContent?: string;
            name?: string;
            recurring?: boolean;
        };
        "edgejobs.fileResponse": {
            FileContent?: string;
        };
        "edgejobs.taskContainer": {
            EndpointId?: number;
            Id?: string;
            LogsStatus?: number;
        };
        "edgestacks.edgeStackFromGitRepositoryPayload": {
            /**
             * @description Deployment type to deploy this stack
             *     Valid values are: 0 - 'compose', 1 - 'kubernetes'
             *     compose is enabled only for docker environments
             *     kubernetes is enabled only for kubernetes environments
             * @example 0
             * @enum {integer}
             */
            deploymentType?: 0 | 1 | 2;
            /**
             * @description List of identifiers of EdgeGroups
             * @example [
             *       1
             *     ]
             */
            edgeGroups: number[];
            /**
             * @description Path to the Stack file inside the Git repository
             * @default docker-compose.yml
             * @example docker-compose.yml
             */
            filePathInRepository: string;
            /**
             * @description Name of the stack
             *     Max length: 255
             *     Name must only contains lowercase characters, numbers, hyphens, or underscores
             *     Name must start with a lowercase character or number
             *     Example: stack-name or stack_123 or stackName
             * @example stack-name
             */
            name: string;
            /** @description List of Registries to use for this stack */
            registries?: number[];
            /**
             * @description Use basic authentication to clone the Git repository
             * @example true
             */
            repositoryAuthentication?: boolean;
            /**
             * @description Password used in basic authentication. Required when RepositoryAuthentication is true.
             * @example myGitPassword
             */
            repositoryPassword?: string;
            /**
             * @description Reference name of a Git repository hosting the Stack file
             * @example refs/heads/master
             */
            repositoryReferenceName?: string;
            /**
             * @description URL of a Git repository hosting the Stack file
             * @example https://github.com/openfaas/faas
             */
            repositoryURL: string;
            /**
             * @description Username used in basic authentication. Required when RepositoryAuthentication is true.
             * @example myGitUsername
             */
            repositoryUsername?: string;
            /**
             * @description TLSSkipVerify skips SSL verification when cloning the Git repository
             * @example false
             */
            tlsskipVerify?: boolean;
            /** @description Uses the manifest's namespaces instead of the default one */
            useManifestNamespaces?: boolean;
        };
        "edgestacks.edgeStackFromStringPayload": {
            /**
             * @description Deployment type to deploy this stack
             *     Valid values are: 0 - 'compose', 1 - 'kubernetes'
             *     compose is enabled only for docker environments
             *     kubernetes is enabled only for kubernetes environments
             * @example 0
             * @enum {integer}
             */
            deploymentType?: 0 | 1 | 2;
            /**
             * @description List of identifiers of EdgeGroups
             * @example [
             *       1
             *     ]
             */
            edgeGroups?: number[];
            /**
             * @description Name of the stack
             *     Max length: 255
             *     Name must only contains lowercase characters, numbers, hyphens, or underscores
             *     Name must start with a lowercase character or number
             *     Example: stack-name or stack_123 or stackName
             * @example stack-name
             */
            name: string;
            /** @description List of Registries to use for this stack */
            registries?: number[];
            /**
             * @description Content of the Stack file
             * @example version: 3
             *      services:
             *      web:
             *      image:nginx
             */
            stackFileContent: string;
            /** @description Uses the manifest's namespaces instead of the default one */
            useManifestNamespaces?: boolean;
        };
        "edgestacks.stackFileResponse": {
            StackFileContent?: string;
        };
        "edgestacks.updateEdgeStackPayload": {
            /**
             * @description Deployment type to deploy this stack
             *     Valid values are: 0 - 'compose', 1 - 'kubernetes'
             *     compose is enabled only for docker environments
             *     kubernetes is enabled only for kubernetes environments
             * @example 0
             * @enum {integer}
             */
            deploymentType?: 0 | 1 | 2;
            edgeGroups?: number[];
            stackFileContent?: string;
            updateVersion?: boolean;
            /** @description Uses the manifest's namespaces instead of the default one */
            useManifestNamespaces?: boolean;
        };
        "edgestacks.updateStatusPayload": {
            endpointID?: number;
            error?: string;
            /** @description Deprecated */
            status?: number;
            time?: number;
            version?: number;
        };
        "endpointedge.edgeJobResponse": {
            /**
             * @description Whether to collect logs
             * @example true
             */
            CollectLogs?: boolean;
            /**
             * @description A cron expression to schedule this job
             * @example * * * * *
             */
            CronExpression?: string;
            /**
             * @description EdgeJob Identifier
             * @example 2
             */
            Id?: number;
            /**
             * @description Script to run
             * @example echo hello
             */
            Script?: string;
            /**
             * @description Version of this EdgeJob
             * @example 2
             */
            Version?: number;
        };
        "endpointedge.endpointEdgeStatusInspectResponse": {
            /**
             * @description The current value of CheckinInterval
             * @example 5
             */
            checkin?: number;
            credentials?: string;
            /**
             * @description The tunnel port
             * @example 8732
             */
            port?: number;
            /** @description List of requests for jobs to run on the environment(endpoint) */
            schedules?: components["schemas"]["endpointedge.edgeJobResponse"][];
            /** @description List of stacks to be deployed on the environments(endpoints) */
            stacks?: components["schemas"]["endpointedge.stackStatusResponse"][];
            /**
             * @description Status represents the environment(endpoint) status
             * @example REQUIRED
             */
            status?: string;
        };
        "endpointedge.stackStatusResponse": {
            /**
             * @description EdgeStack Identifier
             * @example 1
             */
            id?: number;
            /**
             * @description Version of this stack
             * @example 3
             */
            version?: number;
        };
        "endpointgroups.endpointGroupCreatePayload": {
            /**
             * @description List of environment(endpoint) identifiers that will be part of this group
             * @example [
             *       1,
             *       3
             *     ]
             */
            associatedEndpoints?: number[];
            /**
             * @description Environment(Endpoint) group description
             * @example description
             */
            description?: string;
            /**
             * @description Environment(Endpoint) group name
             * @example my-environment-group
             */
            name: string;
            /**
             * @description List of tag identifiers to which this environment(endpoint) group is associated
             * @example [
             *       1,
             *       2
             *     ]
             */
            tagIDs?: number[];
        };
        "endpointgroups.endpointGroupUpdatePayload": {
            /**
             * @description Environment(Endpoint) group description
             * @example description
             */
            description?: string;
            /**
             * @description Environment(Endpoint) group name
             * @example my-environment-group
             */
            name?: string;
            /**
             * @description List of tag identifiers associated to the environment(endpoint) group
             * @example [
             *       3,
             *       4
             *     ]
             */
            tagIDs?: number[];
            teamAccessPolicies?: components["schemas"]["portainer.TeamAccessPolicies"];
            userAccessPolicies?: components["schemas"]["portainer.UserAccessPolicies"];
        };
        "endpoints.dockerhubStatusResponse": {
            /** @description Daily limit */
            limit?: number;
            /** @description Remaiming images to pull */
            remaining?: number;
        };
        "endpoints.endpointCreateGlobalKeyResponse": {
            /** @description Environment(Endpoint) Identifier */
            endpointID?: number;
        };
        "endpoints.endpointDeleteBatchPartialResponse": {
            deleted?: number[];
            errors?: number[];
        };
        "endpoints.endpointDeleteBatchPayload": {
            endpoints?: components["schemas"]["endpoints.endpointDeleteRequest"][];
        };
        "endpoints.endpointDeleteRequest": {
            deleteCluster?: boolean;
            id?: number;
        };
        "endpoints.endpointSettingsUpdatePayload": {
            /**
             * @description Whether non-administrator should be able to use bind mounts when creating containers
             * @example false
             */
            allowBindMountsForRegularUsers?: boolean;
            /**
             * @description Whether non-administrator should be able to use container capabilities
             * @example true
             */
            allowContainerCapabilitiesForRegularUsers?: boolean;
            /**
             * @description Whether non-administrator should be able to use device mapping
             * @example true
             */
            allowDeviceMappingForRegularUsers?: boolean;
            /**
             * @description Whether non-administrator should be able to use the host pid
             * @example true
             */
            allowHostNamespaceForRegularUsers?: boolean;
            /**
             * @description Whether non-administrator should be able to use privileged mode when creating containers
             * @example false
             */
            allowPrivilegedModeForRegularUsers?: boolean;
            /**
             * @description Whether non-administrator should be able to manage stacks
             * @example true
             */
            allowStackManagementForRegularUsers?: boolean;
            /**
             * @description Whether non-administrator should be able to use sysctl settings
             * @example true
             */
            allowSysctlSettingForRegularUsers?: boolean;
            /**
             * @description Whether non-administrator should be able to browse volumes
             * @example true
             */
            allowVolumeBrowserForRegularUsers?: boolean;
            /** @example false */
            enableGPUManagement?: boolean;
            /**
             * @description Whether host management features are enabled
             * @example true
             */
            enableHostManagementFeatures?: boolean;
            gpus?: components["schemas"]["portainer.Pair"][];
        };
        "endpoints.endpointUpdatePayload": {
            /**
             * @description Azure application ID
             * @example eag7cdo9-o09l-9i83-9dO9-f0b23oe78db4
             */
            azureApplicationID?: string;
            /**
             * @description Azure authentication key
             * @example cOrXoK/1D35w8YQ8nH1/8ZGwzz45JIYD5jxHKXEQknk=
             */
            azureAuthenticationKey?: string;
            /**
             * @description Azure tenant ID
             * @example 34ddc78d-4fel-2358-8cc1-df84c8o839f5
             */
            azureTenantID?: string;
            /**
             * @description The check in interval for edge agent (in seconds)
             * @example 5
             */
            edgeCheckinInterval?: number;
            /** @description GPUs information */
            gpus?: components["schemas"]["portainer.Pair"][];
            /**
             * @description Group identifier
             * @example 1
             */
            groupID?: number;
            kubernetes?: components["schemas"]["portainer.KubernetesData"];
            /**
             * @description Name that will be used to identify this environment(endpoint)
             * @example my-environment
             */
            name?: string;
            /**
             * @description URL or IP address where exposed containers will be reachable.\
             *     Defaults to URL if not specified
             * @example docker.mydomain.tld:2375
             */
            publicURL?: string;
            /**
             * @description The status of the environment(endpoint) (1 - up, 2 - down)
             * @example 1
             */
            status?: number;
            /**
             * @description List of tag identifiers to which this environment(endpoint) is associated
             * @example [
             *       1,
             *       2
             *     ]
             */
            tagIDs?: number[];
            teamAccessPolicies?: components["schemas"]["portainer.TeamAccessPolicies"];
            /**
             * @description Require TLS to connect against this environment(endpoint)
             * @example true
             */
            tls?: boolean;
            /**
             * @description Skip client verification when using TLS
             * @example false
             */
            tlsskipClientVerify?: boolean;
            /**
             * @description Skip server verification when using TLS
             * @example false
             */
            tlsskipVerify?: boolean;
            /**
             * @description URL or IP address of a Docker host
             * @example docker.mydomain.tld:2375
             */
            url?: string;
            userAccessPolicies?: components["schemas"]["portainer.UserAccessPolicies"];
        };
        "endpoints.endpointUpdateRelationsPayload": {
            relations?: {
                [key: string]: {
                    edgeGroups?: number[];
                    /**
                     * @description Environment(Endpoint) group identifier
                     * @example 1
                     */
                    group?: number;
                    tags?: number[];
                };
            };
        };
        "endpoints.forceUpdateServicePayload": {
            /** @description PullImage if true will pull the image */
            pullImage?: boolean;
            /** @description ServiceId to update */
            serviceID?: string;
        };
        "endpoints.registryAccessPayload": {
            namespaces?: string[];
            teamAccessPolicies?: components["schemas"]["portainer.TeamAccessPolicies"];
            userAccessPolicies?: components["schemas"]["portainer.UserAccessPolicies"];
        };
        "filesystem.DirEntry": {
            content?: string;
            isFile?: boolean;
            name?: string;
            permissions?: number;
        };
        "gitops.fileResponse": {
            fileContent?: string;
        };
        "gitops.repositoryFilePreviewPayload": {
            /** @example myGitPassword */
            password?: string;
            /** @example refs/heads/master */
            reference?: string;
            /** @example https://github.com/openfaas/faas */
            repository: string;
            /**
             * @description Path to file whose content will be read
             * @example docker-compose.yml
             */
            targetFile?: string;
            /**
             * @description TLSSkipVerify skips SSL verification when cloning the Git repository
             * @example false
             */
            tlsskipVerify?: boolean;
            /** @example myGitUsername */
            username?: string;
        };
        "gittypes.GitAuthentication": {
            /**
             * @description Git credentials identifier when the value is not 0
             *     When the value is 0, Username and Password are set without using saved credential
             *     This is introduced since 2.15.0
             * @example 0
             */
            gitCredentialID?: number;
            password?: string;
            username?: string;
        };
        "gittypes.RepoConfig": {
            authentication?: components["schemas"]["gittypes.GitAuthentication"];
            /**
             * @description Path to where the config file is in this url/refName
             * @example docker-compose.yml
             */
            configFilePath?: string;
            /**
             * @description Repository hash
             * @example bc4c183d756879ea4d173315338110b31004b8e0
             */
            configHash?: string;
            /**
             * @description The reference name
             * @example refs/heads/branch_name
             */
            referenceName?: string;
            /**
             * @description TLSSkipVerify skips SSL verification when cloning the Git repository
             * @example false
             */
            tlsskipVerify?: boolean;
            /**
             * @description The repo url
             * @example https://github.com/portainer/portainer.git
             */
            url?: string;
        };
        "helm.installChartPayload": {
            chart?: string;
            name?: string;
            namespace?: string;
            repo?: string;
            values?: string;
        };
        "images.ImageResponse": {
            created?: number;
            id?: string;
            nodeName?: string;
            size?: number;
            tags?: string[];
            /** @description Used is true if the image is used by at least one container
             *     supplied only when withUsage is true */
            used?: boolean;
        };
        "intstr.IntOrString": {
            intVal?: number;
            strVal?: string;
            type?: number;
        };
        "kubernetes.Configuration": {
            ConfigurationOwner?: string;
            Data?: {
                [key: string]: unknown;
            };
            Kind?: string;
        };
        "kubernetes.IngressRule": {
            Host?: string;
            IP?: string;
            Path?: string;
            TLS?: components["schemas"]["kubernetes.TLSInfo"][];
        };
        "kubernetes.K8sApplication": {
            ApplicationOwner?: string;
            ApplicationType?: string;
            Configurations?: components["schemas"]["kubernetes.Configuration"][];
            Containers?: unknown[];
            CreationDate?: string;
            DeploymentType?: string;
            HorizontalPodAutoscaler?: components["schemas"]["v2.HorizontalPodAutoscaler"];
            Id?: string;
            Image?: string;
            Kind?: string;
            Labels?: {
                [key: string]: string;
            };
            LoadBalancerIPAddress?: string;
            MatchLabels?: {
                [key: string]: string;
            };
            Metadata?: components["schemas"]["kubernetes.Metadata"];
            Name?: string;
            Namespace?: string;
            Pods?: components["schemas"]["kubernetes.Pod"][];
            PublishedPorts?: components["schemas"]["kubernetes.PublishedPort"][];
            Resource?: components["schemas"]["kubernetes.K8sApplicationResource"];
            ResourcePool?: string;
            RunningPodsCount?: number;
            ServiceId?: string;
            ServiceName?: string;
            ServiceType?: string;
            Services?: components["schemas"]["v1.Service"][];
            StackId?: string;
            StackName?: string;
            Status?: string;
            TotalPodsCount?: number;
            Uid?: string;
        };
        "kubernetes.K8sApplicationResource": {
            CpuLimit?: number;
            CpuRequest?: number;
            MemoryLimit?: number;
            MemoryRequest?: number;
        };
        "kubernetes.K8sClusterRole": {
            creationDate?: string;
            isSystem?: boolean;
            name?: string;
            /** @description UID of the referent.
             *     More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids */
            uid?: string;
        };
        "kubernetes.K8sClusterRoleBinding": {
            creationDate?: string;
            isSystem?: boolean;
            name?: string;
            namespace?: string;
            roleRef?: components["schemas"]["v1.RoleRef"];
            subjects?: components["schemas"]["v1.Subject"][];
            /** @description UID of the referent.
             *     More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids */
            uid?: string;
        };
        "kubernetes.K8sConfigMap": {
            Annotations?: {
                [key: string]: string;
            };
            ConfigurationOwner?: string;
            ConfigurationOwnerId?: string;
            ConfigurationOwners?: components["schemas"]["kubernetes.K8sConfigurationOwnerResource"][];
            CreationDate?: string;
            Data?: {
                [key: string]: string;
            };
            IsUsed?: boolean;
            Labels?: {
                [key: string]: string;
            };
            Name?: string;
            Namespace?: string;
            UID?: string;
        };
        "kubernetes.K8sConfigurationOwnerResource": {
            Id?: string;
            Name?: string;
            ResourceKind?: string;
        };
        "kubernetes.K8sCronJob": {
            Command?: string;
            Id?: string;
            IsSystem?: boolean;
            Jobs?: components["schemas"]["kubernetes.K8sJob"][];
            Name?: string;
            Namespace?: string;
            Schedule?: string;
            Suspend?: boolean;
            Timezone?: string;
        };
        "kubernetes.K8sCronJobDeleteRequests": {
            [key: string]: string[];
        };
        "kubernetes.K8sDashboard": {
            applicationsCount?: number;
            configMapsCount?: number;
            ingressesCount?: number;
            namespacesCount?: number;
            secretsCount?: number;
            servicesCount?: number;
            volumesCount?: number;
        };
        "kubernetes.K8sIngressController": {
            Availability?: boolean;
            ClassName?: string;
            Name?: string;
            New?: boolean;
            Type?: string;
            Used?: boolean;
        };
        "kubernetes.K8sIngressDeleteRequests": {
            [key: string]: string[];
        };
        "kubernetes.K8sIngressInfo": {
            Annotations?: {
                [key: string]: string;
            };
            ClassName?: string;
            CreationDate?: string;
            Hosts?: string[];
            Labels?: {
                [key: string]: string;
            };
            Name?: string;
            Namespace?: string;
            Paths?: components["schemas"]["kubernetes.K8sIngressPath"][];
            TLS?: components["schemas"]["kubernetes.K8sIngressTLS"][];
            Type?: string;
            UID?: string;
        };
        "kubernetes.K8sIngressPath": {
            HasService?: boolean;
            Host?: string;
            IngressName?: string;
            Path?: string;
            PathType?: string;
            Port?: number;
            ServiceName?: string;
        };
        "kubernetes.K8sIngressTLS": {
            Hosts?: string[];
            SecretName?: string;
        };
        "kubernetes.K8sJob": {
            BackoffLimit?: number;
            Command?: string;
            Completions?: number;
            Container?: components["schemas"]["v1.Container"];
            Duration?: string;
            FailedReason?: string;
            FinishTime?: string;
            Id?: string;
            IsSystem?: boolean;
            Name?: string;
            Namespace?: string;
            PodName?: string;
            StartTime?: string;
            Status?: string;
        };
        "kubernetes.K8sJobDeleteRequests": {
            [key: string]: string[];
        };
        "kubernetes.K8sNamespaceDetails": {
            Annotations?: {
                [key: string]: string;
            };
            Name?: string;
            Owner?: string;
            ResourceQuota?: components["schemas"]["kubernetes.K8sResourceQuota"];
        };
        "kubernetes.K8sPersistentVolume": {
            accessModes?: string[];
            annotations?: {
                [key: string]: string;
            };
            capacity?: components["schemas"]["v1.ResourceList"];
            claimRef?: components["schemas"]["v1.ObjectReference"];
            csi?: components["schemas"]["v1.CSIPersistentVolumeSource"];
            name?: string;
            persistentVolumeReclaimPolicy?: string;
            storageClassName?: string;
            volumeMode?: string;
        };
        "kubernetes.K8sPersistentVolumeClaim": {
            accessModes?: string[];
            creationDate?: string;
            id?: string;
            labels?: {
                [key: string]: string;
            };
            name?: string;
            namespace?: string;
            owningApplications?: components["schemas"]["kubernetes.K8sApplication"][];
            phase?: string;
            resourcesRequests?: components["schemas"]["v1.ResourceList"];
            storage?: number;
            storageClass?: string;
            volumeMode?: string;
            volumeName?: string;
        };
        "kubernetes.K8sResourceQuota": {
            cpu?: string;
            enabled?: boolean;
            memory?: string;
        };
        "kubernetes.K8sRole": {
            creationDate?: string;
            /** @description isSystem is true if prefixed with "system:" or exists in the kube-system namespace
             *     or is one of the portainer roles */
            isSystem?: boolean;
            name?: string;
            namespace?: string;
            /** @description UID of the referent.
             *     More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids */
            uid?: string;
        };
        "kubernetes.K8sRoleBinding": {
            creationDate?: string;
            isSystem?: boolean;
            name?: string;
            namespace?: string;
            roleRef?: components["schemas"]["v1.RoleRef"];
            subjects?: components["schemas"]["v1.Subject"][];
            /** @description UID of the referent.
             *     More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids */
            uid?: string;
        };
        "kubernetes.K8sRoleBindingDeleteRequests": {
            [key: string]: string[];
        };
        "kubernetes.K8sRoleDeleteRequests": {
            [key: string]: string[];
        };
        "kubernetes.K8sSecret": {
            Annotations?: {
                [key: string]: string;
            };
            ConfigurationOwner?: string;
            ConfigurationOwnerId?: string;
            ConfigurationOwners?: components["schemas"]["kubernetes.K8sConfigurationOwnerResource"][];
            CreationDate?: string;
            Data?: {
                [key: string]: string;
            };
            IsUsed?: boolean;
            Labels?: {
                [key: string]: string;
            };
            Name?: string;
            Namespace?: string;
            SecretType?: string;
            UID?: string;
        };
        "kubernetes.K8sServiceAccount": {
            creationDate?: string;
            isSystem?: boolean;
            name?: string;
            namespace?: string;
            /** @description UID of the referent.
             *     More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids */
            uid?: string;
        };
        "kubernetes.K8sServiceAccountDeleteRequests": {
            [key: string]: string[];
        };
        "kubernetes.K8sServiceDeleteRequests": {
            [key: string]: string[];
        };
        "kubernetes.K8sServiceInfo": {
            allocateLoadBalancerNodePorts?: boolean;
            annotations?: {
                [key: string]: string;
            };
            /** @description serviceList screen */
            applications?: components["schemas"]["kubernetes.K8sApplication"][];
            clusterIPs?: string[];
            creationDate?: string;
            externalIPs?: string[];
            externalName?: string;
            ingressStatus?: components["schemas"]["kubernetes.K8sServiceIngress"][];
            labels?: {
                [key: string]: string;
            };
            name?: string;
            namespace?: string;
            ports?: components["schemas"]["kubernetes.K8sServicePort"][];
            selector?: {
                [key: string]: string;
            };
            type?: string;
            uid?: string;
        };
        "kubernetes.K8sServiceIngress": {
            Host?: string;
            IP?: string;
        };
        "kubernetes.K8sServicePort": {
            Name?: string;
            NodePort?: number;
            Port?: number;
            Protocol?: string;
            TargetPort?: string;
        };
        "kubernetes.K8sStorageClass": {
            allowVolumeExpansion?: boolean;
            name?: string;
            provisioner?: string;
            reclaimPolicy?: string;
        };
        "kubernetes.K8sVolumeInfo": {
            persistentVolume?: components["schemas"]["kubernetes.K8sPersistentVolume"];
            persistentVolumeClaim?: components["schemas"]["kubernetes.K8sPersistentVolumeClaim"];
            storageClass?: components["schemas"]["kubernetes.K8sStorageClass"];
        };
        "kubernetes.Metadata": {
            labels?: {
                [key: string]: string;
            };
        };
        "kubernetes.Pod": {
            Status?: string;
        };
        "kubernetes.PublishedPort": {
            IngressRules?: components["schemas"]["kubernetes.IngressRule"][];
            Port?: number;
        };
        "kubernetes.TLSInfo": {
            hosts?: string[];
        };
        "kubernetes.namespacesToggleSystemPayload": {
            /**
             * @description Toggle the system state of this namespace to true or false
             * @example true
             */
            system?: boolean;
        };
        "ldap.checkPayload": {
            ldapsettings?: components["schemas"]["portainer.LDAPSettings"];
        };
        "motd.motdResponse": {
            ContentLayout?: {
                [key: string]: string;
            };
            Hash?: number[];
            Message?: string;
            Style?: string;
            Title?: string;
        };
        "openamt.deviceActionPayload": {
            action?: string;
        };
        "openamt.deviceFeaturesPayload": {
            features?: components["schemas"]["portainer.OpenAMTDeviceEnabledFeatures"];
        };
        "openamt.openAMTConfigurePayload": {
            certFileContent?: string;
            certFileName?: string;
            certFilePassword?: string;
            domainName?: string;
            enabled?: boolean;
            mpspassword?: string;
            mpsserver?: string;
            mpsuser?: string;
        };
        "portainer.APIKey": {
            /** @description Unix timestamp (UTC) when the API key was created */
            dateCreated?: number;
            /** @example portainer-api-key */
            description?: string;
            /** @description Digest represents SHA256 hash of the raw API key */
            digest?: string;
            /** @example 1 */
            id?: number;
            /** @description Unix timestamp (UTC) when the API key was last used */
            lastUsed?: number;
            /** @description API key identifier (7 char prefix) */
            prefix?: string;
            /**
             * @description User Identifier
             * @example 1
             */
            userId?: number;
        };
        "portainer.AccessPolicy": {
            /**
             * @description Role identifier. Reference the role that will be associated to this access policy
             * @example 1
             */
            RoleId?: number;
        };
        "portainer.Authorizations": {
            [key: string]: boolean;
        };
        "portainer.AutoUpdateSettings": {
            /**
             * @description Pull latest image
             * @example false
             */
            forcePullImage?: boolean;
            /**
             * @description Force update ignores repo changes
             * @example false
             */
            forceUpdate?: boolean;
            /**
             * @description Auto update interval
             * @example 1m30s
             */
            interval?: string;
            /**
             * @description Autoupdate job id
             * @example 15
             */
            jobID?: string;
            /**
             * @description A UUID generated from client
             * @example 05de31a2-79fa-4644-9c12-faa67e5c49f0
             */
            webhook?: string;
        };
        "portainer.AzureCredentials": {
            /**
             * @description Azure application ID
             * @example eag7cdo9-o09l-9i83-9dO9-f0b23oe78db4
             */
            ApplicationID?: string;
            /**
             * @description Azure authentication key
             * @example cOrXoK/1D35w8YQ8nH1/8ZGwzz45JIYD5jxHKXEQknk=
             */
            AuthenticationKey?: string;
            /**
             * @description Azure tenant ID
             * @example 34ddc78d-4fel-2358-8cc1-df84c8o839f5
             */
            TenantID?: string;
        };
        "portainer.CustomTemplate": {
            /**
             * @description User identifier who created this template
             * @example 3
             */
            CreatedByUserId?: number;
            /**
             * @description Description of the template
             * @example High performance web server
             */
            Description?: string;
            /**
             * @description Path to the Stack file
             * @example docker-compose.yml
             */
            EntryPoint?: string;
            GitConfig?: components["schemas"]["gittypes.RepoConfig"];
            /**
             * @description CustomTemplate Identifier
             * @example 1
             */
            Id?: number;
            /**
             * @description URL of the template's logo
             * @example https://portainer.io/img/logo.svg
             */
            Logo?: string;
            /**
             * @description A note that will be displayed in the UI. Supports HTML content
             * @example This is my <b>custom</b> template
             */
            Note?: string;
            /**
             * @description Platform associated to the template.
             *     Valid values are: 1 - 'linux', 2 - 'windows'
             * @example 1
             * @enum {integer}
             */
            Platform?: 1 | 2;
            /**
             * @description Path on disk to the repository hosting the Stack file
             * @example /data/custom_template/3
             */
            ProjectPath?: string;
            ResourceControl?: components["schemas"]["portainer.ResourceControl"];
            /**
             * @description Title of the template
             * @example Nginx
             */
            Title?: string;
            /**
             * @description Type of created stack:
             *     * 1 - swarm
             *     * 2 - compose
             *     * 3 - kubernetes
             * @example 1
             * @enum {integer}
             */
            Type?: 1 | 2 | 3;
            /**
             * @description EdgeTemplate indicates if this template purpose for Edge Stack
             * @example false
             */
            edgeTemplate?: boolean;
            /**
             * @description IsComposeFormat indicates if the Kubernetes template is created from a Docker Compose file
             * @example false
             */
            isComposeFormat?: boolean;
            variables?: components["schemas"]["portainer.CustomTemplateVariableDefinition"][];
        };
        "portainer.CustomTemplateVariableDefinition": {
            /** @example default value */
            defaultValue?: string;
            /** @example Description */
            description?: string;
            /** @example My Variable */
            label?: string;
            /** @example MY_VAR */
            name?: string;
        };
        "portainer.DiagnosticsData": {
            DNS?: {
                [key: string]: string;
            };
            Log?: string;
            Proxy?: {
                [key: string]: string;
            };
            Telnet?: {
                [key: string]: string;
            };
        };
        "portainer.DockerSnapshot": {
            ContainerCount?: number;
            DiagnosticsData?: components["schemas"]["portainer.DiagnosticsData"];
            DockerSnapshotRaw?: components["schemas"]["portainer.DockerSnapshotRaw"];
            DockerVersion?: string;
            GpuUseAll?: boolean;
            GpuUseList?: string[];
            HealthyContainerCount?: number;
            ImageCount?: number;
            IsPodman?: boolean;
            NodeCount?: number;
            RunningContainerCount?: number;
            ServiceCount?: number;
            StackCount?: number;
            StoppedContainerCount?: number;
            Swarm?: boolean;
            Time?: number;
            TotalCPU?: number;
            TotalMemory?: number;
            UnhealthyContainerCount?: number;
            VolumeCount?: number;
        };
        "portainer.DockerSnapshotRaw": Record<string, never>;
        "portainer.EcrData": {
            /** @example ap-southeast-2 */
            Region?: string;
        };
        "portainer.Edge": {
            /**
             * @description Deprecated 2.18
             * @example false
             */
            AsyncMode?: boolean;
            /**
             * @description The command list interval for edge agent - used in edge async mode (in seconds)
             * @example 5
             */
            CommandInterval?: number;
            /**
             * @description The ping interval for edge agent - used in edge async mode (in seconds)
             * @example 5
             */
            PingInterval?: number;
            /**
             * @description The snapshot interval for edge agent - used in edge async mode (in seconds)
             * @example 5
             */
            SnapshotInterval?: number;
        };
        "portainer.EdgeGroup": {
            Dynamic?: boolean;
            Endpoints?: number[];
            /**
             * @description EdgeGroup Identifier
             * @example 1
             */
            Id?: number;
            Name?: string;
            PartialMatch?: boolean;
            TagIds?: number[];
        };
        "portainer.EdgeJob": {
            Created?: number;
            CronExpression?: string;
            EdgeGroups?: number[];
            Endpoints?: {
                [key: string]: components["schemas"]["portainer.EdgeJobEndpointMeta"];
            };
            /**
             * @description EdgeJob Identifier
             * @example 1
             */
            Id?: number;
            Name?: string;
            Recurring?: boolean;
            ScriptPath?: string;
            Version?: number;
            /** @description Field used for log collection of Endpoints belonging to EdgeGroups */
            groupLogsCollection?: {
                [key: string]: components["schemas"]["portainer.EdgeJobEndpointMeta"];
            };
        };
        "portainer.EdgeJobEndpointMeta": {
            collectLogs?: boolean;
            logsStatus?: number;
        };
        "portainer.EdgeStack": {
            /** @description StatusArray    map[EndpointID][]EdgeStackStatus `json:"StatusArray"` */
            CreationDate?: number;
            DeploymentType?: number;
            EdgeGroups?: number[];
            EntryPoint?: string;
            /**
             * @description EdgeStack Identifier
             * @example 1
             */
            Id?: number;
            ManifestPath?: string;
            Name?: string;
            NumDeployments?: number;
            ProjectPath?: string;
            Status?: {
                [key: string]: components["schemas"]["portainer.EdgeStackStatus"];
            };
            Version?: number;
            /** @description Uses the manifest's namespaces instead of the default one */
            useManifestNamespaces?: boolean;
        };
        "portainer.EdgeStackDeploymentStatus": {
            Version?: number;
            error?: string;
            /** @description EE only feature */
            rollbackTo?: number;
            time?: number;
            type?: number;
        };
        "portainer.EdgeStackStatus": {
            /** @description Deprecated */
            Type?: number;
            deploymentInfo?: components["schemas"]["portainer.StackDeploymentInfo"];
            details?: components["schemas"]["portainer.EdgeStackStatusDetails"];
            endpointID?: number;
            /** @description Deprecated */
            error?: string;
            /** @description ReadyRePullImage is a flag to indicate whether the auto update is trigger to re-pull image */
            readyRePullImage?: boolean;
            status?: components["schemas"]["portainer.EdgeStackDeploymentStatus"][];
        };
        "portainer.EdgeStackStatusDetails": {
            acknowledged?: boolean;
            error?: boolean;
            imagesPulled?: boolean;
            ok?: boolean;
            pending?: boolean;
            remoteUpdateSuccess?: boolean;
            remove?: boolean;
        };
        "portainer.Endpoint": {
            /**
             * @description The identifier of the AMT Device associated with this environment(endpoint)
             * @example 4c4c4544-004b-3910-8037-b6c04f504633
             */
            AMTDeviceGUID?: string;
            AuthorizedTeams?: number[];
            /** @description Deprecated in DBVersion == 18 */
            AuthorizedUsers?: number[];
            AzureCredentials?: components["schemas"]["portainer.AzureCredentials"];
            /**
             * @description Maximum version of docker-compose
             * @example 3.8
             */
            ComposeSyntaxMaxVersion?: string;
            /**
             * @description ContainerEngine represents the container engine type. This can be 'docker' or 'podman' when interacting directly with these environmentes, otherwise '' for kubernetes environments.
             * @example docker
             */
            ContainerEngine?: string;
            /**
             * @description The check in interval for edge agent (in seconds)
             * @example 5
             */
            EdgeCheckinInterval?: number;
            /** @description The identifier of the edge agent associated with this environment(endpoint) */
            EdgeID?: string;
            /** @description The key which is used to map the agent to Portainer */
            EdgeKey?: string;
            EnableGPUManagement?: boolean;
            Gpus?: components["schemas"]["portainer.Pair"][];
            /**
             * @description Environment(Endpoint) group identifier
             * @example 1
             */
            GroupId?: number;
            /**
             * @description Heartbeat indicates the heartbeat status of an edge environment
             * @example true
             */
            Heartbeat?: boolean;
            /**
             * @description Environment(Endpoint) Identifier
             * @example 1
             */
            Id?: number;
            /** @description Deprecated v2.18 */
            IsEdgeDevice?: boolean;
            Kubernetes?: components["schemas"]["portainer.KubernetesData"];
            /**
             * @description Environment(Endpoint) name
             * @example my-environment
             */
            Name?: string;
            PostInitMigrations?: components["schemas"]["portainer.EndpointPostInitMigrations"];
            /**
             * @description URL or IP address where exposed containers will be reachable
             * @example docker.mydomain.tld:2375
             */
            PublicURL?: string;
            /** @description List of snapshots */
            Snapshots?: components["schemas"]["portainer.DockerSnapshot"][];
            /**
             * @description The status of the environment(endpoint) (1 - up, 2 - down)
             * @example 1
             */
            Status?: number;
            /** @description Deprecated fields
             *     Deprecated in DBVersion == 4 */
            TLS?: boolean;
            TLSCACert?: string;
            TLSCert?: string;
            TLSConfig?: components["schemas"]["portainer.TLSConfiguration"];
            TLSKey?: string;
            /** @description List of tag identifiers to which this environment(endpoint) is associated */
            TagIds?: number[];
            /** @description Deprecated in DBVersion == 22 */
            Tags?: string[];
            TeamAccessPolicies?: components["schemas"]["portainer.TeamAccessPolicies"];
            /**
             * @description Environment(Endpoint) environment(endpoint) type. 1 for a Docker environment(endpoint), 2 for an agent on Docker environment(endpoint) or 3 for an Azure environment(endpoint).
             * @example 1
             */
            Type?: number;
            /**
             * @description URL or IP address of the Docker host associated to this environment(endpoint)
             * @example docker.mydomain.tld:2375
             */
            URL?: string;
            UserAccessPolicies?: components["schemas"]["portainer.UserAccessPolicies"];
            /** @description Whether the device has been trusted or not by the user */
            UserTrusted?: boolean;
            agent?: {
                /** @example 1.0.0 */
                version?: string;
            };
            edge?: components["schemas"]["portainer.EnvironmentEdgeSettings"];
            /** @description LastCheckInDate mark last check-in date on checkin */
            lastCheckInDate?: number;
            /** @description QueryDate of each query with the endpoints list */
            queryDate?: number;
            securitySettings?: components["schemas"]["portainer.EndpointSecuritySettings"];
        };
        "portainer.EndpointAuthorizations": {
            [key: string]: components["schemas"]["portainer.Authorizations"];
        };
        "portainer.EndpointGroup": {
            AuthorizedTeams?: number[];
            /** @description Deprecated in DBVersion == 18 */
            AuthorizedUsers?: number[];
            /**
             * @description Description associated to the environment(endpoint) group
             * @example Environment(Endpoint) group description
             */
            Description?: string;
            /**
             * @description Environment(Endpoint) group Identifier
             * @example 1
             */
            Id?: number;
            /** @description Deprecated fields */
            Labels?: components["schemas"]["portainer.Pair"][];
            /**
             * @description Environment(Endpoint) group name
             * @example my-environment-group
             */
            Name?: string;
            /** @description List of tags associated to this environment(endpoint) group */
            TagIds?: number[];
            /** @description Deprecated in DBVersion == 22 */
            Tags?: string[];
            TeamAccessPolicies?: components["schemas"]["portainer.TeamAccessPolicies"];
            UserAccessPolicies?: components["schemas"]["portainer.UserAccessPolicies"];
        };
        "portainer.EndpointPostInitMigrations": {
            MigrateGPUs?: boolean;
            MigrateIngresses?: boolean;
        };
        "portainer.EndpointSecuritySettings": {
            /**
             * @description Whether non-administrator should be able to use bind mounts when creating containers
             * @example false
             */
            allowBindMountsForRegularUsers?: boolean;
            /**
             * @description Whether non-administrator should be able to use container capabilities
             * @example true
             */
            allowContainerCapabilitiesForRegularUsers?: boolean;
            /**
             * @description Whether non-administrator should be able to use device mapping
             * @example true
             */
            allowDeviceMappingForRegularUsers?: boolean;
            /**
             * @description Whether non-administrator should be able to use the host pid
             * @example true
             */
            allowHostNamespaceForRegularUsers?: boolean;
            /**
             * @description Whether non-administrator should be able to use privileged mode when creating containers
             * @example false
             */
            allowPrivilegedModeForRegularUsers?: boolean;
            /**
             * @description Whether non-administrator should be able to manage stacks
             * @example true
             */
            allowStackManagementForRegularUsers?: boolean;
            /**
             * @description Whether non-administrator should be able to use sysctl settings
             * @example true
             */
            allowSysctlSettingForRegularUsers?: boolean;
            /**
             * @description Whether non-administrator should be able to browse volumes
             * @example true
             */
            allowVolumeBrowserForRegularUsers?: boolean;
            /**
             * @description Whether host management features are enabled
             * @example true
             */
            enableHostManagementFeatures?: boolean;
        };
        "portainer.EnvironmentEdgeSettings": {
            /**
             * @description The command list interval for edge agent - used in edge async mode [seconds]
             * @example 60
             */
            CommandInterval?: number;
            /**
             * @description The ping interval for edge agent - used in edge async mode [seconds]
             * @example 60
             */
            PingInterval?: number;
            /**
             * @description The snapshot interval for edge agent - used in edge async mode [seconds]
             * @example 60
             */
            SnapshotInterval?: number;
            /** @description Whether the device has been started in edge async mode */
            asyncMode?: boolean;
        };
        "portainer.GitlabRegistryData": {
            InstanceURL?: string;
            ProjectId?: number;
            ProjectPath?: string;
        };
        "portainer.GlobalDeploymentOptions": {
            /** @example false */
            hideStacksFunctionality?: boolean;
        };
        "portainer.HelmUserRepository": {
            /**
             * @description Membership Identifier
             * @example 1
             */
            Id?: number;
            /**
             * @description Helm repository URL
             * @example https://kubernetes.github.io/ingress-nginx
             */
            URL?: string;
            /**
             * @description User identifier
             * @example 1
             */
            UserId?: number;
        };
        "portainer.InternalAuthSettings": {
            requiredPasswordLength?: number;
        };
        "portainer.K8sNamespaceInfo": {
            Annotations?: {
                [key: string]: string;
            };
            CreationDate?: string;
            Id?: string;
            IsDefault?: boolean;
            IsSystem?: boolean;
            Name?: string;
            NamespaceOwner?: string;
            ResourceQuota?: components["schemas"]["v1.ResourceQuota"];
            Status?: components["schemas"]["v1.NamespaceStatus"];
        };
        "portainer.K8sNodeLimits": {
            CPU?: number;
            Memory?: number;
        };
        "portainer.K8sNodesLimits": {
            [key: string]: components["schemas"]["portainer.K8sNodeLimits"];
        };
        "portainer.KubernetesConfiguration": {
            AllowNoneIngressClass?: boolean;
            EnableResourceOverCommit?: boolean;
            IngressAvailabilityPerNamespace?: boolean;
            IngressClasses?: components["schemas"]["portainer.KubernetesIngressClassConfig"][];
            ResourceOverCommitPercentage?: number;
            RestrictDefaultNamespace?: boolean;
            StorageClasses?: components["schemas"]["portainer.KubernetesStorageClassConfig"][];
            UseLoadBalancer?: boolean;
            UseServerMetrics?: boolean;
        };
        "portainer.KubernetesData": {
            Configuration?: components["schemas"]["portainer.KubernetesConfiguration"];
            Flags?: components["schemas"]["portainer.KubernetesFlags"];
            Snapshots?: components["schemas"]["portainer.KubernetesSnapshot"][];
        };
        "portainer.KubernetesFlags": {
            IsServerIngressClassDetected?: boolean;
            IsServerMetricsDetected?: boolean;
            IsServerStorageDetected?: boolean;
        };
        "portainer.KubernetesIngressClassConfig": {
            Blocked?: boolean;
            BlockedNamespaces?: string[];
            Name?: string;
            Type?: string;
        };
        "portainer.KubernetesSnapshot": {
            DiagnosticsData?: components["schemas"]["portainer.DiagnosticsData"];
            KubernetesVersion?: string;
            NodeCount?: number;
            Time?: number;
            TotalCPU?: number;
            TotalMemory?: number;
        };
        "portainer.KubernetesStorageClassConfig": {
            AccessModes?: string[];
            AllowVolumeExpansion?: boolean;
            Name?: string;
            Provisioner?: string;
        };
        "portainer.LDAPGroupSearchSettings": {
            /**
             * @description LDAP attribute which denotes the group membership
             * @example member
             */
            GroupAttribute?: string;
            /**
             * @description The distinguished name of the element from which the LDAP server will search for groups
             * @example dc=ldap,dc=domain,dc=tld
             */
            GroupBaseDN?: string;
            /**
             * @description The LDAP search filter used to select group elements, optional
             * @example (objectClass=account
             */
            GroupFilter?: string;
        };
        "portainer.LDAPSearchSettings": {
            /**
             * @description The distinguished name of the element from which the LDAP server will search for users
             * @example dc=ldap,dc=domain,dc=tld
             */
            BaseDN?: string;
            /**
             * @description Optional LDAP search filter used to select user elements
             * @example (objectClass=account)
             */
            Filter?: string;
            /**
             * @description LDAP attribute which denotes the username
             * @example uid
             */
            UserNameAttribute?: string;
        };
        "portainer.LDAPSettings": {
            /**
             * @description Enable this option if the server is configured for Anonymous access. When enabled, ReaderDN and Password will not be used
             * @example true
             */
            AnonymousMode?: boolean;
            /**
             * @description Automatically provision users and assign them to matching LDAP group names
             * @example true
             */
            AutoCreateUsers?: boolean;
            GroupSearchSettings?: components["schemas"]["portainer.LDAPGroupSearchSettings"][];
            /**
             * @description Password of the account that will be used to search users
             * @example readonly-password
             */
            Password?: string;
            /**
             * @description Account that will be used to search for users
             * @example cn=readonly-account,dc=ldap,dc=domain,dc=tld
             */
            ReaderDN?: string;
            SearchSettings?: components["schemas"]["portainer.LDAPSearchSettings"][];
            /**
             * @description Whether LDAP connection should use StartTLS
             * @example true
             */
            StartTLS?: boolean;
            TLSConfig?: components["schemas"]["portainer.TLSConfiguration"];
            /**
             * @description URL or IP address of the LDAP server
             * @example myldap.domain.tld:389
             */
            URL?: string;
        };
        "portainer.OAuthSettings": {
            AccessTokenURI?: string;
            AuthStyle?: number;
            AuthorizationURI?: string;
            ClientID?: string;
            ClientSecret?: string;
            DefaultTeamID?: number;
            KubeSecretKey?: number[];
            LogoutURI?: string;
            OAuthAutoCreateUsers?: boolean;
            RedirectURI?: string;
            ResourceURI?: string;
            SSO?: boolean;
            Scopes?: string;
            UserIdentifier?: string;
        };
        "portainer.OpenAMTConfiguration": {
            certFileContent?: string;
            certFileName?: string;
            certFilePassword?: string;
            domainName?: string;
            enabled?: boolean;
            mpsPassword?: string;
            mpsServer?: string;
            /** @description retrieved from API */
            mpsToken?: string;
            mpsUser?: string;
        };
        "portainer.OpenAMTDeviceEnabledFeatures": {
            IDER?: boolean;
            KVM?: boolean;
            SOL?: boolean;
            redirection?: boolean;
            userConsent?: string;
        };
        "portainer.Pair": {
            /** @example name */
            name?: string;
            /** @example value */
            value?: string;
        };
        "portainer.QuayRegistryData": {
            OrganisationName?: string;
            UseOrganisation?: boolean;
        };
        "portainer.Registry": {
            /** @description Stores temporary access token */
            AccessToken?: string;
            AccessTokenExpiry?: number;
            /**
             * @description Is authentication against this registry enabled
             * @example true
             */
            Authentication?: boolean;
            /** @description Deprecated in DBVersion == 18 */
            AuthorizedTeams?: number[];
            /** @description Deprecated in DBVersion == 18 */
            AuthorizedUsers?: number[];
            /**
             * @description Base URL, introduced for ProGet registry
             * @example registry.mydomain.tld:2375
             */
            BaseURL?: string;
            Ecr?: components["schemas"]["portainer.EcrData"];
            Gitlab?: components["schemas"]["portainer.GitlabRegistryData"];
            /**
             * @description Registry Identifier
             * @example 1
             */
            Id?: number;
            ManagementConfiguration?: components["schemas"]["portainer.RegistryManagementConfiguration"];
            /**
             * @description Registry Name
             * @example my-registry
             */
            Name?: string;
            /**
             * @description Password or SecretAccessKey used to authenticate against this registry
             * @example registry_password
             */
            Password?: string;
            Quay?: components["schemas"]["portainer.QuayRegistryData"];
            RegistryAccesses?: components["schemas"]["portainer.RegistryAccesses"];
            TeamAccessPolicies?: components["schemas"]["portainer.TeamAccessPolicies"];
            /**
             * @description Registry Type (1 - Quay, 2 - Azure, 3 - Custom, 4 - Gitlab, 5 - ProGet, 6 - DockerHub, 7 - ECR)
             * @enum {integer}
             */
            Type?: 1 | 2 | 3 | 4 | 5 | 6 | 7;
            /**
             * @description URL or IP address of the Docker registry
             * @example registry.mydomain.tld:2375
             */
            URL?: string;
            UserAccessPolicies?: components["schemas"]["portainer.UserAccessPolicies"];
            /**
             * @description Username or AccessKeyID used to authenticate against this registry
             * @example registry user
             */
            Username?: string;
        };
        "portainer.RegistryAccessPolicies": {
            Namespaces?: string[];
            TeamAccessPolicies?: components["schemas"]["portainer.TeamAccessPolicies"];
            UserAccessPolicies?: components["schemas"]["portainer.UserAccessPolicies"];
        };
        "portainer.RegistryAccesses": {
            [key: string]: components["schemas"]["portainer.RegistryAccessPolicies"];
        };
        "portainer.RegistryManagementConfiguration": {
            AccessToken?: string;
            AccessTokenExpiry?: number;
            Authentication?: boolean;
            Ecr?: components["schemas"]["portainer.EcrData"];
            Password?: string;
            TLSConfig?: components["schemas"]["portainer.TLSConfiguration"];
            /** @description Registry Type (1 - Quay, 2 - Azure, 3 - Custom, 4 - Gitlab, 5 - ProGet, 6 - DockerHub, 7 - ECR) */
            Type?: number;
            Username?: string;
        };
        "portainer.ResourceControl": {
            AccessLevel?: number;
            /**
             * @description Permit access to resource only to admins
             * @example true
             */
            AdministratorsOnly?: boolean;
            /**
             * @description ResourceControl Identifier
             * @example 1
             */
            Id?: number;
            /** @description Deprecated fields
             *     Deprecated in DBVersion == 2 */
            OwnerId?: number;
            /**
             * @description Permit access to the associated resource to any user
             * @example true
             */
            Public?: boolean;
            /**
             * @description Docker resource identifier on which access control will be applied.\
             *     In the case of a resource control applied to a stack, use the stack name as identifier
             * @example 617c5f22bb9b023d6daab7cba43a57576f83492867bc767d1c59416b065e5f08
             */
            ResourceId?: string;
            /**
             * @description List of Docker resources that will inherit this access control
             * @example [
             *       "617c5f22bb9b023d6daab7cba43a57576f83492867bc767d1c59416b065e5f08"
             *     ]
             */
            SubResourceIds?: string[];
            System?: boolean;
            TeamAccesses?: components["schemas"]["portainer.TeamResourceAccess"][];
            /**
             * @description Type of Docker resource. Valid values are: 1- container, 2 -service
             *     3 - volume, 4 - secret, 5 - stack, 6 - config or 7 - custom template
             * @example 1
             */
            Type?: number;
            UserAccesses?: components["schemas"]["portainer.UserResourceAccess"][];
        };
        "portainer.Role": {
            Authorizations?: components["schemas"]["portainer.Authorizations"];
            /**
             * @description Role description
             * @example Read-only access of all resources in an environment(endpoint)
             */
            Description?: string;
            /**
             * @description Role Identifier
             * @example 1
             */
            Id?: number;
            /**
             * @description Role name
             * @example HelpDesk
             */
            Name?: string;
            Priority?: number;
        };
        "portainer.SSLSettings": {
            certPath?: string;
            httpEnabled?: boolean;
            keyPath?: string;
            selfSigned?: boolean;
        };
        "portainer.Settings": {
            /** @description Container environment parameter AGENT_SECRET */
            AgentSecret?: string;
            AllowBindMountsForRegularUsers?: boolean;
            AllowContainerCapabilitiesForRegularUsers?: boolean;
            AllowDeviceMappingForRegularUsers?: boolean;
            AllowHostNamespaceForRegularUsers?: boolean;
            AllowPrivilegedModeForRegularUsers?: boolean;
            AllowStackManagementForRegularUsers?: boolean;
            AllowVolumeBrowserForRegularUsers?: boolean;
            /**
             * @description Active authentication method for the Portainer instance. Valid values are: 1 for internal, 2 for LDAP, or 3 for oauth
             * @example 1
             */
            AuthenticationMethod?: number;
            /** @description A list of label name & value that will be used to hide containers when querying containers */
            BlackListedLabels?: components["schemas"]["portainer.Pair"][];
            /** @description Deprecated fields */
            DisplayDonationHeader?: boolean;
            DisplayExternalContributors?: boolean;
            Edge?: components["schemas"]["portainer.Edge"];
            /**
             * @description The default check in interval for edge agent (in seconds)
             * @example 5
             */
            EdgeAgentCheckinInterval?: number;
            /** @description EdgePortainerURL is the URL that is exposed to edge agents */
            EdgePortainerUrl?: string;
            /** @description Whether edge compute features are enabled */
            EnableEdgeComputeFeatures?: boolean;
            /** @description Deprecated fields v26 */
            EnableHostManagementFeatures?: boolean;
            /**
             * @description Whether telemetry is enabled
             * @example false
             */
            EnableTelemetry?: boolean;
            /**
             * @description EnforceEdgeID makes Portainer store the Edge ID instead of accepting anyone
             * @example false
             */
            EnforceEdgeID?: boolean;
            FeatureFlagSettings?: {
                [key: string]: boolean;
            };
            GlobalDeploymentOptions?: components["schemas"]["portainer.GlobalDeploymentOptions"];
            /** @description Helm repository URL, defaults to "" */
            HelmRepositoryURL?: string;
            InternalAuthSettings?: components["schemas"]["portainer.InternalAuthSettings"];
            IsDockerDesktopExtension?: boolean;
            /**
             * @description The expiry of a Kubeconfig
             * @example 24h
             */
            KubeconfigExpiry?: string;
            /**
             * @description KubectlImage, defaults to portainer/kubectl-shell
             * @example portainer/kubectl-shell
             */
            KubectlShellImage?: string;
            LDAPSettings?: components["schemas"]["portainer.LDAPSettings"];
            /**
             * @description URL to a logo that will be displayed on the login page as well as on top of the sidebar. Will use default Portainer logo when value is empty string
             * @example https://mycompany.mydomain.tld/logo.png
             */
            LogoURL?: string;
            OAuthSettings?: components["schemas"]["portainer.OAuthSettings"];
            /**
             * @description The interval in which environment(endpoint) snapshots are created
             * @example 5m
             */
            SnapshotInterval?: string;
            /**
             * @description URL to the templates that will be displayed in the UI when navigating to App Templates
             * @example https://raw.githubusercontent.com/portainer/templates/master/templates.json
             */
            TemplatesURL?: string;
            /**
             * @description TrustOnFirstConnect makes Portainer accepting edge agent connection by default
             * @example false
             */
            TrustOnFirstConnect?: boolean;
            /**
             * @description The duration of a user session
             * @example 5m
             */
            UserSessionTimeout?: string;
            openAMTConfiguration?: components["schemas"]["portainer.OpenAMTConfiguration"];
        };
        "portainer.Stack": {
            /** @description Only applies when deploying stack with multiple files */
            AdditionalFiles?: string[];
            AutoUpdate?: components["schemas"]["portainer.AutoUpdateSettings"];
            /**
             * @description Environment(Endpoint) identifier. Reference the environment(endpoint) that will be used for deployment
             * @example 1
             */
            EndpointId?: number;
            /**
             * @description Path to the Stack file
             * @example docker-compose.yml
             */
            EntryPoint?: string;
            /** @description A list of environment(endpoint) variables used during stack deployment */
            Env?: components["schemas"]["portainer.Pair"][];
            /**
             * @description Stack Identifier
             * @example 1
             */
            Id?: number;
            /**
             * @description Stack name
             * @example myStack
             */
            Name?: string;
            Option?: components["schemas"]["portainer.StackOption"];
            ResourceControl?: components["schemas"]["portainer.ResourceControl"];
            /**
             * @description Stack status (1 - active, 2 - inactive)
             * @example 1
             */
            Status?: number;
            /**
             * @description Cluster identifier of the Swarm cluster where the stack is deployed
             * @example jpofkc0i9uo9wtx1zesuk649w
             */
            SwarmId?: string;
            /**
             * @description Stack type. 1 for a Swarm stack, 2 for a Compose stack
             * @example 2
             */
            Type?: number;
            /**
             * @description The username which created this stack
             * @example admin
             */
            createdBy?: string;
            /**
             * @description The date in unix time when stack was created
             * @example 1587399600
             */
            creationDate?: number;
            /**
             * @description Whether the stack is from a app template
             * @example false
             */
            fromAppTemplate?: boolean;
            gitConfig?: components["schemas"]["gittypes.RepoConfig"];
            /**
             * @description Kubernetes namespace if stack is a kube application
             * @example default
             */
            namespace?: string;
            /**
             * @description Path on disk to the repository hosting the Stack file
             * @example /data/compose/myStack_jpofkc0i9uo9wtx1zesuk649w
             */
            projectPath?: string;
            /**
             * @description The date in unix time when stack was last updated
             * @example 1587399600
             */
            updateDate?: number;
            /**
             * @description The username which last updated this stack
             * @example bob
             */
            updatedBy?: string;
        };
        "portainer.StackDeploymentInfo": {
            /** @description ConfigHash is the commit hash of the git repository used for deploying the stack */
            ConfigHash?: string;
            /** @description FileVersion is the version of the stack file, used to detect changes */
            FileVersion?: number;
            /** @description Version is the version of the stack and also is the deployed version in edge agent */
            Version?: number;
        };
        "portainer.StackOption": {
            /**
             * @description Prune services that are no longer referenced
             * @example false
             */
            prune?: boolean;
        };
        "portainer.TLSConfiguration": {
            /**
             * @description Use TLS
             * @example true
             */
            TLS?: boolean;
            /**
             * @description Path to the TLS CA certificate file
             * @example /data/tls/ca.pem
             */
            TLSCACert?: string;
            /**
             * @description Path to the TLS client certificate file
             * @example /data/tls/cert.pem
             */
            TLSCert?: string;
            /**
             * @description Path to the TLS client key file
             * @example /data/tls/key.pem
             */
            TLSKey?: string;
            /**
             * @description Skip the verification of the server TLS certificate
             * @example false
             */
            TLSSkipVerify?: boolean;
        };
        "portainer.Tag": {
            /** @description A set of environment(endpoint) group ids that have this tag */
            EndpointGroups?: {
                [key: string]: boolean;
            };
            /** @description A set of environment(endpoint) ids that have this tag */
            Endpoints?: {
                [key: string]: boolean;
            };
            /**
             * @description Tag name
             * @example org/acme
             */
            Name?: string;
            /**
             * @description Tag identifier
             * @example 1
             */
            id?: number;
        };
        "portainer.Team": {
            /**
             * @description Team Identifier
             * @example 1
             */
            Id?: number;
            /**
             * @description Team name
             * @example developers
             */
            Name?: string;
        };
        "portainer.TeamAccessPolicies": {
            [key: string]: components["schemas"]["portainer.AccessPolicy"];
        };
        "portainer.TeamMembership": {
            /**
             * @description Membership Identifier
             * @example 1
             */
            Id?: number;
            /**
             * @description Team role (1 for team leader and 2 for team member)
             * @example 1
             */
            Role?: number;
            /**
             * @description Team identifier
             * @example 1
             */
            TeamID?: number;
            /**
             * @description User identifier
             * @example 1
             */
            UserID?: number;
        };
        "portainer.TeamResourceAccess": {
            AccessLevel?: number;
            TeamId?: number;
        };
        "portainer.Template": {
            /**
             * @description Whether the template should be available to administrators only
             * @example true
             */
            administrator_only?: boolean;
            /**
             * @description A list of categories associated to the template
             * @example [
             *       "database"
             *     ]
             */
            categories?: string[];
            /**
             * @description The command that will be executed in a container template
             * @example ls -lah
             */
            command?: string;
            /**
             * @description Description of the template
             * @example High performance web server
             */
            description?: string;
            /** @description A list of environment(endpoint) variables used during the template deployment */
            env?: components["schemas"]["portainer.TemplateEnv"][];
            /**
             * @description Container hostname
             * @example mycontainer
             */
            hostname?: string;
            /**
             * @description Mandatory container/stack fields
             *     Template Identifier
             * @example 1
             */
            id?: number;
            /**
             * @description Mandatory container fields
             *     Image associated to a container template. Mandatory for a container template
             * @example nginx:latest
             */
            image?: string;
            /**
             * @description Whether the container should be started in
             *     interactive mode (-i -t equivalent on the CLI)
             * @example true
             */
            interactive?: boolean;
            /** @description Container labels */
            labels?: components["schemas"]["portainer.Pair"][];
            /**
             * @description URL of the template's logo
             * @example https://portainer.io/img/logo.svg
             */
            logo?: string;
            /**
             * @description Optional stack/container fields
             *     Default name for the stack/container to be used on deployment
             * @example mystackname
             */
            name?: string;
            /**
             * @description Name of a network that will be used on container deployment if it exists inside the environment(endpoint)
             * @example mynet
             */
            network?: string;
            /**
             * @description A note that will be displayed in the UI. Supports HTML content
             * @example This is my <b>custom</b> template
             */
            note?: string;
            /**
             * @description Platform associated to the template.
             *     Valid values are: 'linux', 'windows' or leave empty for multi-platform
             * @example linux
             */
            platform?: string;
            /**
             * @description A list of ports exposed by the container
             * @example [
             *       "8080:80/tcp"
             *     ]
             */
            ports?: string[];
            /**
             * @description Whether the container should be started in privileged mode
             * @example true
             */
            privileged?: boolean;
            /**
             * @description Optional container fields
             *     The URL of a registry associated to the image for a container template
             * @example quay.io
             */
            registry?: string;
            repository?: components["schemas"]["portainer.TemplateRepository"];
            /**
             * @description Container restart policy
             * @example on-failure
             */
            restart_policy?: string;
            /** @description Mandatory Edge stack fields
             *     Stack file used for this template */
            stackFile?: string;
            /**
             * @description Title of the template
             * @example Nginx
             */
            title?: string;
            /**
             * @description Template type. Valid values are: 1 (container), 2 (Swarm stack), 3 (Compose stack), 4 (Compose edge stack)
             * @example 1
             */
            type?: number;
            /** @description A list of volumes used during the container template deployment */
            volumes?: components["schemas"]["portainer.TemplateVolume"][];
        };
        "portainer.TemplateEnv": {
            /**
             * @description Default value that will be set for the variable
             * @example default_value
             */
            default?: string;
            /**
             * @description Content of the tooltip that will be generated in the UI
             * @example MySQL root account password
             */
            description?: string;
            /**
             * @description Text for the label that will be generated in the UI
             * @example Root password
             */
            label?: string;
            /**
             * @description name of the environment(endpoint) variable
             * @example MYSQL_ROOT_PASSWORD
             */
            name?: string;
            /**
             * @description If set to true, will not generate any input for this variable in the UI
             * @example false
             */
            preset?: boolean;
            /** @description A list of name/value that will be used to generate a dropdown in the UI */
            select?: components["schemas"]["portainer.TemplateEnvSelect"][];
        };
        "portainer.TemplateEnvSelect": {
            /**
             * @description Will set this choice as the default choice
             * @example false
             */
            default?: boolean;
            /**
             * @description Some text that will displayed as a choice
             * @example text value
             */
            text?: string;
            /**
             * @description A value that will be associated to the choice
             * @example value
             */
            value?: string;
        };
        "portainer.TemplateRepository": {
            /**
             * @description Path to the stack file inside the git repository
             * @example ./subfolder/docker-compose.yml
             */
            stackfile?: string;
            /**
             * @description URL of a git repository used to deploy a stack template. Mandatory for a Swarm/Compose stack template
             * @example https://github.com/portainer/portainer-compose
             */
            url?: string;
        };
        "portainer.TemplateVolume": {
            /**
             * @description Path on the host
             * @example /tmp
             */
            bind?: string;
            /**
             * @description Path inside the container
             * @example /data
             */
            container?: string;
            /**
             * @description Whether the volume used should be readonly
             * @example true
             */
            readonly?: boolean;
        };
        "portainer.User": {
            /**
             * @description User Identifier
             * @example 1
             */
            Id?: number;
            /**
             * @description User role (1 for administrator account and 2 for regular account)
             * @example 1
             */
            Role?: number;
            ThemeSettings?: components["schemas"]["portainer.UserThemeSettings"];
            /** @example 1 */
            TokenIssueAt?: number;
            /** @example true */
            UseCache?: boolean;
            /**
             * @description Deprecated
             * @example dark
             */
            UserTheme?: string;
            /** @example bob */
            Username?: string;
            endpointAuthorizations?: components["schemas"]["portainer.EndpointAuthorizations"];
            portainerAuthorizations?: components["schemas"]["portainer.Authorizations"];
        };
        "portainer.UserAccessPolicies": {
            [key: string]: components["schemas"]["portainer.AccessPolicy"];
        };
        "portainer.UserResourceAccess": {
            AccessLevel?: number;
            /** @description User identifier who created this template */
            UserId?: number;
        };
        "portainer.UserThemeSettings": {
            /**
             * @description Color represents the color theme of the UI
             * @example dark
             * @enum {string}
             */
            color?: "dark" | "light" | "highcontrast" | "auto";
        };
        "portainer.Webhook": {
            /** @description Environment(Endpoint) identifier. Reference the environment(endpoint) that will be used for deployment */
            EndpointId?: number;
            /**
             * @description Webhook Identifier
             * @example 1
             */
            Id?: number;
            /** @description Registry Identifier */
            RegistryId?: number;
            ResourceId?: string;
            Token?: string;
            /** @description Type of webhook (1 - service) */
            Type?: number;
        };
        "registries.registryConfigurePayload": {
            /**
             * @description Is authentication against this registry enabled
             * @example false
             */
            authentication: boolean;
            /**
             * @description Password used to authenticate against this registry. required when Authentication is true
             * @example registry_password
             */
            password?: string;
            /** @description ECR region */
            region?: string;
            /**
             * @description Use TLS
             * @example true
             */
            tls?: boolean;
            /** @description The TLS CA certificate file */
            tlscacertFile?: number[];
            /** @description The TLS client certificate file */
            tlscertFile?: number[];
            /** @description The TLS client key file */
            tlskeyFile?: number[];
            /**
             * @description Skip the verification of the server TLS certificate
             * @example false
             */
            tlsskipVerify?: boolean;
            /**
             * @description Username used to authenticate against this registry. Required when Authentication is true
             * @example registry_user
             */
            username?: string;
        };
        "registries.registryCreatePayload": {
            /**
             * @description Is authentication against this registry enabled
             * @example false
             */
            authentication: boolean;
            /**
             * @description BaseURL required for ProGet registry
             * @example registry.mydomain.tld:2375
             */
            baseURL?: string;
            ecr?: components["schemas"]["portainer.EcrData"];
            gitlab?: components["schemas"]["portainer.GitlabRegistryData"];
            /**
             * @description Name that will be used to identify this registry
             * @example my-registry
             */
            name: string;
            /**
             * @description Password used to authenticate against this registry. required when Authentication is true
             * @example registry_password
             */
            password?: string;
            quay?: components["schemas"]["portainer.QuayRegistryData"];
            /**
             * @description Registry Type. Valid values are:
             *     	1 (Quay.io),
             *     	2 (Azure container registry),
             *     	3 (custom registry),
             *     	4 (Gitlab registry),
             *     	5 (ProGet registry),
             *     	6 (DockerHub)
             *     	7 (ECR)
             * @example 1
             * @enum {integer}
             */
            type: 1 | 2 | 3 | 4 | 5 | 6 | 7;
            /**
             * @description URL or IP address of the Docker registry
             * @example registry.mydomain.tld:2375/feed
             */
            url: string;
            /**
             * @description Username used to authenticate against this registry. Required when Authentication is true
             * @example registry_user
             */
            username?: string;
        };
        "registries.registryUpdatePayload": {
            /**
             * @description Is authentication against this registry enabled
             * @example false
             */
            authentication: boolean;
            /**
             * @description BaseURL is used for quay registry
             * @example registry.mydomain.tld:2375
             */
            baseURL?: string;
            ecr?: components["schemas"]["portainer.EcrData"];
            /**
             * @description Name that will be used to identify this registry
             * @example my-registry
             */
            name: string;
            /**
             * @description Password used to authenticate against this registry. required when Authentication is true
             * @example registry_password
             */
            password?: string;
            quay?: components["schemas"]["portainer.QuayRegistryData"];
            registryAccesses?: components["schemas"]["portainer.RegistryAccesses"];
            /**
             * @description URL or IP address of the Docker registry
             * @example registry.mydomain.tld:2375
             */
            url: string;
            /**
             * @description Username used to authenticate against this registry. Required when Authentication is true
             * @example registry_user
             */
            username?: string;
        };
        "release.Chart": {
            /** @description Files are miscellaneous files in a chart archive,
             *     e.g. README, LICENSE, etc. */
            files?: components["schemas"]["release.File"][];
            lock?: components["schemas"]["release.Lock"];
            metadata?: components["schemas"]["release.Metadata"];
            /** @description Schema is an optional JSON schema for imposing structure on Values */
            schema?: number[];
            /** @description Templates for this chart. */
            templates?: components["schemas"]["release.File"][];
            /** @description Values are default config for this chart. */
            values?: {
                [key: string]: unknown;
            };
        };
        "release.Dependency": {
            /** @description Alias usable alias to be used for the chart */
            alias?: string;
            /** @description A yaml path that resolves to a boolean, used for enabling/disabling charts (e.g. subchart1.enabled ) */
            condition?: string;
            /** @description Enabled bool determines if chart should be loaded */
            enabled?: boolean;
            /** @description ImportValues holds the mapping of source values to parent key to be imported. Each item can be a
             *     string or pair of child/parent sublist items. */
            "import-values"?: unknown[];
            /** @description Name is the name of the dependency.
             *
             *     This must mach the name in the dependency's Chart.yaml. */
            name?: string;
            /** @description The URL to the repository.
             *
             *     Appending `index.yaml` to this string should result in a URL that can be
             *     used to fetch the repository index. */
            repository?: string;
            /** @description Tags can be used to group charts for enabling/disabling together */
            tags?: string[];
            /** @description Version is the version (range) of this chart.
             *
             *     A lock file will always produce a single version, while a dependency
             *     may contain a semantic version range. */
            version?: string;
        };
        "release.File": {
            /** @description Data is the template as byte data. */
            data?: number[];
            /** @description Name is the path-like name of the template. */
            name?: string;
        };
        "release.Hook": {
            /** @description DeletePolicies are the policies that indicate when to delete the hook */
            delete_policies?: string[];
            /** @description Events are the events that this hook fires on. */
            events?: string[];
            /** @description Kind is the Kubernetes kind. */
            kind?: string;
            last_run?: components["schemas"]["release.HookExecution"];
            /** @description Manifest is the manifest contents. */
            manifest?: string;
            name?: string;
            /** @description Path is the chart-relative path to the template. */
            path?: string;
            /** @description Weight indicates the sort order for execution among similar Hook type */
            weight?: number;
        };
        "release.HookExecution": {
            /** @description CompletedAt indicates the date/time this hook was completed. */
            completed_at?: string;
            /** @description Phase indicates whether the hook completed successfully */
            phase?: string;
            /** @description StartedAt indicates the date/time this hook was started */
            started_at?: string;
        };
        "release.Lock": {
            /** @description Dependencies is the list of dependencies that this lock file has locked. */
            dependencies?: components["schemas"]["release.Dependency"][];
            /** @description Digest is a hash of the dependencies in Chart.yaml. */
            digest?: string;
            /** @description Generated is the date the lock file was last generated. */
            generated?: string;
        };
        "release.Maintainer": {
            /** @description Email is an optional email address to contact the named maintainer */
            email?: string;
            /** @description Name is a user name or organization name */
            name?: string;
            /** @description URL is an optional URL to an address for the named maintainer */
            url?: string;
        };
        "release.Metadata": {
            /** @description Annotations are additional mappings uninterpreted by Helm,
             *     made available for inspection by other applications. */
            annotations?: {
                [key: string]: string;
            };
            /** @description The API Version of this chart. Required. */
            apiVersion?: string;
            /** @description The version of the application enclosed inside of this chart. */
            appVersion?: string;
            /** @description The condition to check to enable chart */
            condition?: string;
            /** @description Dependencies are a list of dependencies for a chart. */
            dependencies?: components["schemas"]["release.Dependency"][];
            /** @description Whether or not this chart is deprecated */
            deprecated?: boolean;
            /** @description A one-sentence description of the chart */
            description?: string;
            /** @description The URL to a relevant project page, git repo, or contact person */
            home?: string;
            /** @description The URL to an icon file. */
            icon?: string;
            /** @description A list of string keywords */
            keywords?: string[];
            /** @description KubeVersion is a SemVer constraint specifying the version of Kubernetes required. */
            kubeVersion?: string;
            /** @description A list of name and URL/email address combinations for the maintainer(s) */
            maintainers?: components["schemas"]["release.Maintainer"][];
            /** @description The name of the chart. Required. */
            name?: string;
            /** @description Source is the URL to the source code of this chart */
            sources?: string[];
            /** @description The tags to check to enable chart */
            tags?: string;
            /** @description Specifies the chart type: application or library */
            type?: string;
            /** @description A SemVer 2 conformant version string of the chart. Required. */
            version?: string;
        };
        "release.Release": {
            chart?: components["schemas"]["release.Chart"];
            /** @description Config is the set of extra Values added to the chart.
             *     These values override the default values inside of the chart. */
            config?: {
                [key: string]: unknown;
            };
            /** @description Hooks are all of the hooks declared for this release. */
            hooks?: components["schemas"]["release.Hook"][];
            /** @description Manifest is the string representation of the rendered template. */
            manifest?: string;
            /** @description Name is the name of the release */
            name?: string;
            /** @description Namespace is the kubernetes namespace of the release. */
            namespace?: string;
            /** @description Version is an int which represents the revision of the release. */
            version?: number;
        };
        "release.ReleaseElement": {
            app_version?: string;
            chart?: string;
            name?: string;
            namespace?: string;
            revision?: string;
            status?: string;
            updated?: string;
        };
        "resource.Quantity": {
            Format?: string;
        };
        "resourcecontrols.resourceControlCreatePayload": {
            /**
             * @description Permit access to resource only to admins
             * @example true
             */
            administratorsOnly?: boolean;
            /**
             * @description Permit access to the associated resource to any user
             * @example true
             */
            public?: boolean;
            /** @example 617c5f22bb9b023d6daab7cba43a57576f83492867bc767d1c59416b065e5f08 */
            resourceID: string;
            /**
             * @description List of Docker resources that will inherit this access control
             * @example [
             *       "617c5f22bb9b023d6daab7cba43a57576f83492867bc767d1c59416b065e5f08"
             *     ]
             */
            subResourceIDs?: string[];
            /**
             * @description List of team identifiers with access to the associated resource
             * @example [
             *       56,
             *       7
             *     ]
             */
            teams?: number[];
            /**
             * @description Type of Resource. Valid values are: 1 - container, 2 - service
             *     3 - volume, 4 - network, 5 - secret, 6 - stack, 7 - config, 8 - custom template, 9 - azure-container-group
             * @example 1
             * @enum {integer}
             */
            type: 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9;
            /**
             * @description List of user identifiers with access to the associated resource
             * @example [
             *       1,
             *       4
             *     ]
             */
            users?: number[];
        };
        "resourcecontrols.resourceControlUpdatePayload": {
            /**
             * @description Permit access to resource only to admins
             * @example true
             */
            administratorsOnly?: boolean;
            /**
             * @description Permit access to the associated resource to any user
             * @example true
             */
            public?: boolean;
            /**
             * @description List of team identifiers with access to the associated resource
             * @example [
             *       7
             *     ]
             */
            teams?: number[];
            /**
             * @description List of user identifiers with access to the associated resource
             * @example [
             *       4
             *     ]
             */
            users?: number[];
        };
        "settings.publicSettingsResponse": {
            /**
             * @description Active authentication method for the Portainer instance. Valid values are: 1 for internal, 2 for LDAP, or 3 for oauth
             * @example 1
             */
            AuthenticationMethod?: number;
            /**
             * @description Whether edge compute features are enabled
             * @example true
             */
            EnableEdgeComputeFeatures?: boolean;
            /**
             * @description Whether telemetry is enabled
             * @example true
             */
            EnableTelemetry?: boolean;
            /** @description Supported feature flags */
            Features?: {
                [key: string]: boolean;
            };
            GlobalDeploymentOptions?: components["schemas"]["portainer.GlobalDeploymentOptions"];
            /** @example false */
            IsDockerDesktopExtension?: boolean;
            /**
             * @description URL to a logo that will be displayed on the login page as well as on top of the sidebar. Will use default Portainer logo when value is empty string
             * @example https://mycompany.mydomain.tld/logo.png
             */
            LogoURL?: string;
            /**
             * @description The URL used for oauth login
             * @example https://gitlab.com/oauth
             */
            OAuthLoginURI?: string;
            /**
             * @description The URL used for oauth logout
             * @example https://gitlab.com/oauth/logout
             */
            OAuthLogoutURI?: string;
            /**
             * @description The minimum required length for a password of any user when using internal auth mode
             * @example 1
             */
            RequiredPasswordLength?: number;
            /**
             * @description Whether team sync is enabled
             * @example true
             */
            TeamSync?: boolean;
            edge?: {
                /**
                 * @description The command list interval for edge agent - used in edge async mode [seconds]
                 * @example 60
                 */
                CommandInterval?: number;
                /**
                 * @description The ping interval for edge agent - used in edge async mode [seconds]
                 * @example 60
                 */
                PingInterval?: number;
                /**
                 * @description The snapshot interval for edge agent - used in edge async mode [seconds]
                 * @example 60
                 */
                SnapshotInterval?: number;
                /**
                 * @description The check in interval for edge agent (in seconds) - used in non async mode [seconds]
                 * @example 60
                 */
                checkinInterval?: number;
            };
            /** @description Whether AMT is enabled */
            isAMTEnabled?: boolean;
            /**
             * @description The expiry of a Kubeconfig
             * @default 0
             * @example 24h
             */
            kubeconfigExpiry: string;
        };
        "settings.settingsUpdatePayload": {
            /** @description EdgePortainerURL is the URL that is exposed to edge agents */
            EdgePortainerURL?: string;
            /**
             * @description Active authentication method for the Portainer instance. Valid values are: 1 for internal, 2 for LDAP, or 3 for oauth
             * @example 1
             */
            authenticationMethod?: number;
            /** @description A list of label name & value that will be used to hide containers when querying containers */
            blackListedLabels?: components["schemas"]["portainer.Pair"][];
            /** @example 5 */
            edgeAgentCheckinInterval?: number;
            /**
             * @description Whether edge compute features are enabled
             * @example true
             */
            enableEdgeComputeFeatures?: boolean;
            /**
             * @description Whether telemetry is enabled
             * @example false
             */
            enableTelemetry?: boolean;
            /**
             * @description EnforceEdgeID makes Portainer store the Edge ID instead of accepting anyone
             * @example false
             */
            enforceEdgeID?: boolean;
            globalDeploymentOptions?: components["schemas"]["portainer.GlobalDeploymentOptions"];
            /**
             * @description Helm repository URL
             * @example https://kubernetes.github.io/ingress-nginx
             */
            helmRepositoryURL?: string;
            internalAuthSettings?: components["schemas"]["portainer.InternalAuthSettings"];
            /**
             * @description The expiry of a Kubeconfig
             * @default 0
             * @example 24h
             */
            kubeconfigExpiry: string;
            /**
             * @description Kubectl Shell Image
             * @example portainer/kubectl-shell:latest
             */
            kubectlShellImage?: string;
            ldapsettings?: components["schemas"]["portainer.LDAPSettings"];
            /**
             * @description URL to a logo that will be displayed on the login page as well as on top of the sidebar. Will use default Portainer logo when value is empty string
             * @example https://mycompany.mydomain.tld/logo.png
             */
            logoURL?: string;
            oauthSettings?: components["schemas"]["portainer.OAuthSettings"];
            /**
             * @description The interval in which environment(endpoint) snapshots are created
             * @example 5m
             */
            snapshotInterval?: string;
            /**
             * @description URL to the templates that will be displayed in the UI when navigating to App Templates
             * @example https://raw.githubusercontent.com/portainer/templates/master/templates.json
             */
            templatesURL?: string;
            /**
             * @description TrustOnFirstConnect makes Portainer accepting edge agent connection by default
             * @example false
             */
            trustOnFirstConnect?: boolean;
            /**
             * @description The duration of a user session
             * @example 5m
             */
            userSessionTimeout?: string;
        };
        "ssl.sslUpdatePayload": {
            /** @description SSL Certificates */
            cert?: string;
            httpenabled?: boolean;
            key?: string;
        };
        "stacks.composeStackFromFileContentPayload": {
            /** @description A list of environment variables used during stack deployment */
            env?: components["schemas"]["portainer.Pair"][];
            /**
             * @description Whether the stack is from a app template
             * @example false
             */
            fromAppTemplate?: boolean;
            /**
             * @description Name of the stack
             * @example myStack
             */
            name: string;
            /**
             * @description Content of the Stack file
             * @example version: 3
             *      services:
             *      web:
             *      image:nginx
             */
            stackFileContent: string;
        };
        "stacks.composeStackFromGitRepositoryPayload": {
            /**
             * @description Applicable when deploying with multiple stack files
             * @example [
             *       "[nz.compose.yml",
             *       " uat.compose.yml]"
             *     ]
             */
            additionalFiles?: string[];
            autoUpdate?: components["schemas"]["portainer.AutoUpdateSettings"];
            /**
             * @description Path to the Stack file inside the Git repository
             * @default docker-compose.yml
             * @example docker-compose.yml
             */
            composeFile: string;
            /** @description A list of environment variables used during stack deployment */
            env?: components["schemas"]["portainer.Pair"][];
            /**
             * @description Whether the stack is from a app template
             * @example false
             */
            fromAppTemplate?: boolean;
            /**
             * @description Name of the stack
             * @example myStack
             */
            name: string;
            /**
             * @description Use basic authentication to clone the Git repository
             * @example true
             */
            repositoryAuthentication?: boolean;
            /**
             * @description Password used in basic authentication. Required when RepositoryAuthentication is true.
             * @example myGitPassword
             */
            repositoryPassword?: string;
            /**
             * @description Reference name of a Git repository hosting the Stack file
             * @example refs/heads/master
             */
            repositoryReferenceName?: string;
            /**
             * @description URL of a Git repository hosting the Stack file
             * @example https://github.com/openfaas/faas
             */
            repositoryURL: string;
            /**
             * @description Username used in basic authentication. Required when RepositoryAuthentication is true.
             * @example myGitUsername
             */
            repositoryUsername?: string;
            /**
             * @description TLSSkipVerify skips SSL verification when cloning the Git repository
             * @example false
             */
            tlsskipVerify?: boolean;
        };
        "stacks.kubernetesGitDeploymentPayload": {
            additionalFiles?: string[];
            autoUpdate?: components["schemas"]["portainer.AutoUpdateSettings"];
            composeFormat?: boolean;
            manifestFile?: string;
            namespace?: string;
            repositoryAuthentication?: boolean;
            repositoryPassword?: string;
            repositoryReferenceName?: string;
            repositoryURL?: string;
            repositoryUsername?: string;
            stackName?: string;
            /**
             * @description TLSSkipVerify skips SSL verification when cloning the Git repository
             * @example false
             */
            tlsskipVerify?: boolean;
        };
        "stacks.kubernetesManifestURLDeploymentPayload": {
            composeFormat?: boolean;
            manifestURL?: string;
            namespace?: string;
            stackName?: string;
        };
        "stacks.kubernetesStringDeploymentPayload": {
            composeFormat?: boolean;
            /**
             * @description Whether the stack is from a app template
             * @example false
             */
            fromAppTemplate?: boolean;
            namespace?: string;
            stackFileContent?: string;
            stackName?: string;
        };
        "stacks.stackFileResponse": {
            /**
             * @description Content of the Stack file
             * @example version: 3
             *      services:
             *      web:
             *      image:nginx
             */
            StackFileContent?: string;
        };
        "stacks.stackGitRedployPayload": {
            env?: components["schemas"]["portainer.Pair"][];
            prune?: boolean;
            /**
             * @description Force a pulling to current image with the original tag though the image is already the latest
             * @example false
             */
            pullImage?: boolean;
            repositoryAuthentication?: boolean;
            repositoryPassword?: string;
            repositoryReferenceName?: string;
            repositoryUsername?: string;
            stackName?: string;
        };
        "stacks.stackGitUpdatePayload": {
            autoUpdate?: components["schemas"]["portainer.AutoUpdateSettings"];
            env?: components["schemas"]["portainer.Pair"][];
            prune?: boolean;
            repositoryAuthentication?: boolean;
            repositoryPassword?: string;
            repositoryReferenceName?: string;
            repositoryUsername?: string;
            tlsskipVerify?: boolean;
        };
        "stacks.stackMigratePayload": {
            /**
             * @description Environment(Endpoint) identifier of the target environment(endpoint) where the stack will be relocated
             * @example 2
             */
            endpointID: number;
            /**
             * @description If provided will rename the migrated stack
             * @example new-stack
             */
            name?: string;
            /**
             * @description Swarm cluster identifier, must match the identifier of the cluster where the stack will be relocated
             * @example jpofkc0i9uo9wtx1zesuk649w
             */
            swarmID?: string;
        };
        "stacks.swarmStackFromFileContentPayload": {
            /** @description A list of environment variables used during stack deployment */
            env?: components["schemas"]["portainer.Pair"][];
            /**
             * @description Whether the stack is from a app template
             * @example false
             */
            fromAppTemplate?: boolean;
            /**
             * @description Name of the stack
             * @example myStack
             */
            name: string;
            /**
             * @description Content of the Stack file
             * @example version: 3
             *      services:
             *      web:
             *      image:nginx
             */
            stackFileContent: string;
            /**
             * @description Swarm cluster identifier
             * @example jpofkc0i9uo9wtx1zesuk649w
             */
            swarmID: string;
        };
        "stacks.swarmStackFromGitRepositoryPayload": {
            /**
             * @description Applicable when deploying with multiple stack files
             * @example [
             *       "[nz.compose.yml",
             *       " uat.compose.yml]"
             *     ]
             */
            additionalFiles?: string[];
            autoUpdate?: components["schemas"]["portainer.AutoUpdateSettings"];
            /**
             * @description Path to the Stack file inside the Git repository
             * @default docker-compose.yml
             * @example docker-compose.yml
             */
            composeFile: string;
            /** @description A list of environment variables used during stack deployment */
            env?: components["schemas"]["portainer.Pair"][];
            /**
             * @description Whether the stack is from a app template
             * @example false
             */
            fromAppTemplate?: boolean;
            /**
             * @description Name of the stack
             * @example myStack
             */
            name: string;
            /**
             * @description Use basic authentication to clone the Git repository
             * @example true
             */
            repositoryAuthentication?: boolean;
            /**
             * @description Password used in basic authentication. Required when RepositoryAuthentication is true.
             * @example myGitPassword
             */
            repositoryPassword?: string;
            /**
             * @description Reference name of a Git repository hosting the Stack file
             * @example refs/heads/master
             */
            repositoryReferenceName?: string;
            /**
             * @description URL of a Git repository hosting the Stack file
             * @example https://github.com/openfaas/faas
             */
            repositoryURL: string;
            /**
             * @description Username used in basic authentication. Required when RepositoryAuthentication is true.
             * @example myGitUsername
             */
            repositoryUsername?: string;
            /**
             * @description Swarm cluster identifier
             * @example jpofkc0i9uo9wtx1zesuk649w
             */
            swarmID: string;
            /**
             * @description TLSSkipVerify skips SSL verification when cloning the Git repository
             * @example false
             */
            tlsskipVerify?: boolean;
        };
        "stacks.updateSwarmStackPayload": {
            /** @description A list of environment(endpoint) variables used during stack deployment */
            env?: components["schemas"]["portainer.Pair"][];
            /**
             * @description Prune services that are no longer referenced (only available for Swarm stacks)
             * @example true
             */
            prune?: boolean;
            /**
             * @description Force a pulling to current image with the original tag though the image is already the latest
             * @example false
             */
            pullImage?: boolean;
            /**
             * @description New content of the Stack file
             * @example version: 3
             *      services:
             *      web:
             *      image:nginx
             */
            stackFileContent?: string;
        };
        "swarm.ServiceUpdateResponse": {
            /** @description Optional warning messages */
            Warnings?: string[];
        };
        "system.nodesCountResponse": {
            nodes?: number;
        };
        "system.status": {
            /**
             * @description Portainer API version
             * @example 2.0.0
             */
            Version?: string;
            /**
             * @description Server Instance ID
             * @example 299ab403-70a8-4c05-92f7-bf7a994d50df
             */
            instanceID?: string;
        };
        "system.systemInfoResponse": {
            agents?: number;
            edgeAgents?: number;
            platform?: string;
        };
        "system.versionResponse": {
            /**
             * @description The latest version available
             * @example 2.0.0
             */
            LatestVersion?: string;
            /** @example CE/EE */
            ServerEdition?: string;
            /**
             * @description Whether portainer has an update available
             * @example false
             */
            UpdateAvailable?: boolean;
            /** @example STS/LTS */
            VersionSupport?: string;
            build?: components["schemas"]["build.BuildInfo"];
            databaseVersion?: string;
            dependencies?: components["schemas"]["build.DependenciesInfo"];
            runtime?: components["schemas"]["build.RuntimeInfo"];
            serverVersion?: string;
            ServerVersion?: string;
        };
        "tags.tagCreatePayload": {
            /** @example org/acme */
            name: string;
        };
        "teammemberships.teamMembershipCreatePayload": {
            /**
             * @description Role for the user inside the team (1 for leader and 2 for regular member)
             * @example 1
             * @enum {integer}
             */
            role: 1 | 2;
            /**
             * @description Team identifier
             * @example 1
             */
            teamID: number;
            /**
             * @description User identifier
             * @example 1
             */
            userID: number;
        };
        "teammemberships.teamMembershipUpdatePayload": {
            /**
             * @description Role for the user inside the team (1 for leader and 2 for regular member)
             * @example 1
             * @enum {integer}
             */
            role: 1 | 2;
            /**
             * @description Team identifier
             * @example 1
             */
            teamID: number;
            /**
             * @description User identifier
             * @example 1
             */
            userID: number;
        };
        "teams.teamCreatePayload": {
            /**
             * @description Name
             * @example developers
             */
            name: string;
            /**
             * @description TeamLeaders
             * @example [
             *       3,
             *       5
             *     ]
             */
            teamLeaders?: number[];
        };
        "teams.teamUpdatePayload": {
            /**
             * @description Name
             * @example developers
             */
            name?: string;
        };
        "templates.fileResponse": {
            /**
             * @description The requested file content
             * @example version:2
             */
            fileContent?: string;
        };
        "templates.listResponse": {
            templates?: components["schemas"]["portainer.Template"][];
            version?: string;
        };
        "users.accessTokenResponse": {
            apiKey?: components["schemas"]["portainer.APIKey"];
            rawAPIKey?: string;
        };
        "users.addHelmRepoUrlPayload": {
            url?: string;
        };
        "users.adminInitPayload": {
            /**
             * @description Password for the admin user
             * @example admin-password
             */
            password: string;
            /**
             * @description Username for the admin user
             * @example admin
             */
            username: string;
        };
        "users.helmUserRepositoryResponse": {
            GlobalRepository?: string;
            UserRepositories?: components["schemas"]["portainer.HelmUserRepository"][];
        };
        "users.themePayload": {
            /**
             * @description Color represents the color theme of the UI
             * @example dark
             * @enum {string}
             */
            color?: "dark" | "light" | "highcontrast" | "auto";
        };
        "users.userAccessTokenCreatePayload": {
            /** @example github-api-key */
            description: string;
            /** @example password */
            password: string;
        };
        "users.userCreatePayload": {
            /** @example cg9Wgky3 */
            password: string;
            /**
             * @description User role (1 for administrator account and 2 for regular account)
             * @example 2
             * @enum {integer}
             */
            role: 1 | 2;
            /** @example bob */
            username: string;
        };
        "users.userUpdatePasswordPayload": {
            /**
             * @description New Password
             * @example new_passwd
             */
            newPassword: string;
            /**
             * @description Current Password
             * @example passwd
             */
            password: string;
        };
        "users.userUpdatePayload": {
            /** @example asfj2emv */
            newPassword: string;
            /** @example cg9Wgky3 */
            password: string;
            /**
             * @description User role (1 for administrator account and 2 for regular account)
             * @example 2
             * @enum {integer}
             */
            role: 1 | 2;
            theme?: components["schemas"]["users.themePayload"];
            /** @example true */
            useCache: boolean;
            /** @example bob */
            username: string;
        };
        "v1.CSIPersistentVolumeSource": {
            controllerExpandSecretRef?: components["schemas"]["v1.SecretReference"];
            controllerPublishSecretRef?: components["schemas"]["v1.SecretReference"];
            /** @description driver is the name of the driver to use for this volume.
             *     Required. */
            driver?: string;
            /** @description fsType to mount. Must be a filesystem type supported by the host operating system.
             *     Ex. "ext4", "xfs", "ntfs".
             *     +optional */
            fsType?: string;
            nodeExpandSecretRef?: components["schemas"]["v1.SecretReference"];
            nodePublishSecretRef?: components["schemas"]["v1.SecretReference"];
            nodeStageSecretRef?: components["schemas"]["v1.SecretReference"];
            /** @description readOnly value to pass to ControllerPublishVolumeRequest.
             *     Defaults to false (read/write).
             *     +optional */
            readOnly?: boolean;
            /** @description volumeAttributes of the volume to publish.
             *     +optional */
            volumeAttributes?: {
                [key: string]: string;
            };
            /** @description volumeHandle is the unique volume name returned by the CSI volume
             *     plugins CreateVolume to refer to the volume on all subsequent calls.
             *     Required. */
            volumeHandle?: string;
        };
        "v1.Capabilities": {
            /** @description Added capabilities
             *     +optional */
            add?: string[];
            /** @description Removed capabilities
             *     +optional */
            drop?: string[];
        };
        "v1.ClientIPConfig": {
            /** @description timeoutSeconds specifies the seconds of ClientIP type session sticky time.
             *     The value must be >0 && <=86400(for 1 day) if ServiceAffinity == "ClientIP".
             *     Default value is 10800(for 3 hours).
             *     +optional */
            timeoutSeconds?: number;
        };
        "v1.Condition": {
            /** @description lastTransitionTime is the last time the condition transitioned from one status to another.
             *     This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
             *     +required
             *     +kubebuilder:validation:Required
             *     +kubebuilder:validation:Type=string
             *     +kubebuilder:validation:Format=date-time */
            lastTransitionTime?: string;
            /** @description message is a human readable message indicating details about the transition.
             *     This may be an empty string.
             *     +required
             *     +kubebuilder:validation:Required
             *     +kubebuilder:validation:MaxLength=32768 */
            message?: string;
            /** @description observedGeneration represents the .metadata.generation that the condition was set based upon.
             *     For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
             *     with respect to the current state of the instance.
             *     +optional
             *     +kubebuilder:validation:Minimum=0 */
            observedGeneration?: number;
            /** @description reason contains a programmatic identifier indicating the reason for the condition's last transition.
             *     Producers of specific condition types may define expected values and meanings for this field,
             *     and whether the values are considered a guaranteed API.
             *     The value should be a CamelCase string.
             *     This field may not be empty.
             *     +required
             *     +kubebuilder:validation:Required
             *     +kubebuilder:validation:MaxLength=1024
             *     +kubebuilder:validation:MinLength=1
             *     +kubebuilder:validation:Pattern=`^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$` */
            reason?: string;
            /** @description status of the condition, one of True, False, Unknown.
             *     +required
             *     +kubebuilder:validation:Required
             *     +kubebuilder:validation:Enum=True;False;Unknown */
            status?: string;
            /** @description type of condition in CamelCase or in foo.example.com/CamelCase.
             *     ---
             *     Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
             *     useful (see .node.status.conditions), the ability to deconflict is important.
             *     The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
             *     +required
             *     +kubebuilder:validation:Required
             *     +kubebuilder:validation:Pattern=`^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*\/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$`
             *     +kubebuilder:validation:MaxLength=316 */
            type?: string;
        };
        "v1.ConfigMapEnvSource": {
            /** @description Name of the referent.
             *     More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             *     TODO: Add other useful fields. apiVersion, kind, uid?
             *     +optional */
            name?: string;
            /** @description Specify whether the ConfigMap must be defined
             *     +optional */
            optional?: boolean;
        };
        "v1.ConfigMapKeySelector": {
            /** @description The key to select. */
            key?: string;
            /** @description Name of the referent.
             *     More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             *     TODO: Add other useful fields. apiVersion, kind, uid?
             *     +optional */
            name?: string;
            /** @description Specify whether the ConfigMap or its key must be defined
             *     +optional */
            optional?: boolean;
        };
        "v1.Container": {
            /** @description Arguments to the entrypoint.
             *     The container image's CMD is used if this is not provided.
             *     Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
             *     cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
             *     to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
             *     produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
             *     of whether the variable exists or not. Cannot be updated.
             *     More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
             *     +optional */
            args?: string[];
            /** @description Entrypoint array. Not executed within a shell.
             *     The container image's ENTRYPOINT is used if this is not provided.
             *     Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
             *     cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
             *     to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
             *     produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
             *     of whether the variable exists or not. Cannot be updated.
             *     More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
             *     +optional */
            command?: string[];
            /** @description List of environment variables to set in the container.
             *     Cannot be updated.
             *     +optional
             *     +patchMergeKey=name
             *     +patchStrategy=merge */
            env?: components["schemas"]["v1.EnvVar"][];
            /** @description List of sources to populate environment variables in the container.
             *     The keys defined within a source must be a C_IDENTIFIER. All invalid keys
             *     will be reported as an event when the container is starting. When a key exists in multiple
             *     sources, the value associated with the last source will take precedence.
             *     Values defined by an Env with a duplicate key will take precedence.
             *     Cannot be updated.
             *     +optional */
            envFrom?: components["schemas"]["v1.EnvFromSource"][];
            /** @description Container image name.
             *     More info: https://kubernetes.io/docs/concepts/containers/images
             *     This field is optional to allow higher level config management to default or override
             *     container images in workload controllers like Deployments and StatefulSets.
             *     +optional */
            image?: string;
            /** @description Image pull policy.
             *     One of Always, Never, IfNotPresent.
             *     Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
             *     Cannot be updated.
             *     More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
             *     +optional */
            imagePullPolicy?: string;
            lifecycle?: components["schemas"]["v1.Lifecycle"];
            livenessProbe?: components["schemas"]["v1.Probe"];
            /** @description Name of the container specified as a DNS_LABEL.
             *     Each container in a pod must have a unique name (DNS_LABEL).
             *     Cannot be updated. */
            name?: string;
            /** @description List of ports to expose from the container. Not specifying a port here
             *     DOES NOT prevent that port from being exposed. Any port which is
             *     listening on the default "0.0.0.0" address inside a container will be
             *     accessible from the network.
             *     Modifying this array with strategic merge patch may corrupt the data.
             *     For more information See https://github.com/kubernetes/kubernetes/issues/108255.
             *     Cannot be updated.
             *     +optional
             *     +patchMergeKey=containerPort
             *     +patchStrategy=merge
             *     +listType=map
             *     +listMapKey=containerPort
             *     +listMapKey=protocol */
            ports?: components["schemas"]["v1.ContainerPort"][];
            readinessProbe?: components["schemas"]["v1.Probe"];
            /** @description Resources resize policy for the container.
             *     +featureGate=InPlacePodVerticalScaling
             *     +optional
             *     +listType=atomic */
            resizePolicy?: components["schemas"]["v1.ContainerResizePolicy"][];
            resources?: components["schemas"]["v1.ResourceRequirements"];
            /** @description RestartPolicy defines the restart behavior of individual containers in a pod.
             *     This field may only be set for init containers, and the only allowed value is "Always".
             *     For non-init containers or when this field is not specified,
             *     the restart behavior is defined by the Pod's restart policy and the container type.
             *     Setting the RestartPolicy as "Always" for the init container will have the following effect:
             *     this init container will be continually restarted on
             *     exit until all regular containers have terminated. Once all regular
             *     containers have completed, all init containers with restartPolicy "Always"
             *     will be shut down. This lifecycle differs from normal init containers and
             *     is often referred to as a "sidecar" container. Although this init
             *     container still starts in the init container sequence, it does not wait
             *     for the container to complete before proceeding to the next init
             *     container. Instead, the next init container starts immediately after this
             *     init container is started, or after any startupProbe has successfully
             *     completed.
             *     +featureGate=SidecarContainers
             *     +optional */
            restartPolicy?: string;
            securityContext?: components["schemas"]["v1.SecurityContext"];
            startupProbe?: components["schemas"]["v1.Probe"];
            /** @description Whether this container should allocate a buffer for stdin in the container runtime. If this
             *     is not set, reads from stdin in the container will always result in EOF.
             *     Default is false.
             *     +optional */
            stdin?: boolean;
            /** @description Whether the container runtime should close the stdin channel after it has been opened by
             *     a single attach. When stdin is true the stdin stream will remain open across multiple attach
             *     sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
             *     first client attaches to stdin, and then remains open and accepts data until the client disconnects,
             *     at which time stdin is closed and remains closed until the container is restarted. If this
             *     flag is false, a container processes that reads from stdin will never receive an EOF.
             *     Default is false
             *     +optional */
            stdinOnce?: boolean;
            /** @description Optional: Path at which the file to which the container's termination message
             *     will be written is mounted into the container's filesystem.
             *     Message written is intended to be brief final status, such as an assertion failure message.
             *     Will be truncated by the node if greater than 4096 bytes. The total message length across
             *     all containers will be limited to 12kb.
             *     Defaults to /dev/termination-log.
             *     Cannot be updated.
             *     +optional */
            terminationMessagePath?: string;
            /** @description Indicate how the termination message should be populated. File will use the contents of
             *     terminationMessagePath to populate the container status message on both success and failure.
             *     FallbackToLogsOnError will use the last chunk of container log output if the termination
             *     message file is empty and the container exited with an error.
             *     The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
             *     Defaults to File.
             *     Cannot be updated.
             *     +optional */
            terminationMessagePolicy?: string;
            /** @description Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
             *     Default is false.
             *     +optional */
            tty?: boolean;
            /** @description volumeDevices is the list of block devices to be used by the container.
             *     +patchMergeKey=devicePath
             *     +patchStrategy=merge
             *     +optional */
            volumeDevices?: components["schemas"]["v1.VolumeDevice"][];
            /** @description Pod volumes to mount into the container's filesystem.
             *     Cannot be updated.
             *     +optional
             *     +patchMergeKey=mountPath
             *     +patchStrategy=merge */
            volumeMounts?: components["schemas"]["v1.VolumeMount"][];
            /** @description Container's working directory.
             *     If not specified, the container runtime's default will be used, which
             *     might be configured in the container image.
             *     Cannot be updated.
             *     +optional */
            workingDir?: string;
        };
        "v1.ContainerPort": {
            /** @description Number of port to expose on the pod's IP address.
             *     This must be a valid port number, 0 < x < 65536. */
            containerPort?: number;
            /** @description What host IP to bind the external port to.
             *     +optional */
            hostIP?: string;
            /** @description Number of port to expose on the host.
             *     If specified, this must be a valid port number, 0 < x < 65536.
             *     If HostNetwork is specified, this must match ContainerPort.
             *     Most containers do not need this.
             *     +optional */
            hostPort?: number;
            /** @description If specified, this must be an IANA_SVC_NAME and unique within the pod. Each
             *     named port in a pod must have a unique name. Name for the port that can be
             *     referred to by services.
             *     +optional */
            name?: string;
            /** @description Protocol for port. Must be UDP, TCP, or SCTP.
             *     Defaults to "TCP".
             *     +optional
             *     +default="TCP" */
            protocol?: string;
        };
        "v1.ContainerResizePolicy": {
            /** @description Name of the resource to which this resource resize policy applies.
             *     Supported values: cpu, memory. */
            resourceName?: string;
            /** @description Restart policy to apply when specified resource is resized.
             *     If not specified, it defaults to NotRequired. */
            restartPolicy?: string;
        };
        "v1.Duration": {
            "time.Duration"?: number;
        };
        "v1.EnvFromSource": {
            configMapRef?: components["schemas"]["v1.ConfigMapEnvSource"];
            /** @description An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
             *     +optional */
            prefix?: string;
            secretRef?: components["schemas"]["v1.SecretEnvSource"];
        };
        "v1.EnvVar": {
            /** @description Name of the environment variable. Must be a C_IDENTIFIER. */
            name?: string;
            /** @description Variable references $(VAR_NAME) are expanded
             *     using the previously defined environment variables in the container and
             *     any service environment variables. If a variable cannot be resolved,
             *     the reference in the input string will be unchanged. Double $$ are reduced
             *     to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
             *     "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
             *     Escaped references will never be expanded, regardless of whether the variable
             *     exists or not.
             *     Defaults to "".
             *     +optional */
            value?: string;
            valueFrom?: components["schemas"]["v1.EnvVarSource"];
        };
        "v1.EnvVarSource": {
            configMapKeyRef?: components["schemas"]["v1.ConfigMapKeySelector"];
            fieldRef?: components["schemas"]["v1.ObjectFieldSelector"];
            resourceFieldRef?: components["schemas"]["v1.ResourceFieldSelector"];
            secretKeyRef?: components["schemas"]["v1.SecretKeySelector"];
        };
        "v1.ExecAction": {
            /** @description Command is the command line to execute inside the container, the working directory for the
             *     command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
             *     not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
             *     a shell, you need to explicitly call out to that shell.
             *     Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
             *     +optional */
            command?: string[];
        };
        "v1.FieldsV1": Record<string, never>;
        "v1.GRPCAction": {
            /** @description Port number of the gRPC service. Number must be in the range 1 to 65535. */
            port?: number;
            /** @description Service is the name of the service to place in the gRPC HealthCheckRequest
             *     (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
             *
             *     If this is not specified, the default behavior is defined by gRPC.
             *     +optional
             *     +default="" */
            service?: string;
        };
        "v1.HTTPGetAction": {
            /** @description Host name to connect to, defaults to the pod IP. You probably want to set
             *     "Host" in httpHeaders instead.
             *     +optional */
            host?: string;
            /** @description Custom headers to set in the request. HTTP allows repeated headers.
             *     +optional */
            httpHeaders?: components["schemas"]["v1.HTTPHeader"][];
            /** @description Path to access on the HTTP server.
             *     +optional */
            path?: string;
            port?: components["schemas"]["intstr.IntOrString"];
            /** @description Scheme to use for connecting to the host.
             *     Defaults to HTTP.
             *     +optional */
            scheme?: string;
        };
        "v1.HTTPHeader": {
            /** @description The header field name.
             *     This will be canonicalized upon output, so case-variant names will be understood as the same header. */
            name?: string;
            /** @description The header field value */
            value?: string;
        };
        "v1.LabelSelector": {
            /** @description matchExpressions is a list of label selector requirements. The requirements are ANDed.
             *     +optional */
            matchExpressions?: components["schemas"]["v1.LabelSelectorRequirement"][];
            /** @description matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             *     map is equivalent to an element of matchExpressions, whose key field is "key", the
             *     operator is "In", and the values array contains only "value". The requirements are ANDed.
             *     +optional */
            matchLabels?: {
                [key: string]: string;
            };
        };
        "v1.LabelSelectorRequirement": {
            /** @description key is the label key that the selector applies to. */
            key?: string;
            /** @description operator represents a key's relationship to a set of values.
             *     Valid operators are In, NotIn, Exists and DoesNotExist. */
            operator?: string;
            /** @description values is an array of string values. If the operator is In or NotIn,
             *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
             *     the values array must be empty. This array is replaced during a strategic
             *     merge patch.
             *     +optional */
            values?: string[];
        };
        "v1.Lifecycle": {
            postStart?: components["schemas"]["v1.LifecycleHandler"];
            preStop?: components["schemas"]["v1.LifecycleHandler"];
        };
        "v1.LifecycleHandler": {
            exec?: components["schemas"]["v1.ExecAction"];
            httpGet?: components["schemas"]["v1.HTTPGetAction"];
            sleep?: components["schemas"]["v1.SleepAction"];
            tcpSocket?: components["schemas"]["v1.TCPSocketAction"];
        };
        "v1.LoadBalancerIngress": {
            /** @description Hostname is set for load-balancer ingress points that are DNS based
             *     (typically AWS load-balancers)
             *     +optional */
            hostname?: string;
            /** @description IP is set for load-balancer ingress points that are IP based
             *     (typically GCE or OpenStack load-balancers)
             *     +optional */
            ip?: string;
            /** @description IPMode specifies how the load-balancer IP behaves, and may only be specified when the ip field is specified.
             *     Setting this to "VIP" indicates that traffic is delivered to the node with
             *     the destination set to the load-balancer's IP and port.
             *     Setting this to "Proxy" indicates that traffic is delivered to the node or pod with
             *     the destination set to the node's IP and node port or the pod's IP and port.
             *     Service implementations may use this information to adjust traffic routing.
             *     +optional */
            ipMode?: string;
            /** @description Ports is a list of records of service ports
             *     If used, every port defined in the service should have an entry in it
             *     +listType=atomic
             *     +optional */
            ports?: components["schemas"]["v1.PortStatus"][];
        };
        "v1.LoadBalancerStatus": {
            /** @description Ingress is a list containing ingress points for the load-balancer.
             *     Traffic intended for the service should be sent to these ingress points.
             *     +optional */
            ingress?: components["schemas"]["v1.LoadBalancerIngress"][];
        };
        "v1.ManagedFieldsEntry": {
            /** @description APIVersion defines the version of this resource that this field set
             *     applies to. The format is "group/version" just like the top-level
             *     APIVersion field. It is necessary to track the version of a field
             *     set because it cannot be automatically converted. */
            apiVersion?: string;
            /** @description FieldsType is the discriminator for the different fields format and version.
             *     There is currently only one possible value: "FieldsV1" */
            fieldsType?: string;
            fieldsV1?: components["schemas"]["v1.FieldsV1"];
            /** @description Manager is an identifier of the workflow managing these fields. */
            manager?: string;
            /** @description Operation is the type of operation which lead to this ManagedFieldsEntry being created.
             *     The only valid values for this field are 'Apply' and 'Update'. */
            operation?: string;
            /** @description Subresource is the name of the subresource used to update that object, or
             *     empty string if the object was updated through the main resource. The
             *     value of this field is used to distinguish between managers, even if they
             *     share the same name. For example, a status update will be distinct from a
             *     regular update using the same manager name.
             *     Note that the APIVersion field is not related to the Subresource field and
             *     it always corresponds to the version of the main resource. */
            subresource?: string;
            /** @description Time is the timestamp of when the ManagedFields entry was added. The
             *     timestamp will also be updated if a field is added, the manager
             *     changes any of the owned fields value or removes a field. The
             *     timestamp does not update when a field is removed from the entry
             *     because another manager took it over.
             *     +optional */
            time?: string;
        };
        "v1.NamespaceCondition": {
            /** @description +optional */
            lastTransitionTime?: string;
            /** @description +optional */
            message?: string;
            /** @description +optional */
            reason?: string;
            /** @description Status of the condition, one of True, False, Unknown. */
            status?: string;
            /** @description Type of namespace controller condition. */
            type?: string;
        };
        "v1.NamespaceStatus": {
            /** @description Represents the latest available observations of a namespace's current state.
             *     +optional
             *     +patchMergeKey=type
             *     +patchStrategy=merge */
            conditions?: components["schemas"]["v1.NamespaceCondition"][];
            /** @description Phase is the current lifecycle phase of the namespace.
             *     More info: https://kubernetes.io/docs/tasks/administer-cluster/namespaces/
             *     +optional */
            phase?: string;
        };
        "v1.ObjectFieldSelector": {
            /** @description Version of the schema the FieldPath is written in terms of, defaults to "v1".
             *     +optional */
            apiVersion?: string;
            /** @description Path of the field to select in the specified API version. */
            fieldPath?: string;
        };
        "v1.ObjectReference": {
            /** @description API version of the referent.
             *     +optional */
            apiVersion?: string;
            /** @description If referring to a piece of an object instead of an entire object, this string
             *     should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2].
             *     For example, if the object reference is to a container within a pod, this would take on a value like:
             *     "spec.containers{name}" (where "name" refers to the name of the container that triggered
             *     the event) or if no container name is specified "spec.containers[2]" (container with
             *     index 2 in this pod). This syntax is chosen only to have some well-defined way of
             *     referencing a part of an object.
             *     TODO: this design is not final and this field is subject to change in the future.
             *     +optional */
            fieldPath?: string;
            /** @description Kind of the referent.
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             *     +optional */
            kind?: string;
            /** @description Name of the referent.
             *     More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             *     +optional */
            name?: string;
            /** @description Namespace of the referent.
             *     More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             *     +optional */
            namespace?: string;
            /** @description Specific resourceVersion to which this reference is made, if any.
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             *     +optional */
            resourceVersion?: string;
            /** @description UID of the referent.
             *     More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             *     +optional */
            uid?: string;
        };
        "v1.OwnerReference": {
            /** @description API version of the referent. */
            apiVersion?: string;
            /** @description If true, AND if the owner has the "foregroundDeletion" finalizer, then
             *     the owner cannot be deleted from the key-value store until this
             *     reference is removed.
             *     See https://kubernetes.io/docs/concepts/architecture/garbage-collection/#foreground-deletion
             *     for how the garbage collector interacts with this field and enforces the foreground deletion.
             *     Defaults to false.
             *     To set this field, a user needs "delete" permission of the owner,
             *     otherwise 422 (Unprocessable Entity) will be returned.
             *     +optional */
            blockOwnerDeletion?: boolean;
            /** @description If true, this reference points to the managing controller.
             *     +optional */
            controller?: boolean;
            /** @description Kind of the referent.
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
            kind?: string;
            /** @description Name of the referent.
             *     More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names */
            name?: string;
            /** @description UID of the referent.
             *     More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids */
            uid?: string;
        };
        "v1.PortStatus": {
            /** @description Error is to record the problem with the service port
             *     The format of the error shall comply with the following rules:
             *     - built-in error values shall be specified in this file and those shall use
             *       CamelCase names
             *     - cloud provider specific error values must have names that comply with the
             *       format foo.example.com/CamelCase.
             *     ---
             *     The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
             *     +optional
             *     +kubebuilder:validation:Required
             *     +kubebuilder:validation:Pattern=`^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*\/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$`
             *     +kubebuilder:validation:MaxLength=316 */
            error?: string;
            /** @description Port is the port number of the service port of which status is recorded here */
            port?: number;
            /** @description Protocol is the protocol of the service port of which status is recorded here
             *     The supported values are: "TCP", "UDP", "SCTP" */
            protocol?: string;
        };
        "v1.Probe": {
            exec?: components["schemas"]["v1.ExecAction"];
            /** @description Minimum consecutive failures for the probe to be considered failed after having succeeded.
             *     Defaults to 3. Minimum value is 1.
             *     +optional */
            failureThreshold?: number;
            grpc?: components["schemas"]["v1.GRPCAction"];
            httpGet?: components["schemas"]["v1.HTTPGetAction"];
            /** @description Number of seconds after the container has started before liveness probes are initiated.
             *     More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
             *     +optional */
            initialDelaySeconds?: number;
            /** @description How often (in seconds) to perform the probe.
             *     Default to 10 seconds. Minimum value is 1.
             *     +optional */
            periodSeconds?: number;
            /** @description Minimum consecutive successes for the probe to be considered successful after having failed.
             *     Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
             *     +optional */
            successThreshold?: number;
            tcpSocket?: components["schemas"]["v1.TCPSocketAction"];
            /** @description Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
             *     The grace period is the duration in seconds after the processes running in the pod are sent
             *     a termination signal and the time when the processes are forcibly halted with a kill signal.
             *     Set this value longer than the expected cleanup time for your process.
             *     If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
             *     value overrides the value provided by the pod spec.
             *     Value must be non-negative integer. The value zero indicates stop immediately via
             *     the kill signal (no opportunity to shut down).
             *     This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
             *     Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
             *     +optional */
            terminationGracePeriodSeconds?: number;
            /** @description Number of seconds after which the probe times out.
             *     Defaults to 1 second. Minimum value is 1.
             *     More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
             *     +optional */
            timeoutSeconds?: number;
        };
        "v1.ResourceClaim": {
            /** @description Name must match the name of one entry in pod.spec.resourceClaims of
             *     the Pod where this field is used. It makes that resource available
             *     inside a container. */
            name?: string;
        };
        "v1.ResourceFieldSelector": {
            /** @description Container name: required for volumes, optional for env vars
             *     +optional */
            containerName?: string;
            divisor?: components["schemas"]["resource.Quantity"];
            /** @description Required: resource to select */
            resource?: string;
        };
        "v1.ResourceList": {
            [key: string]: components["schemas"]["resource.Quantity"];
        };
        "v1.ResourceQuota": {
            /** @description Annotations is an unstructured key value map stored with a resource that may be
             *     set by external tools to store and retrieve arbitrary metadata. They are not
             *     queryable and should be preserved when modifying objects.
             *     More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
             *     +optional */
            annotations?: {
                [key: string]: string;
            };
            /** @description APIVersion defines the versioned schema of this representation of an object.
             *     Servers should convert recognized schemas to the latest internal value, and
             *     may reject unrecognized values.
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             *     +optional */
            apiVersion?: string;
            /** @description CreationTimestamp is a timestamp representing the server time when this object was
             *     created. It is not guaranteed to be set in happens-before order across separate operations.
             *     Clients may not set this value. It is represented in RFC3339 form and is in UTC.
             *
             *     Populated by the system.
             *     Read-only.
             *     Null for lists.
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             *     +optional */
            creationTimestamp?: string;
            /** @description Number of seconds allowed for this object to gracefully terminate before
             *     it will be removed from the system. Only set when deletionTimestamp is also set.
             *     May only be shortened.
             *     Read-only.
             *     +optional */
            deletionGracePeriodSeconds?: number;
            /** @description DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This
             *     field is set by the server when a graceful deletion is requested by the user, and is not
             *     directly settable by a client. The resource is expected to be deleted (no longer visible
             *     from resource lists, and not reachable by name) after the time in this field, once the
             *     finalizers list is empty. As long as the finalizers list contains items, deletion is blocked.
             *     Once the deletionTimestamp is set, this value may not be unset or be set further into the
             *     future, although it may be shortened or the resource may be deleted prior to this time.
             *     For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react
             *     by sending a graceful termination signal to the containers in the pod. After that 30 seconds,
             *     the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup,
             *     remove the pod from the API. In the presence of network partitions, this object may still
             *     exist after this timestamp, until an administrator or automated process can determine the
             *     resource is fully terminated.
             *     If not set, graceful deletion of the object has not been requested.
             *
             *     Populated by the system when a graceful deletion is requested.
             *     Read-only.
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             *     +optional */
            deletionTimestamp?: string;
            /** @description Must be empty before the object is deleted from the registry. Each entry
             *     is an identifier for the responsible component that will remove the entry
             *     from the list. If the deletionTimestamp of the object is non-nil, entries
             *     in this list can only be removed.
             *     Finalizers may be processed and removed in any order.  Order is NOT enforced
             *     because it introduces significant risk of stuck finalizers.
             *     finalizers is a shared field, any actor with permission can reorder it.
             *     If the finalizer list is processed in order, then this can lead to a situation
             *     in which the component responsible for the first finalizer in the list is
             *     waiting for a signal (field value, external system, or other) produced by a
             *     component responsible for a finalizer later in the list, resulting in a deadlock.
             *     Without enforced ordering finalizers are free to order amongst themselves and
             *     are not vulnerable to ordering changes in the list.
             *     +optional
             *     +patchStrategy=merge */
            finalizers?: string[];
            /** @description GenerateName is an optional prefix, used by the server, to generate a unique
             *     name ONLY IF the Name field has not been provided.
             *     If this field is used, the name returned to the client will be different
             *     than the name passed. This value will also be combined with a unique suffix.
             *     The provided value has the same validation rules as the Name field,
             *     and may be truncated by the length of the suffix required to make the value
             *     unique on the server.
             *
             *     If this field is specified and the generated name exists, the server will return a 409.
             *
             *     Applied only if Name is not specified.
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency
             *     +optional */
            generateName?: string;
            /** @description A sequence number representing a specific generation of the desired state.
             *     Populated by the system. Read-only.
             *     +optional */
            generation?: number;
            /** @description Kind is a string value representing the REST resource this object represents.
             *     Servers may infer this from the endpoint the client submits requests to.
             *     Cannot be updated.
             *     In CamelCase.
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             *     +optional */
            kind?: string;
            /** @description Map of string keys and values that can be used to organize and categorize
             *     (scope and select) objects. May match selectors of replication controllers
             *     and services.
             *     More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
             *     +optional */
            labels?: {
                [key: string]: string;
            };
            /** @description ManagedFields maps workflow-id and version to the set of fields
             *     that are managed by that workflow. This is mostly for internal
             *     housekeeping, and users typically shouldn't need to set or
             *     understand this field. A workflow can be the user's name, a
             *     controller's name, or the name of a specific apply path like
             *     "ci-cd". The set of fields is always in the version that the
             *     workflow used when modifying the object.
             *
             *     +optional */
            managedFields?: components["schemas"]["v1.ManagedFieldsEntry"][];
            /** @description Name must be unique within a namespace. Is required when creating resources, although
             *     some resources may allow a client to request the generation of an appropriate name
             *     automatically. Name is primarily intended for creation idempotence and configuration
             *     definition.
             *     Cannot be updated.
             *     More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
             *     +optional */
            name?: string;
            /** @description Namespace defines the space within which each name must be unique. An empty namespace is
             *     equivalent to the "default" namespace, but "default" is the canonical representation.
             *     Not all objects are required to be scoped to a namespace - the value of this field for
             *     those objects will be empty.
             *
             *     Must be a DNS_LABEL.
             *     Cannot be updated.
             *     More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces
             *     +optional */
            namespace?: string;
            /** @description List of objects depended by this object. If ALL objects in the list have
             *     been deleted, this object will be garbage collected. If this object is managed by a controller,
             *     then an entry in this list will point to this controller, with the controller field set to true.
             *     There cannot be more than one managing controller.
             *     +optional
             *     +patchMergeKey=uid
             *     +patchStrategy=merge */
            ownerReferences?: components["schemas"]["v1.OwnerReference"][];
            /** @description An opaque value that represents the internal version of this object that can
             *     be used by clients to determine when objects have changed. May be used for optimistic
             *     concurrency, change detection, and the watch operation on a resource or set of resources.
             *     Clients must treat these values as opaque and passed unmodified back to the server.
             *     They may only be valid for a particular resource or set of resources.
             *
             *     Populated by the system.
             *     Read-only.
             *     Value must be treated as opaque by clients and .
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             *     +optional */
            resourceVersion?: string;
            /** @description Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.
             *     +optional */
            selfLink?: string;
            spec?: components["schemas"]["v1.ResourceQuotaSpec"];
            status?: components["schemas"]["v1.ResourceQuotaStatus"];
            /** @description UID is the unique in time and space value for this object. It is typically generated by
             *     the server on successful creation of a resource and is not allowed to change on PUT
             *     operations.
             *
             *     Populated by the system.
             *     Read-only.
             *     More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
             *     +optional */
            uid?: string;
        };
        "v1.ResourceQuotaSpec": {
            hard?: components["schemas"]["v1.ResourceList"];
            scopeSelector?: components["schemas"]["v1.ScopeSelector"];
            /** @description A collection of filters that must match each object tracked by a quota.
             *     If not specified, the quota matches all objects.
             *     +optional */
            scopes?: string[];
        };
        "v1.ResourceQuotaStatus": {
            hard?: components["schemas"]["v1.ResourceList"];
            used?: components["schemas"]["v1.ResourceList"];
        };
        "v1.ResourceRequirements": {
            /** @description Claims lists the names of resources, defined in spec.resourceClaims,
             *     that are used by this container.
             *
             *     This is an alpha field and requires enabling the
             *     DynamicResourceAllocation feature gate.
             *
             *     This field is immutable. It can only be set for containers.
             *
             *     +listType=map
             *     +listMapKey=name
             *     +featureGate=DynamicResourceAllocation
             *     +optional */
            claims?: components["schemas"]["v1.ResourceClaim"][];
            limits?: components["schemas"]["v1.ResourceList"];
            requests?: components["schemas"]["v1.ResourceList"];
        };
        "v1.RoleRef": {
            /** @description APIGroup is the group for the resource being referenced */
            apiGroup?: string;
            /** @description Kind is the type of resource being referenced */
            kind?: string;
            /** @description Name is the name of resource being referenced */
            name?: string;
        };
        "v1.SELinuxOptions": {
            /** @description Level is SELinux level label that applies to the container.
             *     +optional */
            level?: string;
            /** @description Role is a SELinux role label that applies to the container.
             *     +optional */
            role?: string;
            /** @description Type is a SELinux type label that applies to the container.
             *     +optional */
            type?: string;
            /** @description User is a SELinux user label that applies to the container.
             *     +optional */
            user?: string;
        };
        "v1.ScopeSelector": {
            /** @description A list of scope selector requirements by scope of the resources.
             *     +optional */
            matchExpressions?: components["schemas"]["v1.ScopedResourceSelectorRequirement"][];
        };
        "v1.ScopedResourceSelectorRequirement": {
            /** @description Represents a scope's relationship to a set of values.
             *     Valid operators are In, NotIn, Exists, DoesNotExist. */
            operator?: string;
            /** @description The name of the scope that the selector applies to. */
            scopeName?: string;
            /** @description An array of string values. If the operator is In or NotIn,
             *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
             *     the values array must be empty.
             *     This array is replaced during a strategic merge patch.
             *     +optional */
            values?: string[];
        };
        "v1.SeccompProfile": {
            /** @description localhostProfile indicates a profile defined in a file on the node should be used.
             *     The profile must be preconfigured on the node to work.
             *     Must be a descending path, relative to the kubelet's configured seccomp profile location.
             *     Must be set if type is "Localhost". Must NOT be set for any other type.
             *     +optional */
            localhostProfile?: string;
            /** @description type indicates which kind of seccomp profile will be applied.
             *     Valid options are:
             *
             *     Localhost - a profile defined in a file on the node should be used.
             *     RuntimeDefault - the container runtime default profile should be used.
             *     Unconfined - no profile should be applied.
             *     +unionDiscriminator */
            type?: string;
        };
        "v1.SecretEnvSource": {
            /** @description Name of the referent.
             *     More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             *     TODO: Add other useful fields. apiVersion, kind, uid?
             *     +optional */
            name?: string;
            /** @description Specify whether the Secret must be defined
             *     +optional */
            optional?: boolean;
        };
        "v1.SecretKeySelector": {
            /** @description The key of the secret to select from.  Must be a valid secret key. */
            key?: string;
            /** @description Name of the referent.
             *     More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             *     TODO: Add other useful fields. apiVersion, kind, uid?
             *     +optional */
            name?: string;
            /** @description Specify whether the Secret or its key must be defined
             *     +optional */
            optional?: boolean;
        };
        "v1.SecretReference": {
            /** @description name is unique within a namespace to reference a secret resource.
             *     +optional */
            name?: string;
            /** @description namespace defines the space within which the secret name must be unique.
             *     +optional */
            namespace?: string;
        };
        "v1.SecurityContext": {
            /** @description AllowPrivilegeEscalation controls whether a process can gain more
             *     privileges than its parent process. This bool directly controls if
             *     the no_new_privs flag will be set on the container process.
             *     AllowPrivilegeEscalation is true always when the container is:
             *     1) run as Privileged
             *     2) has CAP_SYS_ADMIN
             *     Note that this field cannot be set when spec.os.name is windows.
             *     +optional */
            allowPrivilegeEscalation?: boolean;
            capabilities?: components["schemas"]["v1.Capabilities"];
            /** @description Run container in privileged mode.
             *     Processes in privileged containers are essentially equivalent to root on the host.
             *     Defaults to false.
             *     Note that this field cannot be set when spec.os.name is windows.
             *     +optional */
            privileged?: boolean;
            /** @description procMount denotes the type of proc mount to use for the containers.
             *     The default is DefaultProcMount which uses the container runtime defaults for
             *     readonly paths and masked paths.
             *     This requires the ProcMountType feature flag to be enabled.
             *     Note that this field cannot be set when spec.os.name is windows.
             *     +optional */
            procMount?: string;
            /** @description Whether this container has a read-only root filesystem.
             *     Default is false.
             *     Note that this field cannot be set when spec.os.name is windows.
             *     +optional */
            readOnlyRootFilesystem?: boolean;
            /** @description The GID to run the entrypoint of the container process.
             *     Uses runtime default if unset.
             *     May also be set in PodSecurityContext.  If set in both SecurityContext and
             *     PodSecurityContext, the value specified in SecurityContext takes precedence.
             *     Note that this field cannot be set when spec.os.name is windows.
             *     +optional */
            runAsGroup?: number;
            /** @description Indicates that the container must run as a non-root user.
             *     If true, the Kubelet will validate the image at runtime to ensure that it
             *     does not run as UID 0 (root) and fail to start the container if it does.
             *     If unset or false, no such validation will be performed.
             *     May also be set in PodSecurityContext.  If set in both SecurityContext and
             *     PodSecurityContext, the value specified in SecurityContext takes precedence.
             *     +optional */
            runAsNonRoot?: boolean;
            /** @description The UID to run the entrypoint of the container process.
             *     Defaults to user specified in image metadata if unspecified.
             *     May also be set in PodSecurityContext.  If set in both SecurityContext and
             *     PodSecurityContext, the value specified in SecurityContext takes precedence.
             *     Note that this field cannot be set when spec.os.name is windows.
             *     +optional */
            runAsUser?: number;
            seLinuxOptions?: components["schemas"]["v1.SELinuxOptions"];
            seccompProfile?: components["schemas"]["v1.SeccompProfile"];
            windowsOptions?: components["schemas"]["v1.WindowsSecurityContextOptions"];
        };
        "v1.Service": {
            /** @description Annotations is an unstructured key value map stored with a resource that may be
             *     set by external tools to store and retrieve arbitrary metadata. They are not
             *     queryable and should be preserved when modifying objects.
             *     More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
             *     +optional */
            annotations?: {
                [key: string]: string;
            };
            /** @description APIVersion defines the versioned schema of this representation of an object.
             *     Servers should convert recognized schemas to the latest internal value, and
             *     may reject unrecognized values.
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             *     +optional */
            apiVersion?: string;
            /** @description CreationTimestamp is a timestamp representing the server time when this object was
             *     created. It is not guaranteed to be set in happens-before order across separate operations.
             *     Clients may not set this value. It is represented in RFC3339 form and is in UTC.
             *
             *     Populated by the system.
             *     Read-only.
             *     Null for lists.
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             *     +optional */
            creationTimestamp?: string;
            /** @description Number of seconds allowed for this object to gracefully terminate before
             *     it will be removed from the system. Only set when deletionTimestamp is also set.
             *     May only be shortened.
             *     Read-only.
             *     +optional */
            deletionGracePeriodSeconds?: number;
            /** @description DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This
             *     field is set by the server when a graceful deletion is requested by the user, and is not
             *     directly settable by a client. The resource is expected to be deleted (no longer visible
             *     from resource lists, and not reachable by name) after the time in this field, once the
             *     finalizers list is empty. As long as the finalizers list contains items, deletion is blocked.
             *     Once the deletionTimestamp is set, this value may not be unset or be set further into the
             *     future, although it may be shortened or the resource may be deleted prior to this time.
             *     For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react
             *     by sending a graceful termination signal to the containers in the pod. After that 30 seconds,
             *     the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup,
             *     remove the pod from the API. In the presence of network partitions, this object may still
             *     exist after this timestamp, until an administrator or automated process can determine the
             *     resource is fully terminated.
             *     If not set, graceful deletion of the object has not been requested.
             *
             *     Populated by the system when a graceful deletion is requested.
             *     Read-only.
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             *     +optional */
            deletionTimestamp?: string;
            /** @description Must be empty before the object is deleted from the registry. Each entry
             *     is an identifier for the responsible component that will remove the entry
             *     from the list. If the deletionTimestamp of the object is non-nil, entries
             *     in this list can only be removed.
             *     Finalizers may be processed and removed in any order.  Order is NOT enforced
             *     because it introduces significant risk of stuck finalizers.
             *     finalizers is a shared field, any actor with permission can reorder it.
             *     If the finalizer list is processed in order, then this can lead to a situation
             *     in which the component responsible for the first finalizer in the list is
             *     waiting for a signal (field value, external system, or other) produced by a
             *     component responsible for a finalizer later in the list, resulting in a deadlock.
             *     Without enforced ordering finalizers are free to order amongst themselves and
             *     are not vulnerable to ordering changes in the list.
             *     +optional
             *     +patchStrategy=merge */
            finalizers?: string[];
            /** @description GenerateName is an optional prefix, used by the server, to generate a unique
             *     name ONLY IF the Name field has not been provided.
             *     If this field is used, the name returned to the client will be different
             *     than the name passed. This value will also be combined with a unique suffix.
             *     The provided value has the same validation rules as the Name field,
             *     and may be truncated by the length of the suffix required to make the value
             *     unique on the server.
             *
             *     If this field is specified and the generated name exists, the server will return a 409.
             *
             *     Applied only if Name is not specified.
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency
             *     +optional */
            generateName?: string;
            /** @description A sequence number representing a specific generation of the desired state.
             *     Populated by the system. Read-only.
             *     +optional */
            generation?: number;
            /** @description Kind is a string value representing the REST resource this object represents.
             *     Servers may infer this from the endpoint the client submits requests to.
             *     Cannot be updated.
             *     In CamelCase.
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             *     +optional */
            kind?: string;
            /** @description Map of string keys and values that can be used to organize and categorize
             *     (scope and select) objects. May match selectors of replication controllers
             *     and services.
             *     More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
             *     +optional */
            labels?: {
                [key: string]: string;
            };
            /** @description ManagedFields maps workflow-id and version to the set of fields
             *     that are managed by that workflow. This is mostly for internal
             *     housekeeping, and users typically shouldn't need to set or
             *     understand this field. A workflow can be the user's name, a
             *     controller's name, or the name of a specific apply path like
             *     "ci-cd". The set of fields is always in the version that the
             *     workflow used when modifying the object.
             *
             *     +optional */
            managedFields?: components["schemas"]["v1.ManagedFieldsEntry"][];
            /** @description Name must be unique within a namespace. Is required when creating resources, although
             *     some resources may allow a client to request the generation of an appropriate name
             *     automatically. Name is primarily intended for creation idempotence and configuration
             *     definition.
             *     Cannot be updated.
             *     More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
             *     +optional */
            name?: string;
            /** @description Namespace defines the space within which each name must be unique. An empty namespace is
             *     equivalent to the "default" namespace, but "default" is the canonical representation.
             *     Not all objects are required to be scoped to a namespace - the value of this field for
             *     those objects will be empty.
             *
             *     Must be a DNS_LABEL.
             *     Cannot be updated.
             *     More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces
             *     +optional */
            namespace?: string;
            /** @description List of objects depended by this object. If ALL objects in the list have
             *     been deleted, this object will be garbage collected. If this object is managed by a controller,
             *     then an entry in this list will point to this controller, with the controller field set to true.
             *     There cannot be more than one managing controller.
             *     +optional
             *     +patchMergeKey=uid
             *     +patchStrategy=merge */
            ownerReferences?: components["schemas"]["v1.OwnerReference"][];
            /** @description An opaque value that represents the internal version of this object that can
             *     be used by clients to determine when objects have changed. May be used for optimistic
             *     concurrency, change detection, and the watch operation on a resource or set of resources.
             *     Clients must treat these values as opaque and passed unmodified back to the server.
             *     They may only be valid for a particular resource or set of resources.
             *
             *     Populated by the system.
             *     Read-only.
             *     Value must be treated as opaque by clients and .
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             *     +optional */
            resourceVersion?: string;
            /** @description Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.
             *     +optional */
            selfLink?: string;
            spec?: components["schemas"]["v1.ServiceSpec"];
            status?: components["schemas"]["v1.ServiceStatus"];
            /** @description UID is the unique in time and space value for this object. It is typically generated by
             *     the server on successful creation of a resource and is not allowed to change on PUT
             *     operations.
             *
             *     Populated by the system.
             *     Read-only.
             *     More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
             *     +optional */
            uid?: string;
        };
        "v1.ServicePort": {
            /** @description The application protocol for this port.
             *     This is used as a hint for implementations to offer richer behavior for protocols that they understand.
             *     This field follows standard Kubernetes label syntax.
             *     Valid values are either:
             *
             *     * Un-prefixed protocol names - reserved for IANA standard service names (as per
             *     RFC-6335 and https://www.iana.org/assignments/service-names).
             *
             *     * Kubernetes-defined prefixed names:
             *       * 'kubernetes.io/h2c' - HTTP/2 prior knowledge over cleartext as described in https://www.rfc-editor.org/rfc/rfc9113.html#name-starting-http-2-with-prior-
             *       * 'kubernetes.io/ws'  - WebSocket over cleartext as described in https://www.rfc-editor.org/rfc/rfc6455
             *       * 'kubernetes.io/wss' - WebSocket over TLS as described in https://www.rfc-editor.org/rfc/rfc6455
             *
             *     * Other protocols should use implementation-defined prefixed names such as
             *     mycompany.com/my-custom-protocol.
             *     +optional */
            appProtocol?: string;
            /** @description The name of this port within the service. This must be a DNS_LABEL.
             *     All ports within a ServiceSpec must have unique names. When considering
             *     the endpoints for a Service, this must match the 'name' field in the
             *     EndpointPort.
             *     Optional if only one ServicePort is defined on this service.
             *     +optional */
            name?: string;
            /** @description The port on each node on which this service is exposed when type is
             *     NodePort or LoadBalancer.  Usually assigned by the system. If a value is
             *     specified, in-range, and not in use it will be used, otherwise the
             *     operation will fail.  If not specified, a port will be allocated if this
             *     Service requires one.  If this field is specified when creating a
             *     Service which does not need it, creation will fail. This field will be
             *     wiped when updating a Service to no longer need it (e.g. changing type
             *     from NodePort to ClusterIP).
             *     More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
             *     +optional */
            nodePort?: number;
            /** @description The port that will be exposed by this service. */
            port?: number;
            /** @description The IP protocol for this port. Supports "TCP", "UDP", and "SCTP".
             *     Default is TCP.
             *     +default="TCP"
             *     +optional */
            protocol?: string;
            targetPort?: components["schemas"]["intstr.IntOrString"];
        };
        "v1.ServiceSpec": {
            /** @description allocateLoadBalancerNodePorts defines if NodePorts will be automatically
             *     allocated for services with type LoadBalancer.  Default is "true". It
             *     may be set to "false" if the cluster load-balancer does not rely on
             *     NodePorts.  If the caller requests specific NodePorts (by specifying a
             *     value), those requests will be respected, regardless of this field.
             *     This field may only be set for services with type LoadBalancer and will
             *     be cleared if the type is changed to any other type.
             *     +optional */
            allocateLoadBalancerNodePorts?: boolean;
            /** @description clusterIP is the IP address of the service and is usually assigned
             *     randomly. If an address is specified manually, is in-range (as per
             *     system configuration), and is not in use, it will be allocated to the
             *     service; otherwise creation of the service will fail. This field may not
             *     be changed through updates unless the type field is also being changed
             *     to ExternalName (which requires this field to be blank) or the type
             *     field is being changed from ExternalName (in which case this field may
             *     optionally be specified, as describe above).  Valid values are "None",
             *     empty string (""), or a valid IP address. Setting this to "None" makes a
             *     "headless service" (no virtual IP), which is useful when direct endpoint
             *     connections are preferred and proxying is not required.  Only applies to
             *     types ClusterIP, NodePort, and LoadBalancer. If this field is specified
             *     when creating a Service of type ExternalName, creation will fail. This
             *     field will be wiped when updating a Service to type ExternalName.
             *     More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
             *     +optional */
            clusterIP?: string;
            /** @description ClusterIPs is a list of IP addresses assigned to this service, and are
             *     usually assigned randomly.  If an address is specified manually, is
             *     in-range (as per system configuration), and is not in use, it will be
             *     allocated to the service; otherwise creation of the service will fail.
             *     This field may not be changed through updates unless the type field is
             *     also being changed to ExternalName (which requires this field to be
             *     empty) or the type field is being changed from ExternalName (in which
             *     case this field may optionally be specified, as describe above).  Valid
             *     values are "None", empty string (""), or a valid IP address.  Setting
             *     this to "None" makes a "headless service" (no virtual IP), which is
             *     useful when direct endpoint connections are preferred and proxying is
             *     not required.  Only applies to types ClusterIP, NodePort, and
             *     LoadBalancer. If this field is specified when creating a Service of type
             *     ExternalName, creation will fail. This field will be wiped when updating
             *     a Service to type ExternalName.  If this field is not specified, it will
             *     be initialized from the clusterIP field.  If this field is specified,
             *     clients must ensure that clusterIPs[0] and clusterIP have the same
             *     value.
             *
             *     This field may hold a maximum of two entries (dual-stack IPs, in either order).
             *     These IPs must correspond to the values of the ipFamilies field. Both
             *     clusterIPs and ipFamilies are governed by the ipFamilyPolicy field.
             *     More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
             *     +listType=atomic
             *     +optional */
            clusterIPs?: string[];
            /** @description externalIPs is a list of IP addresses for which nodes in the cluster
             *     will also accept traffic for this service.  These IPs are not managed by
             *     Kubernetes.  The user is responsible for ensuring that traffic arrives
             *     at a node with this IP.  A common example is external load-balancers
             *     that are not part of the Kubernetes system.
             *     +optional */
            externalIPs?: string[];
            /** @description externalName is the external reference that discovery mechanisms will
             *     return as an alias for this service (e.g. a DNS CNAME record). No
             *     proxying will be involved.  Must be a lowercase RFC-1123 hostname
             *     (https://tools.ietf.org/html/rfc1123) and requires `type` to be "ExternalName".
             *     +optional */
            externalName?: string;
            /** @description externalTrafficPolicy describes how nodes distribute service traffic they
             *     receive on one of the Service's "externally-facing" addresses (NodePorts,
             *     ExternalIPs, and LoadBalancer IPs). If set to "Local", the proxy will configure
             *     the service in a way that assumes that external load balancers will take care
             *     of balancing the service traffic between nodes, and so each node will deliver
             *     traffic only to the node-local endpoints of the service, without masquerading
             *     the client source IP. (Traffic mistakenly sent to a node with no endpoints will
             *     be dropped.) The default value, "Cluster", uses the standard behavior of
             *     routing to all endpoints evenly (possibly modified by topology and other
             *     features). Note that traffic sent to an External IP or LoadBalancer IP from
             *     within the cluster will always get "Cluster" semantics, but clients sending to
             *     a NodePort from within the cluster may need to take traffic policy into account
             *     when picking a node.
             *     +optional */
            externalTrafficPolicy?: string;
            /** @description healthCheckNodePort specifies the healthcheck nodePort for the service.
             *     This only applies when type is set to LoadBalancer and
             *     externalTrafficPolicy is set to Local. If a value is specified, is
             *     in-range, and is not in use, it will be used.  If not specified, a value
             *     will be automatically allocated.  External systems (e.g. load-balancers)
             *     can use this port to determine if a given node holds endpoints for this
             *     service or not.  If this field is specified when creating a Service
             *     which does not need it, creation will fail. This field will be wiped
             *     when updating a Service to no longer need it (e.g. changing type).
             *     This field cannot be updated once set.
             *     +optional */
            healthCheckNodePort?: number;
            /** @description InternalTrafficPolicy describes how nodes distribute service traffic they
             *     receive on the ClusterIP. If set to "Local", the proxy will assume that pods
             *     only want to talk to endpoints of the service on the same node as the pod,
             *     dropping the traffic if there are no local endpoints. The default value,
             *     "Cluster", uses the standard behavior of routing to all endpoints evenly
             *     (possibly modified by topology and other features).
             *     +optional */
            internalTrafficPolicy?: string;
            /** @description IPFamilies is a list of IP families (e.g. IPv4, IPv6) assigned to this
             *     service. This field is usually assigned automatically based on cluster
             *     configuration and the ipFamilyPolicy field. If this field is specified
             *     manually, the requested family is available in the cluster,
             *     and ipFamilyPolicy allows it, it will be used; otherwise creation of
             *     the service will fail. This field is conditionally mutable: it allows
             *     for adding or removing a secondary IP family, but it does not allow
             *     changing the primary IP family of the Service. Valid values are "IPv4"
             *     and "IPv6".  This field only applies to Services of types ClusterIP,
             *     NodePort, and LoadBalancer, and does apply to "headless" services.
             *     This field will be wiped when updating a Service to type ExternalName.
             *
             *     This field may hold a maximum of two entries (dual-stack families, in
             *     either order).  These families must correspond to the values of the
             *     clusterIPs field, if specified. Both clusterIPs and ipFamilies are
             *     governed by the ipFamilyPolicy field.
             *     +listType=atomic
             *     +optional */
            ipFamilies?: string[];
            /** @description IPFamilyPolicy represents the dual-stack-ness requested or required by
             *     this Service. If there is no value provided, then this field will be set
             *     to SingleStack. Services can be "SingleStack" (a single IP family),
             *     "PreferDualStack" (two IP families on dual-stack configured clusters or
             *     a single IP family on single-stack clusters), or "RequireDualStack"
             *     (two IP families on dual-stack configured clusters, otherwise fail). The
             *     ipFamilies and clusterIPs fields depend on the value of this field. This
             *     field will be wiped when updating a service to type ExternalName.
             *     +optional */
            ipFamilyPolicy?: string;
            /** @description loadBalancerClass is the class of the load balancer implementation this Service belongs to.
             *     If specified, the value of this field must be a label-style identifier, with an optional prefix,
             *     e.g. "internal-vip" or "example.com/internal-vip". Unprefixed names are reserved for end-users.
             *     This field can only be set when the Service type is 'LoadBalancer'. If not set, the default load
             *     balancer implementation is used, today this is typically done through the cloud provider integration,
             *     but should apply for any default implementation. If set, it is assumed that a load balancer
             *     implementation is watching for Services with a matching class. Any default load balancer
             *     implementation (e.g. cloud providers) should ignore Services that set this field.
             *     This field can only be set when creating or updating a Service to type 'LoadBalancer'.
             *     Once set, it can not be changed. This field will be wiped when a service is updated to a non 'LoadBalancer' type.
             *     +optional */
            loadBalancerClass?: string;
            /** @description Only applies to Service Type: LoadBalancer.
             *     This feature depends on whether the underlying cloud-provider supports specifying
             *     the loadBalancerIP when a load balancer is created.
             *     This field will be ignored if the cloud-provider does not support the feature.
             *     Deprecated: This field was under-specified and its meaning varies across implementations.
             *     Using it is non-portable and it may not support dual-stack.
             *     Users are encouraged to use implementation-specific annotations when available.
             *     +optional */
            loadBalancerIP?: string;
            /** @description If specified and supported by the platform, this will restrict traffic through the cloud-provider
             *     load-balancer will be restricted to the specified client IPs. This field will be ignored if the
             *     cloud-provider does not support the feature."
             *     More info: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/
             *     +optional */
            loadBalancerSourceRanges?: string[];
            /** @description The list of ports that are exposed by this service.
             *     More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
             *     +patchMergeKey=port
             *     +patchStrategy=merge
             *     +listType=map
             *     +listMapKey=port
             *     +listMapKey=protocol */
            ports?: components["schemas"]["v1.ServicePort"][];
            /** @description publishNotReadyAddresses indicates that any agent which deals with endpoints for this
             *     Service should disregard any indications of ready/not-ready.
             *     The primary use case for setting this field is for a StatefulSet's Headless Service to
             *     propagate SRV DNS records for its Pods for the purpose of peer discovery.
             *     The Kubernetes controllers that generate Endpoints and EndpointSlice resources for
             *     Services interpret this to mean that all endpoints are considered "ready" even if the
             *     Pods themselves are not. Agents which consume only Kubernetes generated endpoints
             *     through the Endpoints or EndpointSlice resources can safely assume this behavior.
             *     +optional */
            publishNotReadyAddresses?: boolean;
            /** @description Route service traffic to pods with label keys and values matching this
             *     selector. If empty or not present, the service is assumed to have an
             *     external process managing its endpoints, which Kubernetes will not
             *     modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
             *     Ignored if type is ExternalName.
             *     More info: https://kubernetes.io/docs/concepts/services-networking/service/
             *     +optional
             *     +mapType=atomic */
            selector?: {
                [key: string]: string;
            };
            /** @description Supports "ClientIP" and "None". Used to maintain session affinity.
             *     Enable client IP based session affinity.
             *     Must be ClientIP or None.
             *     Defaults to None.
             *     More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
             *     +optional */
            sessionAffinity?: string;
            sessionAffinityConfig?: components["schemas"]["v1.SessionAffinityConfig"];
            /** @description type determines how the Service is exposed. Defaults to ClusterIP. Valid
             *     options are ExternalName, ClusterIP, NodePort, and LoadBalancer.
             *     "ClusterIP" allocates a cluster-internal IP address for load-balancing
             *     to endpoints. Endpoints are determined by the selector or if that is not
             *     specified, by manual construction of an Endpoints object or
             *     EndpointSlice objects. If clusterIP is "None", no virtual IP is
             *     allocated and the endpoints are published as a set of endpoints rather
             *     than a virtual IP.
             *     "NodePort" builds on ClusterIP and allocates a port on every node which
             *     routes to the same endpoints as the clusterIP.
             *     "LoadBalancer" builds on NodePort and creates an external load-balancer
             *     (if supported in the current cloud) which routes to the same endpoints
             *     as the clusterIP.
             *     "ExternalName" aliases this service to the specified externalName.
             *     Several other fields do not apply to ExternalName services.
             *     More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
             *     +optional */
            type?: string;
        };
        "v1.ServiceStatus": {
            /** @description Current service state
             *     +optional
             *     +patchMergeKey=type
             *     +patchStrategy=merge
             *     +listType=map
             *     +listMapKey=type */
            conditions?: components["schemas"]["v1.Condition"][];
            loadBalancer?: components["schemas"]["v1.LoadBalancerStatus"];
        };
        "v1.SessionAffinityConfig": {
            clientIP?: components["schemas"]["v1.ClientIPConfig"];
        };
        "v1.SleepAction": {
            /** @description Seconds is the number of seconds to sleep. */
            seconds?: number;
        };
        "v1.Subject": {
            /** @description APIGroup holds the API group of the referenced subject.
             *     Defaults to "" for ServiceAccount subjects.
             *     Defaults to "rbac.authorization.k8s.io" for User and Group subjects.
             *     +optional */
            apiGroup?: string;
            /** @description Kind of object being referenced. Values defined by this API group are "User", "Group", and "ServiceAccount".
             *     If the Authorizer does not recognized the kind value, the Authorizer should report an error. */
            kind?: string;
            /** @description Name of the object being referenced. */
            name?: string;
            /** @description Namespace of the referenced object.  If the object kind is non-namespace, such as "User" or "Group", and this value is not empty
             *     the Authorizer should report an error.
             *     +optional */
            namespace?: string;
        };
        "v1.TCPSocketAction": {
            /** @description Optional: Host name to connect to, defaults to the pod IP.
             *     +optional */
            host?: string;
            port?: components["schemas"]["intstr.IntOrString"];
        };
        "v1.VolumeDevice": {
            /** @description devicePath is the path inside of the container that the device will be mapped to. */
            devicePath?: string;
            /** @description name must match the name of a persistentVolumeClaim in the pod */
            name?: string;
        };
        "v1.VolumeMount": {
            /** @description Path within the container at which the volume should be mounted.  Must
             *     not contain ':'. */
            mountPath?: string;
            /** @description mountPropagation determines how mounts are propagated from the host
             *     to container and the other way around.
             *     When not set, MountPropagationNone is used.
             *     This field is beta in 1.10.
             *     +optional */
            mountPropagation?: string;
            /** @description This must match the Name of a Volume. */
            name?: string;
            /** @description Mounted read-only if true, read-write otherwise (false or unspecified).
             *     Defaults to false.
             *     +optional */
            readOnly?: boolean;
            /** @description Path within the volume from which the container's volume should be mounted.
             *     Defaults to "" (volume's root).
             *     +optional */
            subPath?: string;
            /** @description Expanded path within the volume from which the container's volume should be mounted.
             *     Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
             *     Defaults to "" (volume's root).
             *     SubPathExpr and SubPath are mutually exclusive.
             *     +optional */
            subPathExpr?: string;
        };
        "v1.WindowsSecurityContextOptions": {
            /** @description GMSACredentialSpec is where the GMSA admission webhook
             *     (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
             *     GMSA credential spec named by the GMSACredentialSpecName field.
             *     +optional */
            gmsaCredentialSpec?: string;
            /** @description GMSACredentialSpecName is the name of the GMSA credential spec to use.
             *     +optional */
            gmsaCredentialSpecName?: string;
            /** @description HostProcess determines if a container should be run as a 'Host Process' container.
             *     All of a Pod's containers must have the same effective HostProcess value
             *     (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
             *     In addition, if HostProcess is true then HostNetwork must also be set to true.
             *     +optional */
            hostProcess?: boolean;
            /** @description The UserName in Windows to run the entrypoint of the container process.
             *     Defaults to the user specified in image metadata if unspecified.
             *     May also be set in PodSecurityContext. If set in both SecurityContext and
             *     PodSecurityContext, the value specified in SecurityContext takes precedence.
             *     +optional */
            runAsUserName?: string;
        };
        "v1beta1.ContainerMetrics": {
            /** @description Container name corresponding to the one from pod.spec.containers. */
            name?: string;
            usage?: components["schemas"]["v1.ResourceList"];
        };
        "v1beta1.NodeMetrics": {
            /** @description Annotations is an unstructured key value map stored with a resource that may be
             *     set by external tools to store and retrieve arbitrary metadata. They are not
             *     queryable and should be preserved when modifying objects.
             *     More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
             *     +optional */
            annotations?: {
                [key: string]: string;
            };
            /** @description APIVersion defines the versioned schema of this representation of an object.
             *     Servers should convert recognized schemas to the latest internal value, and
             *     may reject unrecognized values.
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             *     +optional */
            apiVersion?: string;
            /** @description CreationTimestamp is a timestamp representing the server time when this object was
             *     created. It is not guaranteed to be set in happens-before order across separate operations.
             *     Clients may not set this value. It is represented in RFC3339 form and is in UTC.
             *
             *     Populated by the system.
             *     Read-only.
             *     Null for lists.
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             *     +optional */
            creationTimestamp?: string;
            /** @description Number of seconds allowed for this object to gracefully terminate before
             *     it will be removed from the system. Only set when deletionTimestamp is also set.
             *     May only be shortened.
             *     Read-only.
             *     +optional */
            deletionGracePeriodSeconds?: number;
            /** @description DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This
             *     field is set by the server when a graceful deletion is requested by the user, and is not
             *     directly settable by a client. The resource is expected to be deleted (no longer visible
             *     from resource lists, and not reachable by name) after the time in this field, once the
             *     finalizers list is empty. As long as the finalizers list contains items, deletion is blocked.
             *     Once the deletionTimestamp is set, this value may not be unset or be set further into the
             *     future, although it may be shortened or the resource may be deleted prior to this time.
             *     For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react
             *     by sending a graceful termination signal to the containers in the pod. After that 30 seconds,
             *     the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup,
             *     remove the pod from the API. In the presence of network partitions, this object may still
             *     exist after this timestamp, until an administrator or automated process can determine the
             *     resource is fully terminated.
             *     If not set, graceful deletion of the object has not been requested.
             *
             *     Populated by the system when a graceful deletion is requested.
             *     Read-only.
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             *     +optional */
            deletionTimestamp?: string;
            /** @description Must be empty before the object is deleted from the registry. Each entry
             *     is an identifier for the responsible component that will remove the entry
             *     from the list. If the deletionTimestamp of the object is non-nil, entries
             *     in this list can only be removed.
             *     Finalizers may be processed and removed in any order.  Order is NOT enforced
             *     because it introduces significant risk of stuck finalizers.
             *     finalizers is a shared field, any actor with permission can reorder it.
             *     If the finalizer list is processed in order, then this can lead to a situation
             *     in which the component responsible for the first finalizer in the list is
             *     waiting for a signal (field value, external system, or other) produced by a
             *     component responsible for a finalizer later in the list, resulting in a deadlock.
             *     Without enforced ordering finalizers are free to order amongst themselves and
             *     are not vulnerable to ordering changes in the list.
             *     +optional
             *     +patchStrategy=merge */
            finalizers?: string[];
            /** @description GenerateName is an optional prefix, used by the server, to generate a unique
             *     name ONLY IF the Name field has not been provided.
             *     If this field is used, the name returned to the client will be different
             *     than the name passed. This value will also be combined with a unique suffix.
             *     The provided value has the same validation rules as the Name field,
             *     and may be truncated by the length of the suffix required to make the value
             *     unique on the server.
             *
             *     If this field is specified and the generated name exists, the server will return a 409.
             *
             *     Applied only if Name is not specified.
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency
             *     +optional */
            generateName?: string;
            /** @description A sequence number representing a specific generation of the desired state.
             *     Populated by the system. Read-only.
             *     +optional */
            generation?: number;
            /** @description Kind is a string value representing the REST resource this object represents.
             *     Servers may infer this from the endpoint the client submits requests to.
             *     Cannot be updated.
             *     In CamelCase.
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             *     +optional */
            kind?: string;
            /** @description Map of string keys and values that can be used to organize and categorize
             *     (scope and select) objects. May match selectors of replication controllers
             *     and services.
             *     More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
             *     +optional */
            labels?: {
                [key: string]: string;
            };
            /** @description ManagedFields maps workflow-id and version to the set of fields
             *     that are managed by that workflow. This is mostly for internal
             *     housekeeping, and users typically shouldn't need to set or
             *     understand this field. A workflow can be the user's name, a
             *     controller's name, or the name of a specific apply path like
             *     "ci-cd". The set of fields is always in the version that the
             *     workflow used when modifying the object.
             *
             *     +optional */
            managedFields?: components["schemas"]["v1.ManagedFieldsEntry"][];
            /** @description Name must be unique within a namespace. Is required when creating resources, although
             *     some resources may allow a client to request the generation of an appropriate name
             *     automatically. Name is primarily intended for creation idempotence and configuration
             *     definition.
             *     Cannot be updated.
             *     More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
             *     +optional */
            name?: string;
            /** @description Namespace defines the space within which each name must be unique. An empty namespace is
             *     equivalent to the "default" namespace, but "default" is the canonical representation.
             *     Not all objects are required to be scoped to a namespace - the value of this field for
             *     those objects will be empty.
             *
             *     Must be a DNS_LABEL.
             *     Cannot be updated.
             *     More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces
             *     +optional */
            namespace?: string;
            /** @description List of objects depended by this object. If ALL objects in the list have
             *     been deleted, this object will be garbage collected. If this object is managed by a controller,
             *     then an entry in this list will point to this controller, with the controller field set to true.
             *     There cannot be more than one managing controller.
             *     +optional
             *     +patchMergeKey=uid
             *     +patchStrategy=merge */
            ownerReferences?: components["schemas"]["v1.OwnerReference"][];
            /** @description An opaque value that represents the internal version of this object that can
             *     be used by clients to determine when objects have changed. May be used for optimistic
             *     concurrency, change detection, and the watch operation on a resource or set of resources.
             *     Clients must treat these values as opaque and passed unmodified back to the server.
             *     They may only be valid for a particular resource or set of resources.
             *
             *     Populated by the system.
             *     Read-only.
             *     Value must be treated as opaque by clients and .
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             *     +optional */
            resourceVersion?: string;
            /** @description Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.
             *     +optional */
            selfLink?: string;
            /** @description The following fields define time interval from which metrics were
             *     collected from the interval [Timestamp-Window, Timestamp]. */
            timestamp?: string;
            /** @description UID is the unique in time and space value for this object. It is typically generated by
             *     the server on successful creation of a resource and is not allowed to change on PUT
             *     operations.
             *
             *     Populated by the system.
             *     Read-only.
             *     More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
             *     +optional */
            uid?: string;
            usage?: components["schemas"]["v1.ResourceList"];
            window?: components["schemas"]["v1.Duration"];
        };
        "v1beta1.NodeMetricsList": {
            /** @description APIVersion defines the versioned schema of this representation of an object.
             *     Servers should convert recognized schemas to the latest internal value, and
             *     may reject unrecognized values.
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             *     +optional */
            apiVersion?: string;
            /** @description continue may be set if the user set a limit on the number of items returned, and indicates that
             *     the server has more data available. The value is opaque and may be used to issue another request
             *     to the endpoint that served this list to retrieve the next set of available objects. Continuing a
             *     consistent list may not be possible if the server configuration has changed or more than a few
             *     minutes have passed. The resourceVersion field returned when using this continue value will be
             *     identical to the value in the first response, unless you have received this token from an error
             *     message. */
            continue?: string;
            /** @description List of node metrics. */
            items?: components["schemas"]["v1beta1.NodeMetrics"][];
            /** @description Kind is a string value representing the REST resource this object represents.
             *     Servers may infer this from the endpoint the client submits requests to.
             *     Cannot be updated.
             *     In CamelCase.
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             *     +optional */
            kind?: string;
            /** @description remainingItemCount is the number of subsequent items in the list which are not included in this
             *     list response. If the list request contained label or field selectors, then the number of
             *     remaining items is unknown and the field will be left unset and omitted during serialization.
             *     If the list is complete (either because it is not chunking or because this is the last chunk),
             *     then there are no more remaining items and this field will be left unset and omitted during
             *     serialization.
             *     Servers older than v1.15 do not set this field.
             *     The intended use of the remainingItemCount is *estimating* the size of a collection. Clients
             *     should not rely on the remainingItemCount to be set or to be exact.
             *     +optional */
            remainingItemCount?: number;
            /** @description String that identifies the server's internal version of this object that
             *     can be used by clients to determine when objects have changed.
             *     Value must be treated as opaque by clients and passed unmodified back to the server.
             *     Populated by the system.
             *     Read-only.
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             *     +optional */
            resourceVersion?: string;
            /** @description Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.
             *     +optional */
            selfLink?: string;
        };
        "v1beta1.PodMetrics": {
            /** @description Annotations is an unstructured key value map stored with a resource that may be
             *     set by external tools to store and retrieve arbitrary metadata. They are not
             *     queryable and should be preserved when modifying objects.
             *     More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
             *     +optional */
            annotations?: {
                [key: string]: string;
            };
            /** @description APIVersion defines the versioned schema of this representation of an object.
             *     Servers should convert recognized schemas to the latest internal value, and
             *     may reject unrecognized values.
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             *     +optional */
            apiVersion?: string;
            /** @description Metrics for all containers are collected within the same time window. */
            containers?: components["schemas"]["v1beta1.ContainerMetrics"][];
            /** @description CreationTimestamp is a timestamp representing the server time when this object was
             *     created. It is not guaranteed to be set in happens-before order across separate operations.
             *     Clients may not set this value. It is represented in RFC3339 form and is in UTC.
             *
             *     Populated by the system.
             *     Read-only.
             *     Null for lists.
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             *     +optional */
            creationTimestamp?: string;
            /** @description Number of seconds allowed for this object to gracefully terminate before
             *     it will be removed from the system. Only set when deletionTimestamp is also set.
             *     May only be shortened.
             *     Read-only.
             *     +optional */
            deletionGracePeriodSeconds?: number;
            /** @description DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This
             *     field is set by the server when a graceful deletion is requested by the user, and is not
             *     directly settable by a client. The resource is expected to be deleted (no longer visible
             *     from resource lists, and not reachable by name) after the time in this field, once the
             *     finalizers list is empty. As long as the finalizers list contains items, deletion is blocked.
             *     Once the deletionTimestamp is set, this value may not be unset or be set further into the
             *     future, although it may be shortened or the resource may be deleted prior to this time.
             *     For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react
             *     by sending a graceful termination signal to the containers in the pod. After that 30 seconds,
             *     the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup,
             *     remove the pod from the API. In the presence of network partitions, this object may still
             *     exist after this timestamp, until an administrator or automated process can determine the
             *     resource is fully terminated.
             *     If not set, graceful deletion of the object has not been requested.
             *
             *     Populated by the system when a graceful deletion is requested.
             *     Read-only.
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             *     +optional */
            deletionTimestamp?: string;
            /** @description Must be empty before the object is deleted from the registry. Each entry
             *     is an identifier for the responsible component that will remove the entry
             *     from the list. If the deletionTimestamp of the object is non-nil, entries
             *     in this list can only be removed.
             *     Finalizers may be processed and removed in any order.  Order is NOT enforced
             *     because it introduces significant risk of stuck finalizers.
             *     finalizers is a shared field, any actor with permission can reorder it.
             *     If the finalizer list is processed in order, then this can lead to a situation
             *     in which the component responsible for the first finalizer in the list is
             *     waiting for a signal (field value, external system, or other) produced by a
             *     component responsible for a finalizer later in the list, resulting in a deadlock.
             *     Without enforced ordering finalizers are free to order amongst themselves and
             *     are not vulnerable to ordering changes in the list.
             *     +optional
             *     +patchStrategy=merge */
            finalizers?: string[];
            /** @description GenerateName is an optional prefix, used by the server, to generate a unique
             *     name ONLY IF the Name field has not been provided.
             *     If this field is used, the name returned to the client will be different
             *     than the name passed. This value will also be combined with a unique suffix.
             *     The provided value has the same validation rules as the Name field,
             *     and may be truncated by the length of the suffix required to make the value
             *     unique on the server.
             *
             *     If this field is specified and the generated name exists, the server will return a 409.
             *
             *     Applied only if Name is not specified.
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency
             *     +optional */
            generateName?: string;
            /** @description A sequence number representing a specific generation of the desired state.
             *     Populated by the system. Read-only.
             *     +optional */
            generation?: number;
            /** @description Kind is a string value representing the REST resource this object represents.
             *     Servers may infer this from the endpoint the client submits requests to.
             *     Cannot be updated.
             *     In CamelCase.
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             *     +optional */
            kind?: string;
            /** @description Map of string keys and values that can be used to organize and categorize
             *     (scope and select) objects. May match selectors of replication controllers
             *     and services.
             *     More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
             *     +optional */
            labels?: {
                [key: string]: string;
            };
            /** @description ManagedFields maps workflow-id and version to the set of fields
             *     that are managed by that workflow. This is mostly for internal
             *     housekeeping, and users typically shouldn't need to set or
             *     understand this field. A workflow can be the user's name, a
             *     controller's name, or the name of a specific apply path like
             *     "ci-cd". The set of fields is always in the version that the
             *     workflow used when modifying the object.
             *
             *     +optional */
            managedFields?: components["schemas"]["v1.ManagedFieldsEntry"][];
            /** @description Name must be unique within a namespace. Is required when creating resources, although
             *     some resources may allow a client to request the generation of an appropriate name
             *     automatically. Name is primarily intended for creation idempotence and configuration
             *     definition.
             *     Cannot be updated.
             *     More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
             *     +optional */
            name?: string;
            /** @description Namespace defines the space within which each name must be unique. An empty namespace is
             *     equivalent to the "default" namespace, but "default" is the canonical representation.
             *     Not all objects are required to be scoped to a namespace - the value of this field for
             *     those objects will be empty.
             *
             *     Must be a DNS_LABEL.
             *     Cannot be updated.
             *     More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces
             *     +optional */
            namespace?: string;
            /** @description List of objects depended by this object. If ALL objects in the list have
             *     been deleted, this object will be garbage collected. If this object is managed by a controller,
             *     then an entry in this list will point to this controller, with the controller field set to true.
             *     There cannot be more than one managing controller.
             *     +optional
             *     +patchMergeKey=uid
             *     +patchStrategy=merge */
            ownerReferences?: components["schemas"]["v1.OwnerReference"][];
            /** @description An opaque value that represents the internal version of this object that can
             *     be used by clients to determine when objects have changed. May be used for optimistic
             *     concurrency, change detection, and the watch operation on a resource or set of resources.
             *     Clients must treat these values as opaque and passed unmodified back to the server.
             *     They may only be valid for a particular resource or set of resources.
             *
             *     Populated by the system.
             *     Read-only.
             *     Value must be treated as opaque by clients and .
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             *     +optional */
            resourceVersion?: string;
            /** @description Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.
             *     +optional */
            selfLink?: string;
            /** @description The following fields define time interval from which metrics were
             *     collected from the interval [Timestamp-Window, Timestamp]. */
            timestamp?: string;
            /** @description UID is the unique in time and space value for this object. It is typically generated by
             *     the server on successful creation of a resource and is not allowed to change on PUT
             *     operations.
             *
             *     Populated by the system.
             *     Read-only.
             *     More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
             *     +optional */
            uid?: string;
            window?: components["schemas"]["v1.Duration"];
        };
        "v1beta1.PodMetricsList": {
            /** @description APIVersion defines the versioned schema of this representation of an object.
             *     Servers should convert recognized schemas to the latest internal value, and
             *     may reject unrecognized values.
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             *     +optional */
            apiVersion?: string;
            /** @description continue may be set if the user set a limit on the number of items returned, and indicates that
             *     the server has more data available. The value is opaque and may be used to issue another request
             *     to the endpoint that served this list to retrieve the next set of available objects. Continuing a
             *     consistent list may not be possible if the server configuration has changed or more than a few
             *     minutes have passed. The resourceVersion field returned when using this continue value will be
             *     identical to the value in the first response, unless you have received this token from an error
             *     message. */
            continue?: string;
            /** @description List of pod metrics. */
            items?: components["schemas"]["v1beta1.PodMetrics"][];
            /** @description Kind is a string value representing the REST resource this object represents.
             *     Servers may infer this from the endpoint the client submits requests to.
             *     Cannot be updated.
             *     In CamelCase.
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             *     +optional */
            kind?: string;
            /** @description remainingItemCount is the number of subsequent items in the list which are not included in this
             *     list response. If the list request contained label or field selectors, then the number of
             *     remaining items is unknown and the field will be left unset and omitted during serialization.
             *     If the list is complete (either because it is not chunking or because this is the last chunk),
             *     then there are no more remaining items and this field will be left unset and omitted during
             *     serialization.
             *     Servers older than v1.15 do not set this field.
             *     The intended use of the remainingItemCount is *estimating* the size of a collection. Clients
             *     should not rely on the remainingItemCount to be set or to be exact.
             *     +optional */
            remainingItemCount?: number;
            /** @description String that identifies the server's internal version of this object that
             *     can be used by clients to determine when objects have changed.
             *     Value must be treated as opaque by clients and passed unmodified back to the server.
             *     Populated by the system.
             *     Read-only.
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             *     +optional */
            resourceVersion?: string;
            /** @description Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.
             *     +optional */
            selfLink?: string;
        };
        "v2.ContainerResourceMetricSource": {
            /** @description container is the name of the container in the pods of the scaling target */
            container?: string;
            /** @description name is the name of the resource in question. */
            name?: string;
            target?: components["schemas"]["v2.MetricTarget"];
        };
        "v2.ContainerResourceMetricStatus": {
            /** @description container is the name of the container in the pods of the scaling target */
            container?: string;
            current?: components["schemas"]["v2.MetricValueStatus"];
            /** @description name is the name of the resource in question. */
            name?: string;
        };
        "v2.CrossVersionObjectReference": {
            /** @description apiVersion is the API version of the referent
             *     +optional */
            apiVersion?: string;
            /** @description kind is the kind of the referent; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
            kind?: string;
            /** @description name is the name of the referent; More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names */
            name?: string;
        };
        "v2.ExternalMetricSource": {
            metric?: components["schemas"]["v2.MetricIdentifier"];
            target?: components["schemas"]["v2.MetricTarget"];
        };
        "v2.ExternalMetricStatus": {
            current?: components["schemas"]["v2.MetricValueStatus"];
            metric?: components["schemas"]["v2.MetricIdentifier"];
        };
        "v2.HPAScalingPolicy": {
            /** @description periodSeconds specifies the window of time for which the policy should hold true.
             *     PeriodSeconds must be greater than zero and less than or equal to 1800 (30 min). */
            periodSeconds?: number;
            /** @description type is used to specify the scaling policy. */
            type?: string;
            /** @description value contains the amount of change which is permitted by the policy.
             *     It must be greater than zero */
            value?: number;
        };
        "v2.HPAScalingRules": {
            /** @description policies is a list of potential scaling polices which can be used during scaling.
             *     At least one policy must be specified, otherwise the HPAScalingRules will be discarded as invalid
             *     +listType=atomic
             *     +optional */
            policies?: components["schemas"]["v2.HPAScalingPolicy"][];
            /** @description selectPolicy is used to specify which policy should be used.
             *     If not set, the default value Max is used.
             *     +optional */
            selectPolicy?: string;
            /** @description stabilizationWindowSeconds is the number of seconds for which past recommendations should be
             *     considered while scaling up or scaling down.
             *     StabilizationWindowSeconds must be greater than or equal to zero and less than or equal to 3600 (one hour).
             *     If not set, use the default values:
             *     - For scale up: 0 (i.e. no stabilization is done).
             *     - For scale down: 300 (i.e. the stabilization window is 300 seconds long).
             *     +optional */
            stabilizationWindowSeconds?: number;
        };
        "v2.HorizontalPodAutoscaler": {
            /** @description Annotations is an unstructured key value map stored with a resource that may be
             *     set by external tools to store and retrieve arbitrary metadata. They are not
             *     queryable and should be preserved when modifying objects.
             *     More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
             *     +optional */
            annotations?: {
                [key: string]: string;
            };
            /** @description APIVersion defines the versioned schema of this representation of an object.
             *     Servers should convert recognized schemas to the latest internal value, and
             *     may reject unrecognized values.
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             *     +optional */
            apiVersion?: string;
            /** @description CreationTimestamp is a timestamp representing the server time when this object was
             *     created. It is not guaranteed to be set in happens-before order across separate operations.
             *     Clients may not set this value. It is represented in RFC3339 form and is in UTC.
             *
             *     Populated by the system.
             *     Read-only.
             *     Null for lists.
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             *     +optional */
            creationTimestamp?: string;
            /** @description Number of seconds allowed for this object to gracefully terminate before
             *     it will be removed from the system. Only set when deletionTimestamp is also set.
             *     May only be shortened.
             *     Read-only.
             *     +optional */
            deletionGracePeriodSeconds?: number;
            /** @description DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This
             *     field is set by the server when a graceful deletion is requested by the user, and is not
             *     directly settable by a client. The resource is expected to be deleted (no longer visible
             *     from resource lists, and not reachable by name) after the time in this field, once the
             *     finalizers list is empty. As long as the finalizers list contains items, deletion is blocked.
             *     Once the deletionTimestamp is set, this value may not be unset or be set further into the
             *     future, although it may be shortened or the resource may be deleted prior to this time.
             *     For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react
             *     by sending a graceful termination signal to the containers in the pod. After that 30 seconds,
             *     the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup,
             *     remove the pod from the API. In the presence of network partitions, this object may still
             *     exist after this timestamp, until an administrator or automated process can determine the
             *     resource is fully terminated.
             *     If not set, graceful deletion of the object has not been requested.
             *
             *     Populated by the system when a graceful deletion is requested.
             *     Read-only.
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             *     +optional */
            deletionTimestamp?: string;
            /** @description Must be empty before the object is deleted from the registry. Each entry
             *     is an identifier for the responsible component that will remove the entry
             *     from the list. If the deletionTimestamp of the object is non-nil, entries
             *     in this list can only be removed.
             *     Finalizers may be processed and removed in any order.  Order is NOT enforced
             *     because it introduces significant risk of stuck finalizers.
             *     finalizers is a shared field, any actor with permission can reorder it.
             *     If the finalizer list is processed in order, then this can lead to a situation
             *     in which the component responsible for the first finalizer in the list is
             *     waiting for a signal (field value, external system, or other) produced by a
             *     component responsible for a finalizer later in the list, resulting in a deadlock.
             *     Without enforced ordering finalizers are free to order amongst themselves and
             *     are not vulnerable to ordering changes in the list.
             *     +optional
             *     +patchStrategy=merge */
            finalizers?: string[];
            /** @description GenerateName is an optional prefix, used by the server, to generate a unique
             *     name ONLY IF the Name field has not been provided.
             *     If this field is used, the name returned to the client will be different
             *     than the name passed. This value will also be combined with a unique suffix.
             *     The provided value has the same validation rules as the Name field,
             *     and may be truncated by the length of the suffix required to make the value
             *     unique on the server.
             *
             *     If this field is specified and the generated name exists, the server will return a 409.
             *
             *     Applied only if Name is not specified.
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency
             *     +optional */
            generateName?: string;
            /** @description A sequence number representing a specific generation of the desired state.
             *     Populated by the system. Read-only.
             *     +optional */
            generation?: number;
            /** @description Kind is a string value representing the REST resource this object represents.
             *     Servers may infer this from the endpoint the client submits requests to.
             *     Cannot be updated.
             *     In CamelCase.
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             *     +optional */
            kind?: string;
            /** @description Map of string keys and values that can be used to organize and categorize
             *     (scope and select) objects. May match selectors of replication controllers
             *     and services.
             *     More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
             *     +optional */
            labels?: {
                [key: string]: string;
            };
            /** @description ManagedFields maps workflow-id and version to the set of fields
             *     that are managed by that workflow. This is mostly for internal
             *     housekeeping, and users typically shouldn't need to set or
             *     understand this field. A workflow can be the user's name, a
             *     controller's name, or the name of a specific apply path like
             *     "ci-cd". The set of fields is always in the version that the
             *     workflow used when modifying the object.
             *
             *     +optional */
            managedFields?: components["schemas"]["v1.ManagedFieldsEntry"][];
            /** @description Name must be unique within a namespace. Is required when creating resources, although
             *     some resources may allow a client to request the generation of an appropriate name
             *     automatically. Name is primarily intended for creation idempotence and configuration
             *     definition.
             *     Cannot be updated.
             *     More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
             *     +optional */
            name?: string;
            /** @description Namespace defines the space within which each name must be unique. An empty namespace is
             *     equivalent to the "default" namespace, but "default" is the canonical representation.
             *     Not all objects are required to be scoped to a namespace - the value of this field for
             *     those objects will be empty.
             *
             *     Must be a DNS_LABEL.
             *     Cannot be updated.
             *     More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces
             *     +optional */
            namespace?: string;
            /** @description List of objects depended by this object. If ALL objects in the list have
             *     been deleted, this object will be garbage collected. If this object is managed by a controller,
             *     then an entry in this list will point to this controller, with the controller field set to true.
             *     There cannot be more than one managing controller.
             *     +optional
             *     +patchMergeKey=uid
             *     +patchStrategy=merge */
            ownerReferences?: components["schemas"]["v1.OwnerReference"][];
            /** @description An opaque value that represents the internal version of this object that can
             *     be used by clients to determine when objects have changed. May be used for optimistic
             *     concurrency, change detection, and the watch operation on a resource or set of resources.
             *     Clients must treat these values as opaque and passed unmodified back to the server.
             *     They may only be valid for a particular resource or set of resources.
             *
             *     Populated by the system.
             *     Read-only.
             *     Value must be treated as opaque by clients and .
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             *     +optional */
            resourceVersion?: string;
            /** @description Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.
             *     +optional */
            selfLink?: string;
            spec?: components["schemas"]["v2.HorizontalPodAutoscalerSpec"];
            status?: components["schemas"]["v2.HorizontalPodAutoscalerStatus"];
            /** @description UID is the unique in time and space value for this object. It is typically generated by
             *     the server on successful creation of a resource and is not allowed to change on PUT
             *     operations.
             *
             *     Populated by the system.
             *     Read-only.
             *     More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
             *     +optional */
            uid?: string;
        };
        "v2.HorizontalPodAutoscalerBehavior": {
            scaleDown?: components["schemas"]["v2.HPAScalingRules"];
            scaleUp?: components["schemas"]["v2.HPAScalingRules"];
        };
        "v2.HorizontalPodAutoscalerCondition": {
            /** @description lastTransitionTime is the last time the condition transitioned from
             *     one status to another
             *     +optional */
            lastTransitionTime?: string;
            /** @description message is a human-readable explanation containing details about
             *     the transition
             *     +optional */
            message?: string;
            /** @description reason is the reason for the condition's last transition.
             *     +optional */
            reason?: string;
            /** @description status is the status of the condition (True, False, Unknown) */
            status?: string;
            /** @description type describes the current condition */
            type?: string;
        };
        "v2.HorizontalPodAutoscalerSpec": {
            behavior?: components["schemas"]["v2.HorizontalPodAutoscalerBehavior"];
            /** @description maxReplicas is the upper limit for the number of replicas to which the autoscaler can scale up.
             *     It cannot be less that minReplicas. */
            maxReplicas?: number;
            /** @description metrics contains the specifications for which to use to calculate the
             *     desired replica count (the maximum replica count across all metrics will
             *     be used).  The desired replica count is calculated multiplying the
             *     ratio between the target value and the current value by the current
             *     number of pods.  Ergo, metrics used must decrease as the pod count is
             *     increased, and vice-versa.  See the individual metric source types for
             *     more information about how each type of metric must respond.
             *     If not set, the default metric will be set to 80% average CPU utilization.
             *     +listType=atomic
             *     +optional */
            metrics?: components["schemas"]["v2.MetricSpec"][];
            /** @description minReplicas is the lower limit for the number of replicas to which the autoscaler
             *     can scale down.  It defaults to 1 pod.  minReplicas is allowed to be 0 if the
             *     alpha feature gate HPAScaleToZero is enabled and at least one Object or External
             *     metric is configured.  Scaling is active as long as at least one metric value is
             *     available.
             *     +optional */
            minReplicas?: number;
            scaleTargetRef?: components["schemas"]["v2.CrossVersionObjectReference"];
        };
        "v2.HorizontalPodAutoscalerStatus": {
            /** @description conditions is the set of conditions required for this autoscaler to scale its target,
             *     and indicates whether or not those conditions are met.
             *     +patchMergeKey=type
             *     +patchStrategy=merge
             *     +listType=map
             *     +listMapKey=type
             *     +optional */
            conditions?: components["schemas"]["v2.HorizontalPodAutoscalerCondition"][];
            /** @description currentMetrics is the last read state of the metrics used by this autoscaler.
             *     +listType=atomic
             *     +optional */
            currentMetrics?: components["schemas"]["v2.MetricStatus"][];
            /** @description currentReplicas is current number of replicas of pods managed by this autoscaler,
             *     as last seen by the autoscaler.
             *     +optional */
            currentReplicas?: number;
            /** @description desiredReplicas is the desired number of replicas of pods managed by this autoscaler,
             *     as last calculated by the autoscaler. */
            desiredReplicas?: number;
            /** @description lastScaleTime is the last time the HorizontalPodAutoscaler scaled the number of pods,
             *     used by the autoscaler to control how often the number of pods is changed.
             *     +optional */
            lastScaleTime?: string;
            /** @description observedGeneration is the most recent generation observed by this autoscaler.
             *     +optional */
            observedGeneration?: number;
        };
        "v2.MetricIdentifier": {
            /** @description name is the name of the given metric */
            name?: string;
            selector?: components["schemas"]["v1.LabelSelector"];
        };
        "v2.MetricSpec": {
            containerResource?: components["schemas"]["v2.ContainerResourceMetricSource"];
            external?: components["schemas"]["v2.ExternalMetricSource"];
            object?: components["schemas"]["v2.ObjectMetricSource"];
            pods?: components["schemas"]["v2.PodsMetricSource"];
            resource?: components["schemas"]["v2.ResourceMetricSource"];
            /** @description type is the type of metric source.  It should be one of "ContainerResource", "External",
             *     "Object", "Pods" or "Resource", each mapping to a matching field in the object.
             *     Note: "ContainerResource" type is available on when the feature-gate
             *     HPAContainerMetrics is enabled */
            type?: string;
        };
        "v2.MetricStatus": {
            containerResource?: components["schemas"]["v2.ContainerResourceMetricStatus"];
            external?: components["schemas"]["v2.ExternalMetricStatus"];
            object?: components["schemas"]["v2.ObjectMetricStatus"];
            pods?: components["schemas"]["v2.PodsMetricStatus"];
            resource?: components["schemas"]["v2.ResourceMetricStatus"];
            /** @description type is the type of metric source.  It will be one of "ContainerResource", "External",
             *     "Object", "Pods" or "Resource", each corresponds to a matching field in the object.
             *     Note: "ContainerResource" type is available on when the feature-gate
             *     HPAContainerMetrics is enabled */
            type?: string;
        };
        "v2.MetricTarget": {
            /** @description averageUtilization is the target value of the average of the
             *     resource metric across all relevant pods, represented as a percentage of
             *     the requested value of the resource for the pods.
             *     Currently only valid for Resource metric source type
             *     +optional */
            averageUtilization?: number;
            averageValue?: components["schemas"]["resource.Quantity"];
            /** @description type represents whether the metric type is Utilization, Value, or AverageValue */
            type?: string;
            value?: components["schemas"]["resource.Quantity"];
        };
        "v2.MetricValueStatus": {
            /** @description currentAverageUtilization is the current value of the average of the
             *     resource metric across all relevant pods, represented as a percentage of
             *     the requested value of the resource for the pods.
             *     +optional */
            averageUtilization?: number;
            averageValue?: components["schemas"]["resource.Quantity"];
            value?: components["schemas"]["resource.Quantity"];
        };
        "v2.ObjectMetricSource": {
            describedObject?: components["schemas"]["v2.CrossVersionObjectReference"];
            metric?: components["schemas"]["v2.MetricIdentifier"];
            target?: components["schemas"]["v2.MetricTarget"];
        };
        "v2.ObjectMetricStatus": {
            current?: components["schemas"]["v2.MetricValueStatus"];
            describedObject?: components["schemas"]["v2.CrossVersionObjectReference"];
            metric?: components["schemas"]["v2.MetricIdentifier"];
        };
        "v2.PodsMetricSource": {
            metric?: components["schemas"]["v2.MetricIdentifier"];
            target?: components["schemas"]["v2.MetricTarget"];
        };
        "v2.PodsMetricStatus": {
            current?: components["schemas"]["v2.MetricValueStatus"];
            metric?: components["schemas"]["v2.MetricIdentifier"];
        };
        "v2.ResourceMetricSource": {
            /** @description name is the name of the resource in question. */
            name?: string;
            target?: components["schemas"]["v2.MetricTarget"];
        };
        "v2.ResourceMetricStatus": {
            current?: components["schemas"]["v2.MetricValueStatus"];
            /** @description name is the name of the resource in question. */
            name?: string;
        };
        "webhooks.webhookCreatePayload": {
            /**
             * @description Environment(Endpoint) identifier. Reference the environment(endpoint) that will be used for deployment
             * @example 1
             */
            endpointID?: number;
            /**
             * @description Registry Identifier
             * @example 1
             */
            registryID?: number;
            resourceID?: string;
            /** @description Type of webhook (1 - service) */
            webhookType?: number;
        };
        "webhooks.webhookUpdatePayload": {
            /** @description Registry Identifier */
            registryID?: number;
        };
    };
    responses: never;
    parameters: never;
    requestBodies: {
        /** @description Ingress controllers */
        "kubernetes.K8sIngressControllerArray": {
            content: {
                "application/json": components["schemas"]["kubernetes.K8sIngressController"][];
            };
        };
        /** @description List of environments to delete, with optional deleteCluster flag to clean-up associated resources (cloud environments only) */
        "endpoints.endpointDeleteBatchPayload": {
            content: {
                "application/json": components["schemas"]["endpoints.endpointDeleteBatchPayload"];
            };
        };
        /** @description Namespace details */
        "kubernetes.K8sNamespaceDetails": {
            content: {
                "application/json": components["schemas"]["kubernetes.K8sNamespaceDetails"];
            };
        };
        /** @description Ingress details */
        "kubernetes.K8sIngressInfo": {
            content: {
                "application/json": components["schemas"]["kubernetes.K8sIngressInfo"];
            };
        };
        /** @description Service definition */
        "kubernetes.K8sServiceInfo": {
            content: {
                "application/json": components["schemas"]["kubernetes.K8sServiceInfo"];
            };
        };
    };
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    AuthenticateUser: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Credentials used for authentication */
        requestBody: {
            content: {
                "application/json": components["schemas"]["auth.authenticatePayload"];
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["auth.authenticateResponse"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invalid Credentials */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    Logout: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    ValidateOAuth: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description OAuth Credentials used for authentication */
        requestBody: {
            content: {
                "application/json": components["schemas"]["auth.oauthPayload"];
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["auth.authenticateResponse"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invalid Credentials */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    Backup: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description An object contains the password to encrypt the backup with */
        requestBody?: {
            content: {
                "application/json": components["schemas"]["backup.backupPayload"];
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    CustomTemplateList: {
        parameters: {
            query: {
                /** @description Template types */
                type: (1 | 2 | 3)[];
                /** @description Filter by edge templates */
                edge?: boolean;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.CustomTemplate"][];
                };
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    CustomTemplateInspect: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Template identifier */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.CustomTemplate"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Template not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    CustomTemplateUpdate: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Template identifier */
                id: number;
            };
            cookie?: never;
        };
        /** @description Template details */
        requestBody: {
            content: {
                "application/json": components["schemas"]["customtemplates.customTemplateUpdatePayload"];
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.CustomTemplate"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied to access template */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Template not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    CustomTemplateDelete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Template identifier */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Access denied to resource */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Template not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    CustomTemplateFile: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Template identifier */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["customtemplates.fileResponse"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Custom template not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    CustomTemplateGitFetch: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Template identifier */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["customtemplates.fileResponse"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Custom template not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    CustomTemplateCreateFile: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "multipart/form-data": {
                    /** @description Title of the template */
                    Title: string;
                    /** @description Description of the template */
                    Description: string;
                    /** @description A note that will be displayed in the UI. Supports HTML content */
                    Note: string;
                    /**
                     * @description Platform associated to the template (1 - 'linux', 2 - 'windows')
                     * @enum {integer}
                     */
                    Platform: 1 | 2;
                    /**
                     * @description Type of created stack (1 - swarm, 2 - compose, 3 - kubernetes)
                     * @enum {integer}
                     */
                    Type: 1 | 2 | 3;
                    /**
                     * Format: binary
                     * @description File
                     */
                    File: string;
                    /** @description URL of the template's logo */
                    Logo?: string;
                    /** @description A json array of variables definitions */
                    Variables?: string;
                };
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.CustomTemplate"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    CustomTemplateCreateRepository: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Required when using method=repository */
        requestBody: {
            content: {
                "application/json": components["schemas"]["customtemplates.customTemplateFromGitRepositoryPayload"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.CustomTemplate"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    CustomTemplateCreateString: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["customtemplates.customTemplateFromFileContentPayload"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.CustomTemplate"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    dockerContainerGpusInspect: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Environment identifier */
                environmentId: number;
                /** @description Container identifier */
                containerId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["containers.containerGpusResponse"];
                };
            };
            /** @description Bad request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Environment or container not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    dockerDashboard: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Environment identifier */
                environmentId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["docker.dashboardResponse"];
                };
            };
            /** @description Bad request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    dockerImagesList: {
        parameters: {
            query?: {
                /** @description Include image usage information */
                withUsage?: boolean;
            };
            header?: never;
            path: {
                /** @description Environment identifier */
                environmentId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["images.ImageResponse"][];
                };
            };
            /** @description Bad request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    EdgeGroupList: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description EdgeGroups */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["edgegroups.decoratedEdgeGroup"][];
                };
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Edge compute features are disabled */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    EdgeGroupCreate: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description EdgeGroup data */
        requestBody: {
            content: {
                "application/json": components["schemas"]["edgegroups.edgeGroupCreatePayload"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.EdgeGroup"];
                };
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Edge compute features are disabled */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    EdgeGroupInspect: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description EdgeGroup Id */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.EdgeGroup"];
                };
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Edge compute features are disabled */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    EgeGroupUpdate: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description EdgeGroup Id */
                id: number;
            };
            cookie?: never;
        };
        /** @description EdgeGroup data */
        requestBody: {
            content: {
                "application/json": components["schemas"]["edgegroups.edgeGroupUpdatePayload"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.EdgeGroup"];
                };
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Edge compute features are disabled */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    EdgeGroupDelete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description EdgeGroup Id */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description No Content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Edge group is in use by an Edge stack or Edge job */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Edge compute features are disabled */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    EdgeJobList: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.EdgeJob"][];
                };
            };
            /** @description Bad Request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Edge compute features are disabled */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    EdgeJobInspect: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description EdgeJob Id */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.EdgeJob"];
                };
            };
            /** @description Bad Request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Edge compute features are disabled */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    EdgeJobUpdate: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description EdgeJob Id */
                id: number;
            };
            cookie?: never;
        };
        /** @description EdgeGroup data */
        requestBody: {
            content: {
                "application/json": components["schemas"]["edgejobs.edgeJobUpdatePayload"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.EdgeJob"];
                };
            };
            /** @description Bad Request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Edge compute features are disabled */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    EdgeJobDelete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description EdgeJob Id */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description No Content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Bad Request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Edge compute features are disabled */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    EdgeJobFile: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description EdgeJob Id */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["edgejobs.edgeJobFileResponse"];
                };
            };
            /** @description Bad Request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Edge compute features are disabled */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    EdgeJobTasksList: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description EdgeJob Id */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["edgejobs.taskContainer"][];
                };
            };
            /** @description Bad Request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Edge compute features are disabled */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    EdgeJobTaskLogsInspect: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description EdgeJob Id */
                id: number;
                /** @description Task Id */
                taskID: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["edgejobs.fileResponse"];
                };
            };
            /** @description Bad Request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Edge compute features are disabled */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    EdgeJobTasksCollect: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description EdgeJob Id */
                id: number;
                /** @description Task Id */
                taskID: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description No Content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Bad Request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Edge compute features are disabled */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    EdgeJobTasksClear: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description EdgeJob Id */
                id: number;
                /** @description Task Id */
                taskID: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description No Content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Bad Request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Edge compute features are disabled */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    EdgeJobCreateFile: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "multipart/form-data": {
                    /**
                     * Format: binary
                     * @description Content of the Stack file
                     */
                    file: string;
                    /** @description Name of the stack */
                    Name: string;
                    /** @description A cron expression to schedule this job */
                    CronExpression: string;
                    /** @description JSON stringified array of Edge Groups ids */
                    EdgeGroups: string;
                    /** @description JSON stringified array of Environment ids */
                    Endpoints: string;
                    /** @description If recurring */
                    Recurring?: boolean;
                };
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.EdgeGroup"];
                };
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Edge compute features are disabled */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    EdgeJobCreateString: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description EdgeGroup data when method is string */
        requestBody: {
            content: {
                "application/json": components["schemas"]["edgejobs.edgeJobCreateFromFileContentPayload"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.EdgeGroup"];
                };
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Edge compute features are disabled */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    EdgeStackList: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.EdgeStack"][];
                };
            };
            /** @description Bad Request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Edge compute features are disabled */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    EdgeStackInspect: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description EdgeStack Id */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.EdgeStack"];
                };
            };
            /** @description Bad Request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Edge compute features are disabled */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    EdgeStackUpdate: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description EdgeStack Id */
                id: number;
            };
            cookie?: never;
        };
        /** @description EdgeStack data */
        requestBody: {
            content: {
                "application/json": components["schemas"]["edgestacks.updateEdgeStackPayload"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.EdgeStack"];
                };
            };
            /** @description Bad Request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Edge compute features are disabled */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    EdgeStackDelete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description EdgeStack Id */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description No Content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Bad Request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Edge compute features are disabled */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    EdgeStackFile: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description EdgeStack Id */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["edgestacks.stackFileResponse"];
                };
            };
            /** @description Bad Request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Edge compute features are disabled */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    EdgeStackStatusUpdate: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description EdgeStack Id */
                id: number;
            };
            cookie?: never;
        };
        /** @description EdgeStack status payload */
        requestBody: {
            content: {
                "application/json": components["schemas"]["edgestacks.updateStatusPayload"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.EdgeStack"];
                };
            };
            /** @description Bad Request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Forbidden */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Not Found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    EdgeStackCreateFile: {
        parameters: {
            query?: {
                /** @description if true, will not create an edge stack, but just will check the settings and return a non-persisted edge stack object */
                dryrun?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "multipart/form-data": {
                    /** @description Name of the stack. it must only consist of lowercase alphanumeric characters, hyphens, or underscores as well as start with a letter or number */
                    Name: string;
                    /**
                     * Format: binary
                     * @description Content of the Stack file
                     */
                    file: string;
                    /** @description JSON stringified array of Edge Groups ids */
                    EdgeGroups: string;
                    /** @description deploy type 0 - 'compose', 1 - 'kubernetes' */
                    DeploymentType: number;
                    /** @description JSON stringified array of Registry ids to use for this stack */
                    Registries?: string;
                    /** @description Uses the manifest's namespaces instead of the default one, relevant only for kube environments */
                    UseManifestNamespaces?: boolean;
                    /** @description Pre Pull image */
                    PrePullImage?: boolean;
                    /** @description Retry deploy */
                    RetryDeploy?: boolean;
                };
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.EdgeStack"];
                };
            };
            /** @description Bad request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Edge compute features are disabled */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    EdgeStackCreateRepository: {
        parameters: {
            query?: {
                /** @description if true, will not create an edge stack, but just will check the settings and return a non-persisted edge stack object */
                dryrun?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description stack config */
        requestBody: {
            content: {
                "application/json": components["schemas"]["edgestacks.edgeStackFromGitRepositoryPayload"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.EdgeStack"];
                };
            };
            /** @description Bad request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Edge compute features are disabled */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    EdgeStackCreateString: {
        parameters: {
            query?: {
                /** @description if true, will not create an edge stack, but just will check the settings and return a non-persisted edge stack object */
                dryrun?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description stack config */
        requestBody: {
            content: {
                "application/json": components["schemas"]["edgestacks.edgeStackFromStringPayload"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.EdgeStack"];
                };
            };
            /** @description Bad request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Edge compute features are disabled */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    EndpointGroupList: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Environment(Endpoint) group */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.EndpointGroup"][];
                };
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    EndpointGroupUpdate: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description EndpointGroup identifier */
                id: number;
            };
            cookie?: never;
        };
        /** @description EndpointGroup details */
        requestBody: {
            content: {
                "application/json": components["schemas"]["endpointgroups.endpointGroupUpdatePayload"];
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.EndpointGroup"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description EndpointGroup not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    EndpointGroupDelete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description EndpointGroup identifier */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description EndpointGroup not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    EndpointGroupAddEndpoint: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description EndpointGroup identifier */
                id: number;
                /** @description Environment(Endpoint) identifier */
                endpointId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description EndpointGroup not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    EndpointGroupDeleteEndpoint: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description EndpointGroup identifier */
                id: number;
                /** @description Environment(Endpoint) identifier */
                endpointId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description EndpointGroup not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    EndpointList: {
        parameters: {
            query?: {
                /** @description Start searching from */
                start?: number;
                /** @description Limit results to this value */
                limit?: number;
                /** @description Order sorted results by desc/asc */
                order?: number;
                /** @description Search query */
                search?: string;
                /** @description List environments(endpoints) of these groups */
                groupIds?: number[];
                /** @description List environments(endpoints) by this status */
                status?: number[];
                /** @description List environments(endpoints) of this type */
                types?: number[];
                /** @description search environments(endpoints) with these tags (depends on tagsPartialMatch) */
                tagIds?: number[];
                /** @description If true, will return environment(endpoint) which has one of tagIds, if false (or missing) will return only environments(endpoints) that has all the tags */
                tagsPartialMatch?: boolean;
                /** @description will return only these environments(endpoints) */
                endpointIds?: number[];
                /** @description If true, will return environment(endpoint) that were provisioned */
                provisioned?: boolean;
                /** @description will return only environments with on of these agent versions */
                agentVersions?: string[];
                /** @description if exists true show only edge async agents, false show only standard edge agents. if missing, will show both types (relevant only for edge agents) */
                edgeAsync?: boolean;
                /** @description if true, show only untrusted edge agents, if false show only trusted edge agents (relevant only for edge agents) */
                edgeDeviceUntrusted?: boolean;
                /** @description if bigger then zero, show only edge agents that checked-in in the last provided seconds (relevant only for edge agents) */
                edgeCheckInPassedSeconds?: number;
                /** @description if true, the snapshot data won't be retrieved */
                excludeSnapshots?: boolean;
                /** @description will return only environments(endpoints) with this name */
                name?: string;
                /** @description only applied when edgeStackId exists. Filter the returned environments based on their deployment status in the stack (not the environment status!) */
                edgeStackStatus?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Endpoints */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.Endpoint"][];
                };
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    EndpointCreate: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "multipart/form-data": {
                    /** @description Name that will be used to identify this environment(endpoint) (example: my-environment) */
                    Name: string;
                    /** @description Environment(Endpoint) type. Value must be one of: 1 (Local Docker environment), 2 (Agent environment), 3 (Azure environment), 4 (Edge agent environment) or 5 (Local Kubernetes Environment) */
                    EndpointCreationType: number;
                    /** @description Container engine used by the environment(endpoint). Value must be one of: 'docker' or 'podman' */
                    ContainerEngine?: string;
                    /** @description URL or IP address of a Docker host (example: docker.mydomain.tld:2375). Defaults to local if not specified (Linux: /var/run/docker.sock, Windows: //./pipe/docker_engine). Cannot be empty if EndpointCreationType is set to 4 (Edge agent environment) */
                    URL?: string;
                    /** @description URL or IP address where exposed containers will be reachable. Defaults to URL if not specified (example: docker.mydomain.tld:2375) */
                    PublicURL?: string;
                    /** @description Environment(Endpoint) group identifier. If not specified will default to 1 (unassigned). */
                    GroupID?: number;
                    /** @description Require TLS to connect against this environment(endpoint). Must be true if EndpointCreationType is set to 2 (Agent environment) */
                    TLS?: boolean;
                    /** @description Skip server verification when using TLS. Must be true if EndpointCreationType is set to 2 (Agent environment) */
                    TLSSkipVerify?: boolean;
                    /** @description Skip client verification when using TLS. Must be true if EndpointCreationType is set to 2 (Agent environment) */
                    TLSSkipClientVerify?: boolean;
                    /**
                     * Format: binary
                     * @description TLS CA certificate file
                     */
                    TLSCACertFile?: string;
                    /**
                     * Format: binary
                     * @description TLS client certificate file
                     */
                    TLSCertFile?: string;
                    /**
                     * Format: binary
                     * @description TLS client key file
                     */
                    TLSKeyFile?: string;
                    /** @description Azure application ID. Required if environment(endpoint) type is set to 3 */
                    AzureApplicationID?: string;
                    /** @description Azure tenant ID. Required if environment(endpoint) type is set to 3 */
                    AzureTenantID?: string;
                    /** @description Azure authentication key. Required if environment(endpoint) type is set to 3 */
                    AzureAuthenticationKey?: string;
                    /** @description List of tag identifiers to which this environment(endpoint) is associated */
                    TagIds?: number[];
                    /** @description The check in interval for edge agent (in seconds) */
                    EdgeCheckinInterval?: number;
                    /** @description URL or IP address that will be used to establish a reverse tunnel */
                    EdgeTunnelServerAddress: string;
                    /** @description List of GPUs - json stringified array of {name, value} structs */
                    Gpus?: string;
                };
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.Endpoint"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Name is not unique */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    EndpointDeleteBatchDeprecated: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: components["requestBodies"]["endpoints.endpointDeleteBatchPayload"];
        responses: {
            /** @description Environment(s) successfully deleted. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Partial success. Some environments were deleted successfully, while others failed. */
            207: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["endpoints.endpointDeleteBatchPartialResponse"];
                };
            };
            /** @description Invalid request payload, such as missing required fields or fields not meeting validation criteria. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized access or operation not allowed. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error occurred while attempting to delete the specified environments. */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    EndpointInspect: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Environment(Endpoint) identifier */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.Endpoint"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Environment(Endpoint) not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    EndpointUpdate: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Environment(Endpoint) identifier */
                id: number;
            };
            cookie?: never;
        };
        /** @description Environment(Endpoint) details */
        requestBody: {
            content: {
                "application/json": components["schemas"]["endpoints.endpointUpdatePayload"];
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.Endpoint"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Environment(Endpoint) not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Name is not unique */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    EndpointDelete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Environment(Endpoint) identifier */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Environment successfully deleted. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invalid request payload, such as missing required fields or fields not meeting validation criteria. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized access or operation not allowed. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unable to find the environment with the specified identifier inside the database. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error occurred while attempting to delete the environment. */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    EndpointAssociationDelete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Environment(Endpoint) identifier */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Environment(Endpoint) not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    endpointDockerhubStatus: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description endpoint ID */
                id: number;
                /** @description registry ID */
                registryId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["endpoints.dockerhubStatusResponse"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description registry or endpoint not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    EndpointEdgeStatusInspect: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Environment(Endpoint) identifier */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "*/*": components["schemas"]["endpointedge.endpointEdgeStatusInspectResponse"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied to access environment(endpoint) */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Environment(Endpoint) not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    endpointForceUpdateService: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description endpoint identifier */
                id: number;
            };
            cookie?: never;
        };
        /** @description details */
        requestBody: {
            content: {
                "application/json": components["schemas"]["endpoints.forceUpdateServicePayload"];
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["swarm.ServiceUpdateResponse"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description endpoint not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    HelmList: {
        parameters: {
            query?: {
                /** @description specify an optional namespace */
                namespace?: string;
                /** @description specify an optional filter */
                filter?: string;
                /** @description specify an optional selector */
                selector?: string;
            };
            header?: never;
            path: {
                /** @description Environment(Endpoint) identifier */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["release.ReleaseElement"][];
                };
            };
            /** @description Invalid environment(endpoint) identifier */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Environment(Endpoint) or ServiceAccount not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    HelmInstall: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Environment(Endpoint) identifier */
                id: number;
            };
            cookie?: never;
        };
        /** @description Chart details */
        requestBody: {
            content: {
                "application/json": components["schemas"]["helm.installChartPayload"];
            };
        };
        responses: {
            /** @description Created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["release.Release"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Environment(Endpoint) or ServiceAccount not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    HelmDelete: {
        parameters: {
            query?: {
                /** @description An optional namespace */
                namespace?: string;
            };
            header?: never;
            path: {
                /** @description Environment(Endpoint) identifier */
                id: number;
                /** @description The name of the release/application to uninstall */
                release: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invalid environment(endpoint) id or bad request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Environment(Endpoint) or ServiceAccount not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error or helm error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    endpointRegistriesList: {
        parameters: {
            query?: {
                /** @description required if kubernetes environment, will show registries by namespace */
                namespace?: string;
            };
            header?: never;
            path: {
                /** @description Environment(Endpoint) identifier */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.Registry"][];
                };
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    endpointRegistryAccess: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Environment(Endpoint) identifier */
                id: number;
                /** @description Registry identifier */
                registryId: number;
            };
            cookie?: never;
        };
        /** @description details */
        requestBody: {
            content: {
                "application/json": components["schemas"]["endpoints.registryAccessPayload"];
            };
        };
        responses: {
            /** @description Success */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Endpoint not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    EndpointSettingsUpdate: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Environment(Endpoint) identifier */
                id: number;
            };
            cookie?: never;
        };
        /** @description Environment(Endpoint) details */
        requestBody: {
            content: {
                "application/json": components["schemas"]["endpoints.endpointSettingsUpdatePayload"];
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.Endpoint"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Environment(Endpoint) not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    EndpointSnapshot: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Environment(Endpoint) identifier */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Environment(Endpoint) not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    EndpointDeleteBatch: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: components["requestBodies"]["endpoints.endpointDeleteBatchPayload"];
        responses: {
            /** @description Environment(s) successfully deleted. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Partial success. Some environments were deleted successfully, while others failed. */
            207: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["endpoints.endpointDeleteBatchPartialResponse"];
                };
            };
            /** @description Invalid request payload, such as missing required fields or fields not meeting validation criteria. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized access or operation not allowed. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error occurred while attempting to delete the specified environments. */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    EndpointCreateGlobalKey: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "*/*": components["schemas"]["endpoints.endpointCreateGlobalKeyResponse"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    EndpointUpdateRelations: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Environment relations data */
        requestBody: {
            content: {
                "application/json": components["schemas"]["endpoints.endpointUpdateRelationsPayload"];
            };
        };
        responses: {
            /** @description Success */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    EndpointSnapshots: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    GitOperationRepoFilePreview: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Template details */
        requestBody: {
            content: {
                "application/json": components["schemas"]["gitops.repositoryFilePreviewPayload"];
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["gitops.fileResponse"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    GetAllKubernetesApplications: {
        parameters: {
            query: {
                /** @description Namespace name */
                namespace: string;
                /** @description Node name */
                nodeName: string;
            };
            header?: never;
            path: {
                /** @description Environment(Endpoint) identifier */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["kubernetes.K8sApplication"][];
                };
            };
            /** @description Invalid request payload, such as missing required fields or fields not meeting validation criteria. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unable to find an environment with the specified identifier. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error occurred while attempting to retrieve the list of applications from the cluster. */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    GetAllKubernetesApplicationsCount: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Environment identifier */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": number;
                };
            };
            /** @description Invalid request payload, such as missing required fields or fields not meeting validation criteria. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unable to find an environment with the specified identifier. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error occurred while attempting to retrieve the count of all applications from the cluster. */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    DeleteClusterRoleBindings: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Environment identifier */
                id: number;
            };
            cookie?: never;
        };
        /** @description A list of cluster role bindings to delete */
        requestBody: {
            content: {
                "application/json": string[];
            };
        };
        responses: {
            /** @description Success */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invalid request payload, such as missing required fields or fields not meeting validation criteria. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unable to find an environment with the specified identifier or unable to find a specific cluster role binding. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error occurred while attempting to delete cluster role bindings. */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    DeleteClusterRoles: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Environment identifier */
                id: number;
            };
            cookie?: never;
        };
        /** @description A list of cluster roles to delete */
        requestBody: {
            content: {
                "application/json": string[];
            };
        };
        responses: {
            /** @description Success */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invalid request payload, such as missing required fields or fields not meeting validation criteria. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unable to find an environment with the specified identifier or unable to find a specific cluster role. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error occurred while attempting to delete cluster roles. */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    GetAllKubernetesClusterRoleBindings: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Environment identifier */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["kubernetes.K8sClusterRoleBinding"][];
                };
            };
            /** @description Invalid request payload, such as missing required fields or fields not meeting validation criteria. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unable to find an environment with the specified identifier. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error occurred while attempting to retrieve the list of cluster role bindings. */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    GetAllKubernetesClusterRoles: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Environment identifier */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["kubernetes.K8sClusterRole"][];
                };
            };
            /** @description Invalid request payload, such as missing required fields or fields not meeting validation criteria. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unable to find an environment with the specified identifier. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error occurred while attempting to retrieve the list of cluster roles. */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    GetAllKubernetesConfigMaps: {
        parameters: {
            query: {
                /** @description Set to true to include information about applications that use the ConfigMaps in the response */
                isUsed: boolean;
            };
            header?: never;
            path: {
                /** @description Environment identifier */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["kubernetes.K8sConfigMap"][];
                };
            };
            /** @description Invalid request payload, such as missing required fields or fields not meeting validation criteria. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unable to find an environment with the specified identifier. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error occurred while attempting to retrieve all configmaps from the cluster. */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    GetAllKubernetesConfigMapsCount: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Environment identifier */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": number;
                };
            };
            /** @description Invalid request payload, such as missing required fields or fields not meeting validation criteria. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unable to find an environment with the specified identifier. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error occurred while attempting to retrieve the count of all configmaps from the cluster. */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    GetKubernetesCronJobs: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Environment identifier */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["kubernetes.K8sCronJob"][];
                };
            };
            /** @description Invalid request payload, such as missing required fields or fields not meeting validation criteria. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unable to find an environment with the specified identifier. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error occurred while attempting to retrieve the list of Cron Jobs. */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    DeleteCronJobs: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Environment identifier */
                id: number;
            };
            cookie?: never;
        };
        /** @description A map where the key is the namespace and the value is an array of Cron Jobs to delete */
        requestBody: {
            content: {
                "application/json": components["schemas"]["kubernetes.K8sCronJobDeleteRequests"];
            };
        };
        responses: {
            /** @description Success */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invalid request payload, such as missing required fields or fields not meeting validation criteria. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unable to find an environment with the specified identifier or unable to find a specific service account. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error occurred while attempting to delete Cron Jobs. */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    GetKubernetesDashboard: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Environment (Endpoint) identifier */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["kubernetes.K8sDashboard"][];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    GetAllKubernetesIngressControllers: {
        parameters: {
            query?: {
                /** @description Only return allowed ingress controllers */
                allowedOnly?: boolean;
            };
            header?: never;
            path: {
                /** @description Environment identifier */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["kubernetes.K8sIngressController"][];
                };
            };
            /** @description Invalid request payload, such as missing required fields or fields not meeting validation criteria. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unable to find an environment with the specified identifier. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error occurred while attempting to retrieve ingress controllers */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    UpdateKubernetesIngressControllers: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Environment identifier */
                id: number;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["kubernetes.K8sIngressControllerArray"];
        responses: {
            /** @description Success */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invalid request payload, such as missing required fields or fields not meeting validation criteria. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unable to find an environment with the specified identifier or unable to find the ingress controllers to update. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error occurred while attempting to update ingress controllers. */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    GetAllKubernetesClusterIngresses: {
        parameters: {
            query?: {
                /** @description Lookup services associated with each ingress */
                withServices?: boolean;
            };
            header?: never;
            path: {
                /** @description Environment identifier */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["kubernetes.K8sIngressInfo"][];
                };
            };
            /** @description Invalid request payload, such as missing required fields or fields not meeting validation criteria. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unable to find an environment with the specified identifier. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error occurred while attempting to retrieve ingresses. */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    GetAllKubernetesClusterIngressesCount: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Environment identifier */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": number;
                };
            };
            /** @description Invalid request payload, such as missing required fields or fields not meeting validation criteria. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unable to find an environment with the specified identifier. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error occurred while attempting to retrieve ingresses count. */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    DeleteKubernetesIngresses: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Environment identifier */
                id: number;
            };
            cookie?: never;
        };
        /** @description Ingress details */
        requestBody: {
            content: {
                "application/json": components["schemas"]["kubernetes.K8sIngressDeleteRequests"];
            };
        };
        responses: {
            /** @description Success */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invalid request payload, such as missing required fields or fields not meeting validation criteria. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unable to find an environment with the specified identifier or unable to find a specific ingress. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error occurred while attempting to delete specified ingresses. */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    GetKubernetesJobs: {
        parameters: {
            query?: {
                /** @description Whether to include Jobs that have a cronjob owner */
                includeCronJobChildren?: boolean;
            };
            header?: never;
            path: {
                /** @description Environment identifier */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["kubernetes.K8sJob"][];
                };
            };
            /** @description Invalid request payload, such as missing required fields or fields not meeting validation criteria. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unable to find an environment with the specified identifier. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error occurred while attempting to retrieve the list of Jobs. */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    DeleteJobs: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Environment identifier */
                id: number;
            };
            cookie?: never;
        };
        /** @description A map where the key is the namespace and the value is an array of Jobs to delete */
        requestBody: {
            content: {
                "application/json": components["schemas"]["kubernetes.K8sJobDeleteRequests"];
            };
        };
        responses: {
            /** @description Success */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invalid request payload, such as missing required fields or fields not meeting validation criteria. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unable to find an environment with the specified identifier or unable to find a specific service account. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error occurred while attempting to delete Jobs. */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    GetKubernetesMaxResourceLimits: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Environment(Endpoint) identifier */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.K8sNodesLimits"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unable to find an environment with the specified identifier. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error occurred while attempting to retrieve nodes limits. */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    GetApplicationsResources: {
        parameters: {
            query: {
                /** @description Node name */
                node: string;
            };
            header?: never;
            path: {
                /** @description Environment(Endpoint) identifier */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["kubernetes.K8sApplicationResource"];
                };
            };
            /** @description Invalid request payload, such as missing required fields or fields not meeting validation criteria. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unable to find an environment with the specified identifier. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error occurred while attempting to retrieve the total resource requests and limits for all applications from the cluster. */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    GetKubernetesMetricsForAllNodes: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Environment identifier */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["v1beta1.NodeMetricsList"];
                };
            };
            /** @description Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error occurred while attempting to retrieve the list of nodes with their live metrics. */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    GetKubernetesMetricsForNode: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Environment identifier */
                id: number;
                /** @description Node identifier */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["v1beta1.NodeMetrics"];
                };
            };
            /** @description Invalid request payload, such as missing required fields or fields not meeting validation criteria. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error occurred while attempting to retrieve the live metrics for the specified node. */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    GetKubernetesMetricsForAllPods: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Environment identifier */
                id: number;
                /** @description Namespace */
                namespace: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["v1beta1.PodMetricsList"];
                };
            };
            /** @description Invalid request payload, such as missing required fields or fields not meeting validation criteria. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error occurred while attempting to retrieve the list of pods with their live metrics. */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    GetKubernetesMetricsForPod: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Environment identifier */
                id: number;
                /** @description Namespace */
                namespace: string;
                /** @description Pod identifier */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["v1beta1.PodMetrics"];
                };
            };
            /** @description Invalid request payload, such as missing required fields or fields not meeting validation criteria. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error occurred while attempting to retrieve the live metrics for the specified pod. */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    GetKubernetesNamespaces: {
        parameters: {
            query: {
                /** @description When set to true, include the resource quota information as part of the Namespace information. Default is false */
                withResourceQuota: boolean;
            };
            header?: never;
            path: {
                /** @description Environment identifier */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.K8sNamespaceInfo"][];
                };
            };
            /** @description Invalid request payload, such as missing required fields or fields not meeting validation criteria. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unable to find an environment with the specified identifier. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error occurred while attempting to retrieve the list of namespaces. */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    UpdateKubernetesNamespaceDeprecated: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Environment identifier */
                id: number;
                /** @description Namespace */
                namespace: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["kubernetes.K8sNamespaceDetails"];
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.K8sNamespaceInfo"];
                };
            };
            /** @description Invalid request payload, such as missing required fields or fields not meeting validation criteria. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unable to find an environment with the specified identifier or unable to find a specific namespace. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error occurred while attempting to update the namespace. */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    CreateKubernetesNamespace: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Environment identifier */
                id: number;
            };
            cookie?: never;
        };
        /** @description Namespace configuration details */
        requestBody: {
            content: {
                "application/json": components["schemas"]["kubernetes.K8sNamespaceDetails"];
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.K8sNamespaceInfo"];
                };
            };
            /** @description Invalid request payload, such as missing required fields or fields not meeting validation criteria. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Conflict - the namespace already exists. */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error occurred while attempting to create the namespace. */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    DeleteKubernetesNamespace: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Environment identifier */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "*/*": string;
                };
            };
            /** @description Invalid request payload, such as missing required fields or fields not meeting validation criteria. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized access or operation not allowed. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error occurred while attempting to delete the namespace. */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    GetKubernetesNamespace: {
        parameters: {
            query: {
                /** @description When set to true, include the resource quota information as part of the Namespace information. Default is false */
                withResourceQuota: boolean;
            };
            header?: never;
            path: {
                /** @description Environment identifier */
                id: number;
                /** @description The namespace name to get details for */
                namespace: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.K8sNamespaceInfo"];
                };
            };
            /** @description Invalid request payload, such as missing required fields or fields not meeting validation criteria. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unable to find an environment with the specified identifier or unable to find a specific namespace. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error occurred while attempting to retrieve specified namespace information. */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    UpdateKubernetesNamespace: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Environment identifier */
                id: number;
                /** @description Namespace */
                namespace: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["kubernetes.K8sNamespaceDetails"];
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.K8sNamespaceInfo"];
                };
            };
            /** @description Invalid request payload, such as missing required fields or fields not meeting validation criteria. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unable to find an environment with the specified identifier or unable to find a specific namespace. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error occurred while attempting to update the namespace. */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    GetKubernetesConfigMap: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Environment identifier */
                id: number;
                /** @description The namespace name where the configmap is located */
                namespace: string;
                /** @description The configmap name to get details for */
                configmap: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["kubernetes.K8sConfigMap"];
                };
            };
            /** @description Invalid request payload, such as missing required fields or fields not meeting validation criteria. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unable to find an environment with the specified identifier or a configmap with the specified name in the given namespace. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error occurred while attempting to retrieve a configmap by name within the specified namespace. */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    GetKubernetesIngressControllersByNamespace: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Environment identifier */
                id: number;
                /** @description Namespace */
                namespace: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["kubernetes.K8sIngressController"][];
                };
            };
            /** @description Invalid request payload, such as missing required fields or fields not meeting validation criteria. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unable to find an environment with the specified identifier or a namespace with the specified name. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error occurred while attempting to retrieve ingress controllers by a namespace */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    UpdateKubernetesIngressControllersByNamespace: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Environment identifier */
                id: number;
                /** @description Namespace name */
                namespace: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["kubernetes.K8sIngressControllerArray"];
        responses: {
            /** @description Success */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invalid request payload, such as missing required fields or fields not meeting validation criteria. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unable to find an environment with the specified identifier. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error occurred while attempting to update ingress controllers by namespace. */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    GetAllKubernetesIngresses: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Environment identifier */
                id: number;
                /** @description Namespace name */
                namespace: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["kubernetes.K8sIngressInfo"][];
                };
            };
            /** @description Invalid request payload, such as missing required fields or fields not meeting validation criteria. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unable to find an environment with the specified identifier. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error occurred while attempting to retrieve ingresses */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    UpdateKubernetesIngress: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Environment identifier */
                id: number;
                /** @description Namespace name */
                namespace: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["kubernetes.K8sIngressInfo"];
        responses: {
            /** @description Success */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invalid request payload, such as missing required fields or fields not meeting validation criteria. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unable to find an environment with the specified identifier or unable to find the specified ingress. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error occurred while attempting to update the specified ingress. */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    CreateKubernetesIngress: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Environment identifier */
                id: number;
                /** @description Namespace name */
                namespace: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["kubernetes.K8sIngressInfo"];
        responses: {
            /** @description Success */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invalid request payload, such as missing required fields or fields not meeting validation criteria. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unable to find an environment with the specified identifier. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Conflict - an ingress with the same name already exists in the specified namespace. */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error occurred while attempting to create an ingress. */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    GetKubernetesIngress: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Environment identifier */
                id: number;
                /** @description Namespace name */
                namespace: string;
                /** @description Ingress name */
                ingress: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["kubernetes.K8sIngressInfo"];
                };
            };
            /** @description Invalid request payload, such as missing required fields or fields not meeting validation criteria. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unable to find an environment with the specified identifier or unable to find an ingress with the specified name. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error occurred while attempting to retrieve an ingress. */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    GetKubernetesSecret: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Environment identifier */
                id: number;
                /** @description The namespace name where the secret is located */
                namespace: string;
                /** @description The secret name to get details for */
                secret: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["kubernetes.K8sSecret"];
                };
            };
            /** @description Invalid request payload, such as missing required fields or fields not meeting validation criteria. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unable to find an environment with the specified identifier. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error occurred while attempting to retrieve a secret by name belong in a namespace. */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    GetKubernetesServicesByNamespace: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Environment identifier */
                id: number;
                /** @description Namespace name */
                namespace: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["kubernetes.K8sServiceInfo"][];
                };
            };
            /** @description Invalid request payload, such as missing required fields or fields not meeting validation criteria. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unable to find an environment with the specified identifier. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error occurred while attempting to retrieve all services for a namespace. */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    UpdateKubernetesService: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Environment identifier */
                id: number;
                /** @description Namespace name */
                namespace: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["kubernetes.K8sServiceInfo"];
        responses: {
            /** @description Success */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invalid request payload, such as missing required fields or fields not meeting validation criteria. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unable to find an environment with the specified identifier or unable to find the service to update. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error occurred while attempting to update a service. */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    CreateKubernetesService: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Environment identifier */
                id: number;
                /** @description Namespace name */
                namespace: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["kubernetes.K8sServiceInfo"];
        responses: {
            /** @description Success */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invalid request payload, such as missing required fields or fields not meeting validation criteria. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unable to find an environment with the specified identifier. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error occurred while attempting to create a service. */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    KubernetesNamespacesToggleSystem: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Environment identifier */
                id: number;
                /** @description Namespace name */
                namespace: string;
            };
            cookie?: never;
        };
        /** @description Update details */
        requestBody: {
            content: {
                "application/json": components["schemas"]["kubernetes.namespacesToggleSystemPayload"];
            };
        };
        responses: {
            /** @description Success */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invalid request payload, such as missing required fields or fields not meeting validation criteria. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unable to find an environment with the specified identifier or unable to find the namespace to update. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error occurred while attempting to update the system state of the namespace. */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    GetKubernetesVolumesInNamespace: {
        parameters: {
            query?: {
                /** @description When set to True, include the applications that are using the volumes. It is set to false by default */
                withApplications?: boolean;
            };
            header?: never;
            path: {
                /** @description Environment identifier */
                id: number;
                /** @description Namespace identifier */
                namespace: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        [key: string]: components["schemas"]["kubernetes.K8sVolumeInfo"];
                    };
                };
            };
            /** @description Invalid request payload, such as missing required fields or fields not meeting validation criteria. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized access or operation not allowed. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error occurred while attempting to retrieve kubernetes volumes in the namespace. */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    GetKubernetesNamespacesCount: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Environment identifier */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": number;
                };
            };
            /** @description Invalid request payload, such as missing required fields or fields not meeting validation criteria. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unable to find an environment with the specified identifier. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error occurred while attempting to compute the namespace count. */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    GetKubernetesNodesLimits: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Environment(Endpoint) identifier */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.K8sNodesLimits"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unable to find an environment with the specified identifier. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error occurred while attempting to retrieve nodes limits. */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    GetKubernetesRBACStatus: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Environment(Endpoint) identifier */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description RBAC status */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": boolean;
                };
            };
            /** @description Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unable to find an environment with the specified identifier. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error occurred while attempting to retrieve the RBAC status. */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    DeleteRoleBindings: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Environment identifier */
                id: number;
            };
            cookie?: never;
        };
        /** @description A map where the key is the namespace and the value is an array of role bindings to delete */
        requestBody: {
            content: {
                "application/json": components["schemas"]["kubernetes.K8sRoleBindingDeleteRequests"];
            };
        };
        responses: {
            /** @description Success */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invalid request payload, such as missing required fields or fields not meeting validation criteria. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unable to find an environment with the specified identifier or unable to find a specific role binding. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error occurred while attempting to delete role bindings. */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    GetKubernetesRoleBindings: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Environment identifier */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["kubernetes.K8sRoleBinding"][];
                };
            };
            /** @description Invalid request payload, such as missing required fields or fields not meeting validation criteria. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unable to find an environment with the specified identifier. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error occurred while attempting to retrieve the list of role bindings. */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    GetKubernetesRoles: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Environment identifier */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["kubernetes.K8sRole"][];
                };
            };
            /** @description Invalid request payload, such as missing required fields or fields not meeting validation criteria. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unable to find an environment with the specified identifier. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error occurred while attempting to retrieve the list of roles. */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    DeleteRoles: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Environment identifier */
                id: number;
            };
            cookie?: never;
        };
        /** @description A map where the key is the namespace and the value is an array of roles to delete */
        requestBody: {
            content: {
                "application/json": components["schemas"]["kubernetes.K8sRoleDeleteRequests"];
            };
        };
        responses: {
            /** @description Success */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invalid request payload, such as missing required fields or fields not meeting validation criteria. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unable to find an environment with the specified identifier or unable to find a specific role. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error occurred while attempting to delete roles. */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    GetKubernetesSecrets: {
        parameters: {
            query: {
                /** @description When set to true, associate the Secrets with the applications that use them */
                isUsed: boolean;
            };
            header?: never;
            path: {
                /** @description Environment identifier */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["kubernetes.K8sSecret"][];
                };
            };
            /** @description Invalid request payload, such as missing required fields or fields not meeting validation criteria. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unable to find an environment with the specified identifier. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error occurred while attempting to retrieve all secrets from the cluster. */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    GetKubernetesSecretsCount: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Environment identifier */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": number;
                };
            };
            /** @description Invalid request payload, such as missing required fields or fields not meeting validation criteria. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unable to find an environment with the specified identifier. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error occurred while attempting to retrieve the count of all secrets from the cluster. */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    DeleteServiceAccounts: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Environment identifier */
                id: number;
            };
            cookie?: never;
        };
        /** @description A map where the key is the namespace and the value is an array of service accounts to delete */
        requestBody: {
            content: {
                "application/json": components["schemas"]["kubernetes.K8sServiceAccountDeleteRequests"];
            };
        };
        responses: {
            /** @description Success */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invalid request payload, such as missing required fields or fields not meeting validation criteria. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unable to find an environment with the specified identifier or unable to find a specific service account. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error occurred while attempting to delete service accounts. */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    GetKubernetesServiceAccounts: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Environment identifier */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["kubernetes.K8sServiceAccount"][];
                };
            };
            /** @description Invalid request payload, such as missing required fields or fields not meeting validation criteria. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unable to find an environment with the specified identifier. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error occurred while attempting to retrieve the list of service accounts. */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    GetKubernetesServices: {
        parameters: {
            query?: {
                /** @description Lookup applications associated with each service */
                withApplications?: boolean;
            };
            header?: never;
            path: {
                /** @description Environment identifier */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["kubernetes.K8sServiceInfo"][];
                };
            };
            /** @description Invalid request payload, such as missing required fields or fields not meeting validation criteria. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unable to find an environment with the specified identifier. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error occurred while attempting to retrieve all services. */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    GetAllKubernetesServicesCount: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Environment identifier */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": number;
                };
            };
            /** @description Invalid request payload, such as missing required fields or fields not meeting validation criteria. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unable to find an environment with the specified identifier. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error occurred while attempting to retrieve the total count of all services. */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    DeleteKubernetesServices: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Environment identifier */
                id: number;
            };
            cookie?: never;
        };
        /** @description A map where the key is the namespace and the value is an array of services to delete */
        requestBody: {
            content: {
                "application/json": components["schemas"]["kubernetes.K8sServiceDeleteRequests"];
            };
        };
        responses: {
            /** @description Success */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invalid request payload, such as missing required fields or fields not meeting validation criteria. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unable to find an environment with the specified identifier or unable to find a specific service. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error occurred while attempting to delete services. */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    GetAllKubernetesVolumes: {
        parameters: {
            query?: {
                /** @description When set to True, include the applications that are using the volumes. It is set to false by default */
                withApplications?: boolean;
            };
            header?: never;
            path: {
                /** @description Environment identifier */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        [key: string]: components["schemas"]["kubernetes.K8sVolumeInfo"];
                    };
                };
            };
            /** @description Invalid request payload, such as missing required fields or fields not meeting validation criteria. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized access or operation not allowed. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error occurred while attempting to retrieve kubernetes volumes. */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    GetKubernetesVolume: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Environment identifier */
                id: number;
                /** @description Namespace identifier */
                namespace: string;
                /** @description Volume name */
                volume: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["kubernetes.K8sVolumeInfo"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getAllKubernetesVolumesCount: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Environment identifier */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": number;
                };
            };
            /** @description Invalid request payload, such as missing required fields or fields not meeting validation criteria. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized access or operation not allowed. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error occurred while attempting to retrieve kubernetes volumes count. */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    GetKubernetesConfig: {
        parameters: {
            query?: {
                /** @description will include only these environments(endpoints) */
                ids?: number[];
                /** @description will exclude these environments(endpoints) */
                excludeIds?: number[];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": Record<string, never>;
                    " application/yaml": Record<string, never>;
                };
            };
            /** @description Invalid request payload, such as missing required fields or fields not meeting validation criteria. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unable to find an environment with the specified identifier. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error occurred while attempting to generate the kubeconfig file. */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    LDAPCheck: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description details */
        requestBody: {
            content: {
                "application/json": components["schemas"]["ldap.checkPayload"];
            };
        };
        responses: {
            /** @description Success */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    MOTD: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["motd.motdResponse"];
                };
            };
        };
    };
    OpenAMTConfigure: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description OpenAMT Settings */
        requestBody: {
            content: {
                "application/json": components["schemas"]["openamt.openAMTConfigurePayload"];
            };
        };
        responses: {
            /** @description Success */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied to access settings */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    openAMTActivate: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Environment identifier */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied to access settings */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    OpenAMTDevices: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Environment(Endpoint) identifier */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied to access settings */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    DeviceAction: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Environment identifier */
                id: number;
                /** @description Device identifier */
                deviceId: number;
            };
            cookie?: never;
        };
        /** @description Device Action */
        requestBody: {
            content: {
                "application/json": components["schemas"]["openamt.deviceActionPayload"];
            };
        };
        responses: {
            /** @description Success */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied to access settings */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    DeviceFeatures: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Environment identifier */
                id: number;
                /** @description Device identifier */
                deviceId: number;
            };
            cookie?: never;
        };
        /** @description Device Features */
        requestBody: {
            content: {
                "application/json": components["schemas"]["openamt.deviceFeaturesPayload"];
            };
        };
        responses: {
            /** @description Success */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied to access settings */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    OpenAMTHostInfo: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Environment identifier */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied to access settings */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    RegistryList: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.Registry"][];
                };
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    RegistryCreate: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Registry details */
        requestBody: {
            content: {
                "application/json": components["schemas"]["registries.registryCreatePayload"];
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.Registry"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Another registry with the same name or same URL & credentials already exists */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    RegistryInspect: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Registry identifier */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.Registry"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied to access registry */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Registry not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    RegistryUpdate: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Registry identifier */
                id: number;
            };
            cookie?: never;
        };
        /** @description Registry details */
        requestBody: {
            content: {
                "application/json": components["schemas"]["registries.registryUpdatePayload"];
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.Registry"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Registry not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Another registry with the same name or same URL & credentials already exists */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    RegistryDelete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Registry identifier */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Registry not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    RegistryConfigure: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Registry identifier */
                id: number;
            };
            cookie?: never;
        };
        /** @description Registry configuration */
        requestBody: {
            content: {
                "application/json": components["schemas"]["registries.registryConfigurePayload"];
            };
        };
        responses: {
            /** @description Success */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Registry not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    ResourceControlCreate: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Resource control details */
        requestBody: {
            content: {
                "application/json": components["schemas"]["resourcecontrols.resourceControlCreatePayload"];
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.ResourceControl"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description A resource control is already associated to this resource */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    ResourceControlUpdate: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Resource control identifier */
                id: number;
            };
            cookie?: never;
        };
        /** @description Resource control details */
        requestBody: {
            content: {
                "application/json": components["schemas"]["resourcecontrols.resourceControlUpdatePayload"];
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.ResourceControl"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Resource control not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    ResourceControlDelete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Resource control identifier */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Resource control not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    Restore: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Restore request payload */
        requestBody: {
            content: {
                "application/json": components["schemas"]["backup.restorePayload"];
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    RoleList: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.Role"][];
                };
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    SettingsInspect: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.Settings"];
                };
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    SettingsUpdate: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description New settings */
        requestBody: {
            content: {
                "application/json": components["schemas"]["settings.settingsUpdatePayload"];
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.Settings"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    SettingsPublic: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["settings.publicSettingsResponse"];
                };
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    SSLInspect: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.SSLSettings"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied to access settings */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    SSLUpdate: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description SSL Settings */
        requestBody: {
            content: {
                "application/json": components["schemas"]["ssl.sslUpdatePayload"];
            };
        };
        responses: {
            /** @description Success */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied to access settings */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    StackList: {
        parameters: {
            query?: {
                /** @description Filters to process on the stack list. Encoded as JSON (a map[string]string). For example, {'SwarmID': 'jpofkc0i9uo9wtx1zesuk649w'} will only return stacks that are part of the specified Swarm cluster. Available filters: EndpointID, SwarmID. */
                filters?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "*/*": components["schemas"]["portainer.Stack"][];
                };
            };
            /** @description Success */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    StackInspect: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Stack identifier */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.Stack"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Stack not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    StackUpdate: {
        parameters: {
            query: {
                /** @description Environment identifier */
                endpointId: number;
            };
            header?: never;
            path: {
                /** @description Stack identifier */
                id: number;
            };
            cookie?: never;
        };
        /** @description Stack details */
        requestBody: {
            content: {
                "application/json": components["schemas"]["stacks.updateSwarmStackPayload"];
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.Stack"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    StackDelete: {
        parameters: {
            query: {
                /** @description Set to true to delete an external stack. Only external Swarm stacks are supported */
                external?: boolean;
                /** @description Environment identifier */
                endpointId: number;
            };
            header?: never;
            path: {
                /** @description Stack identifier */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    StackAssociate: {
        parameters: {
            query: {
                /** @description Environment identifier */
                endpointId: number;
                /** @description Swarm identifier */
                swarmId: number;
                /** @description Indicates whether the stack is orphaned */
                orphanedRunning: boolean;
            };
            header?: never;
            path: {
                /** @description Stack identifier */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.Stack"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Stack not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    StackFileInspect: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Stack identifier */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["stacks.stackFileResponse"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Stack not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    StackUpdateGit: {
        parameters: {
            query?: {
                /** @description Stacks created before version 1.18.0 might not have an associated environment(endpoint) identifier. Use this optional parameter to set the environment(endpoint) identifier used by the stack. */
                endpointId?: number;
            };
            header?: never;
            path: {
                /** @description Stack identifier */
                id: number;
            };
            cookie?: never;
        };
        /** @description Git configs for pull and redeploy a stack */
        requestBody: {
            content: {
                "application/json": components["schemas"]["stacks.stackGitUpdatePayload"];
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.Stack"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    StackGitRedeploy: {
        parameters: {
            query?: {
                /** @description Stacks created before version 1.18.0 might not have an associated environment(endpoint) identifier. Use this optional parameter to set the environment(endpoint) identifier used by the stack. */
                endpointId?: number;
            };
            header?: never;
            path: {
                /** @description Stack identifier */
                id: number;
            };
            cookie?: never;
        };
        /** @description Git configs for pull and redeploy of a stack. **StackName** may only be populated for Kuberenetes stacks, and if specified with a blank string, it will be set to blank */
        requestBody: {
            content: {
                "application/json": components["schemas"]["stacks.stackGitRedployPayload"];
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.Stack"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    StackMigrate: {
        parameters: {
            query?: {
                /** @description Stacks created before version 1.18.0 might not have an associated environment(endpoint) identifier. Use this optional parameter to set the environment(endpoint) identifier used by the stack. */
                endpointId?: number;
            };
            header?: never;
            path: {
                /** @description Stack identifier */
                id: number;
            };
            cookie?: never;
        };
        /** @description Stack migration details */
        requestBody: {
            content: {
                "application/json": components["schemas"]["stacks.stackMigratePayload"];
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.Stack"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Stack not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description A stack with the same name is already running on the target environment(endpoint) */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    StackStart: {
        parameters: {
            query: {
                /** @description Environment identifier */
                endpointId: number;
            };
            header?: never;
            path: {
                /** @description Stack identifier */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "*/*": components["schemas"]["portainer.Stack"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Stack name is not unique */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    StackStop: {
        parameters: {
            query: {
                /** @description Environment identifier */
                endpointId: number;
            };
            header?: never;
            path: {
                /** @description Stack identifier */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "*/*": components["schemas"]["portainer.Stack"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    StackCreateKubernetesGit: {
        parameters: {
            query: {
                /** @description Identifier of the environment that will be used to deploy the stack */
                endpointId: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description stack config */
        requestBody: {
            content: {
                "application/json": components["schemas"]["stacks.kubernetesGitDeploymentPayload"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.Stack"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Stack name or webhook ID already exists */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    StackCreateKubernetesFile: {
        parameters: {
            query: {
                /** @description Identifier of the environment that will be used to deploy the stack */
                endpointId: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description stack config */
        requestBody: {
            content: {
                "application/json": components["schemas"]["stacks.kubernetesStringDeploymentPayload"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.Stack"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    StackCreateKubernetesUrl: {
        parameters: {
            query: {
                /** @description Identifier of the environment that will be used to deploy the stack */
                endpointId: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description stack config */
        requestBody: {
            content: {
                "application/json": components["schemas"]["stacks.kubernetesManifestURLDeploymentPayload"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.Stack"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    StackCreateDockerStandaloneFile: {
        parameters: {
            query: {
                /** @description Identifier of the environment that will be used to deploy the stack */
                endpointId: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "multipart/form-data": {
                    /** @description Name of the stack */
                    Name: string;
                    /** @description Environment variables passed during deployment, represented as a JSON array [{'name': 'name', 'value': 'value'}]. */
                    Env?: string;
                    /**
                     * Format: binary
                     * @description Stack file
                     */
                    file?: string;
                };
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.Stack"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    StackCreateDockerStandaloneRepository: {
        parameters: {
            query: {
                /** @description Identifier of the environment that will be used to deploy the stack */
                endpointId: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description stack config */
        requestBody: {
            content: {
                "application/json": components["schemas"]["stacks.composeStackFromGitRepositoryPayload"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.Stack"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Stack name or webhook ID already exists */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    StackCreateDockerStandaloneString: {
        parameters: {
            query: {
                /** @description Identifier of the environment that will be used to deploy the stack */
                endpointId: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description stack config */
        requestBody: {
            content: {
                "application/json": components["schemas"]["stacks.composeStackFromFileContentPayload"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.Stack"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    StackCreateDockerSwarmFile: {
        parameters: {
            query: {
                /** @description Identifier of the environment that will be used to deploy the stack */
                endpointId: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "multipart/form-data": {
                    /** @description Name of the stack */
                    Name?: string;
                    /** @description Swarm cluster identifier. */
                    SwarmID?: string;
                    /** @description Environment variables passed during deployment, represented as a JSON array [{'name': 'name', 'value': 'value'}]. Optional */
                    Env?: string;
                    /**
                     * Format: binary
                     * @description Stack file
                     */
                    file?: string;
                };
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.Stack"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    StackCreateDockerSwarmRepository: {
        parameters: {
            query: {
                /** @description Identifier of the environment that will be used to deploy the stack */
                endpointId: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description stack config */
        requestBody: {
            content: {
                "application/json": components["schemas"]["stacks.swarmStackFromGitRepositoryPayload"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.Stack"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Stack name or webhook ID already exists */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    StackCreateDockerSwarmString: {
        parameters: {
            query: {
                /** @description Identifier of the environment that will be used to deploy the stack */
                endpointId: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description stack config */
        requestBody: {
            content: {
                "application/json": components["schemas"]["stacks.swarmStackFromFileContentPayload"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.Stack"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    StackDeleteKubernetesByName: {
        parameters: {
            query: {
                /** @description Set to true to delete an external stack. Only external Swarm stacks are supported */
                external?: boolean;
                /** @description Environment identifier */
                endpointId: number;
            };
            header?: never;
            path: {
                /** @description Stack name */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    WebhookInvoke: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Stack identifier */
                webhookID: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Autoupdate for the stack isn't available */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    StatusInspect: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["system.status"];
                };
            };
        };
    };
    systemInfo: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["system.systemInfoResponse"];
                };
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    systemNodesCount: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["system.nodesCountResponse"];
                };
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    systemStatus: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["system.status"];
                };
            };
        };
    };
    systemUpgrade: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["system.status"];
                };
            };
        };
    };
    systemVersion: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["system.versionResponse"];
                };
            };
        };
    };
    TagList: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.Tag"][];
                };
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    TagCreate: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Tag details */
        requestBody: {
            content: {
                "application/json": components["schemas"]["tags.tagCreatePayload"];
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.Tag"];
                };
            };
            /** @description This name is already associated to a tag */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    TagDelete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Tag identifier */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Tag not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    TeamMembershipList: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.TeamMembership"][];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    TeamMembershipCreate: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Team membership details */
        requestBody: {
            content: {
                "application/json": components["schemas"]["teammemberships.teamMembershipCreatePayload"];
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.TeamMembership"];
                };
            };
            /** @description Success */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied to manage memberships */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Team membership already registered */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    TeamMembershipUpdate: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Team membership identifier */
                id: number;
            };
            cookie?: never;
        };
        /** @description Team membership details */
        requestBody: {
            content: {
                "application/json": components["schemas"]["teammemberships.teamMembershipUpdatePayload"];
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.TeamMembership"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description TeamMembership not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    TeamMembershipDelete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description TeamMembership identifier */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description TeamMembership not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    TeamList: {
        parameters: {
            query?: {
                /** @description Only list teams that the user is leader of */
                onlyLedTeams?: boolean;
                /** @description Identifier of the environment(endpoint) that will be used to filter the authorized teams */
                environmentId?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.Team"][];
                };
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    TeamCreate: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description details */
        requestBody: {
            content: {
                "application/json": components["schemas"]["teams.teamCreatePayload"];
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.Team"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description A team with the same name already exists */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    TeamInspect: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Team identifier */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.Team"];
                };
            };
            /** @description Success */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Team not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    TeamUpdate: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Team identifier */
                id: number;
            };
            cookie?: never;
        };
        /** @description Team details */
        requestBody: {
            content: {
                "application/json": components["schemas"]["teams.teamUpdatePayload"];
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.Team"];
                };
            };
            /** @description Success */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Team not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    TeamDelete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Team Id */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Team not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    TeamMemberships: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Team Id */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.TeamMembership"][];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    TemplateList: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["templates.listResponse"];
                };
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    TemplateFile: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Template identifier */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["templates.fileResponse"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    HelmRepoSearch: {
        parameters: {
            query: {
                /** @description Helm repository URL */
                repo: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": string;
                };
            };
            /** @description Bad request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    HelmShow: {
        parameters: {
            query: {
                /** @description Helm repository URL */
                repo: string;
                /** @description Chart name */
                chart: string;
            };
            header?: never;
            path: {
                /** @description chart/values/readme */
                command: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "text/plain": string;
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Environment(Endpoint) or ServiceAccount not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    UploadTLS: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description TLS file type. Valid values are 'ca', 'cert' or 'key'. */
                certificate: "ca" | "cert" | "key";
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "multipart/form-data": {
                    /** @description Folder where the TLS file will be stored. Will be created if not existing */
                    folder: string;
                    /**
                     * Format: binary
                     * @description The file to upload
                     */
                    file: string;
                };
            };
        };
        responses: {
            /** @description Success */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    UserList: {
        parameters: {
            query?: {
                /** @description Identifier of the environment(endpoint) that will be used to filter the authorized users */
                environmentId?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.User"][];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    UserCreate: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description User details */
        requestBody: {
            content: {
                "application/json": components["schemas"]["users.userCreatePayload"];
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.User"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description User already exists */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    UserInspect: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description User identifier */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.User"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description User not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    UserUpdate: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description User identifier */
                id: number;
            };
            cookie?: never;
        };
        /** @description User details */
        requestBody: {
            content: {
                "application/json": components["schemas"]["users.userUpdatePayload"];
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.User"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description User not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Username already exist */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    UserDelete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description User identifier */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description User not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    HelmUserRepositoriesList: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description User identifier */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["users.helmUserRepositoryResponse"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    HelmUserRepositoryCreate: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description User identifier */
                id: number;
            };
            cookie?: never;
        };
        /** @description Helm Repository */
        requestBody: {
            content: {
                "application/json": components["schemas"]["users.addHelmRepoUrlPayload"];
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.HelmUserRepository"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    HelmUserRepositoryDelete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description User identifier */
                id: number;
                /** @description Repository identifier */
                repositoryID: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    UserMembershipsInspect: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description User identifier */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.TeamMembership"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    UserUpdatePassword: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description identifier */
                id: number;
            };
            cookie?: never;
        };
        /** @description details */
        requestBody: {
            content: {
                "application/json": components["schemas"]["users.userUpdatePasswordPayload"];
            };
        };
        responses: {
            /** @description Success */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description User not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    UserGetAPIKeys: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description User identifier */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.APIKey"][];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description User not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    UserGenerateAPIKey: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description User identifier */
                id: number;
            };
            cookie?: never;
        };
        /** @description details */
        requestBody: {
            content: {
                "application/json": components["schemas"]["users.userAccessTokenCreatePayload"];
            };
        };
        responses: {
            /** @description Created */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["users.accessTokenResponse"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description User not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    UserRemoveAPIKey: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description User identifier */
                id: number;
                /** @description Api Key identifier */
                keyID: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    UserAdminCheck: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description User not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    UserAdminInit: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description User details */
        requestBody: {
            content: {
                "application/json": components["schemas"]["users.adminInitPayload"];
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.User"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Admin user already initialized */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    CurrentUserInspect: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["portainer.User"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Permission denied */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description User not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
}
